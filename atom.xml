<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Binger‘s Blog]]></title>
  <subtitle><![CDATA[Python and Quant]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.kekefund.com/"/>
  <updated>2016-01-04T08:00:02.000Z</updated>
  <id>http://www.kekefund.com/</id>
  
  <author>
    <name><![CDATA[Binger]]></name>
    <email><![CDATA[cbbing@163.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[IP代理池的实现框架(安装包)]]></title>
    <link href="http://www.kekefund.com/2016/01/04/python-ip-proxy-frame/"/>
    <id>http://www.kekefund.com/2016/01/04/python-ip-proxy-frame/</id>
    <published>2016-01-04T07:58:00.000Z</published>
    <updated>2016-01-04T08:00:02.000Z</updated>
    <content type="html"><![CDATA[<p>上一篇 <a href="http://kekefund.com/2015/11/17/pytho-ip-proxy/" target="_blank" rel="external">IP代理池的实现</a> 讲解了IP代理池的实现细节。</p>
<p>由于爬虫多个项目都需要用到IP代理，打造一个公用的IP代理库就很有必要。本文主要讲解公用的IP代理库的实现框架。</p>
<blockquote>
<p>实现思路如下：</p>
<p>1，数据抓取：从各个IP代理网站抓取大量IP数据；</p>
<p>2，数据筛选：Ping每个IP，连接速度&lt;1.5s的IP地址入库；</p>
<p>3，定时更新：设置定时任务，每日重新Ping数据库内的IP，更新连接速度；</p>
<p>4，定时新增：设置定时任务，每日定时从IP代理网站取新数据</p>
<p>5，提供获取接口</p>
</blockquote>
<a id="more"></a>
<h1 id="1，数据抓取">1，数据抓取</h1><h2 id="定义IPItem">定义IPItem</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span>:</span></span><br><span class="line">        <span class="keyword">self</span>.ip = <span class="string">''</span>    <span class="comment"># IP</span></span><br><span class="line">        <span class="keyword">self</span>.port = <span class="string">''</span>  <span class="comment"># Port</span></span><br><span class="line">        <span class="keyword">self</span>.addr = <span class="string">''</span>  <span class="comment"># 位置</span></span><br><span class="line">        <span class="keyword">self</span>.type = <span class="string">''</span>  <span class="comment"># 类型:http, https</span></span><br><span class="line">        <span class="keyword">self</span>.anonymous = <span class="string">''</span> <span class="comment"># 匿名度</span></span><br><span class="line">        <span class="keyword">self</span>.speed = -<span class="number">1</span> <span class="comment">#速度</span></span><br><span class="line">        <span class="keyword">self</span>.source = <span class="string">''</span></span><br><span class="line">        <span class="keyword">self</span>.create_time = <span class="string">''</span></span><br><span class="line">        <span class="keyword">self</span>.update_time = <span class="string">''</span></span><br></pre></td></tr></table></figure>
<h2 id="解析多个代理网站的IP，返回IPItem列表">解析多个代理网站的IP，返回IPItem列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># parse ip web</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    ip_items_haodaili =self.parse_haodaili()</span><br><span class="line">    ip_items_kuaidaili = self.parse_kuaidaili()</span><br><span class="line">    ip_items_xici = self.parse_xici()</span><br><span class="line">    ip_items_66 = self.parse_66ip()</span><br><span class="line"></span><br><span class="line">    ip_items = []</span><br><span class="line">    ip_items.extend(ip_items_haodaili)</span><br><span class="line">    ip_items.extend(ip_items_kuaidaili)</span><br><span class="line">    ip_items.extend(ip_items_xici)</span><br><span class="line">    ip_items.extend(ip_items_66)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ip_items</span><br></pre></td></tr></table></figure>
<h1 id="2，数据筛选">2，数据筛选</h1><p>多线程批量刷新ip_items，只保留ping速度在1.5s以内的ip_item。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_ip_speed</span><span class="params">(self, ip_items)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#多线程</span></span><br><span class="line">    pool = ThreadPool(processes=<span class="number">20</span>)</span><br><span class="line">    pool.map(self.ping_one_ip, ip_items)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ip_items = [item <span class="keyword">for</span> item <span class="keyword">in</span> ip_items <span class="keyword">if</span> item.speed &gt;=<span class="number">0</span> <span class="keyword">and</span> item.speed &lt; <span class="number">1500.0</span>]    <span class="comment"># 超时1.5s以内</span></span><br></pre></td></tr></table></figure>
<p>其中，ping_one_ip()函数在上一篇文章<a href="http://kekefund.com/2015/11/17/pytho-ip-proxy/" target="_blank" rel="external">IP代理池的实现</a>中有介绍。</p>
<h1 id="3，定时更新">3，定时更新</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_useful_in_db</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新数据库中的IP Speed</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_ip_speed_to_db</span><span class="params">(ip_item)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> ip_item.get_info()</span><br><span class="line">        self.ping_one_ip(ip_item)</span><br><span class="line">        <span class="keyword">print</span> ip_item.get_info()</span><br><span class="line">        sql = <span class="string">"update &#123;table&#125; set Speed=&#123;speed&#125;, UpdateTime='&#123;update_time&#125;' "</span> \</span><br><span class="line">                <span class="string">"where IP='&#123;ip&#125;' and Port='&#123;port&#125;'"</span>.format(</span><br><span class="line">                    table=mysql_table_ip,</span><br><span class="line">                    speed=ip_item.speed,</span><br><span class="line">                    update_time=GetNowTime(),</span><br><span class="line">                    ip=ip_item.ip,</span><br><span class="line">                    port=ip_item.port)</span><br><span class="line">        <span class="keyword">print</span> engine.execute(sql)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ip_items = []</span><br><span class="line"></span><br><span class="line">    df = pd.read_sql_table(mysql_table_ip, engine)</span><br><span class="line">    <span class="keyword">for</span> ix, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">        <span class="keyword">print</span> type(ix), type(row)</span><br><span class="line">        <span class="keyword">print</span> ix, row</span><br><span class="line">        ip_item = IPItem()</span><br><span class="line">        ip_item.init_from_series(row)</span><br><span class="line">        ip_items.append(ip_item)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#多线程</span></span><br><span class="line">    pool = ThreadPool(processes=<span class="number">10</span>)</span><br><span class="line">    pool.map(update_ip_speed_to_db, ip_items)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'update speed success!'</span></span><br></pre></td></tr></table></figure>
<h1 id="4，定时新增">4，定时新增</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_add</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    ip_items = self.parse() <span class="comment"># 获取ip代理网站数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'test speed begin...'</span></span><br><span class="line">    test_ip_speed(ip_items)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'test speed end'</span></span><br><span class="line"></span><br><span class="line">    save_data(ip_items)</span><br></pre></td></tr></table></figure>
<h1 id="5，获取IP代理库的接口(对外)">5，获取IP代理库的接口(对外)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取IP代理地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ip_proxy</span><span class="params">(count=<span class="number">100</span>, result_in_DataFrame = False)</span>:</span></span><br><span class="line">    sql = <span class="string">'select IP, Port, Type from &#123;0&#125; where Speed &gt; 0 order by Speed limit &#123;1&#125;'</span>.format(mysql_table_ip, count)</span><br><span class="line">    df = pd.read_sql_query(sql, engine)</span><br><span class="line">    <span class="keyword">if</span> result_in_DataFrame:</span><br><span class="line">        <span class="keyword">return</span> df</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> df[[<span class="string">'IP'</span>, <span class="string">'Port'</span>, <span class="string">'Type'</span>]].get_values()</span><br></pre></td></tr></table></figure>
<p>下载：<a href="http://7xo67b.com1.z0.glb.clouddn.com/IpProxy-1.0.tar.gz" target="_blank" rel="external">安装包</a></p>
<h2 id="使用方法：">使用方法：</h2><h3 id="1，安装">1，安装</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ tar -zxvf IpProxy-<span class="number">1.0</span><span class="class">.tar</span><span class="class">.gz</span></span><br><span class="line"></span><br><span class="line">$ cd IpProxy-<span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">$ sudo python setup<span class="class">.py</span> install</span><br></pre></td></tr></table></figure>
<h3 id="2，使用">2，使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="keyword">from</span> ip_proxy <span class="keyword">import</span> get_ip_proxy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: get_ip_proxy(count=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">array([[<span class="string">u'123.56.177.156'</span>, <span class="string">u'8080'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'101.200.202.168'</span>, <span class="string">u'80'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'101.200.202.168'</span>, <span class="string">u'80'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'101.201.221.168'</span>, <span class="string">u'20151'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'101.201.221.168'</span>, <span class="string">u'20151'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'101.201.221.168'</span>, <span class="string">u'20151'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'114.112.103.21'</span>, <span class="string">u'3128'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'101.200.234.114'</span>, <span class="string">u'8080'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'114.112.103.21'</span>, <span class="string">u'3128'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'114.112.103.21'</span>, <span class="string">u'3128'</span>, <span class="string">u'http'</span>]], dtype=object)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n [<span class="number">8</span>]: get_ip_proxy(count=<span class="number">10</span>, result_in_DataFrame=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">                IP   Port  Type</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>   <span class="number">123.56</span><span class="number">.177</span><span class="number">.156</span>   <span class="number">8080</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>  <span class="number">101.200</span><span class="number">.202</span><span class="number">.168</span>     <span class="number">80</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>  <span class="number">101.200</span><span class="number">.202</span><span class="number">.168</span>     <span class="number">80</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>  <span class="number">101.201</span><span class="number">.221</span><span class="number">.168</span>  <span class="number">20151</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>  <span class="number">101.201</span><span class="number">.221</span><span class="number">.168</span>  <span class="number">20151</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>  <span class="number">101.201</span><span class="number">.221</span><span class="number">.168</span>  <span class="number">20151</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>   <span class="number">114.112</span><span class="number">.103</span><span class="number">.21</span>   <span class="number">3128</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>  <span class="number">101.200</span><span class="number">.234</span><span class="number">.114</span>   <span class="number">8080</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>   <span class="number">114.112</span><span class="number">.103</span><span class="number">.21</span>   <span class="number">3128</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>   <span class="number">114.112</span><span class="number">.103</span><span class="number">.21</span>   <span class="number">3128</span>  http</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇 <a href="http://kekefund.com/2015/11/17/pytho-ip-proxy/">IP代理池的实现</a> 讲解了IP代理池的实现细节。</p>
<p>由于爬虫多个项目都需要用到IP代理，打造一个公用的IP代理库就很有必要。本文主要讲解公用的IP代理库的实现框架。</p>
<blockquote>
<p>实现思路如下：</p>
<p>1，数据抓取：从各个IP代理网站抓取大量IP数据；</p>
<p>2，数据筛选：Ping每个IP，连接速度&lt;1.5s的IP地址入库；</p>
<p>3，定时更新：设置定时任务，每日重新Ping数据库内的IP，更新连接速度；</p>
<p>4，定时新增：设置定时任务，每日定时从IP代理网站取新数据</p>
<p>5，提供获取接口</p>
</blockquote>]]>
    
    </summary>
    
      <category term="IP代理" scheme="http://www.kekefund.com/tags/IP%E4%BB%A3%E7%90%86/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://www.kekefund.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[日本蜡烛线理论]]></title>
    <link href="http://www.kekefund.com/2015/12/17/japan-candle-diagram-theory/"/>
    <id>http://www.kekefund.com/2015/12/17/japan-candle-diagram-theory/</id>
    <published>2015-12-17T08:11:06.000Z</published>
    <updated>2015-12-17T08:23:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、基本理论及原则">一、基本理论及原则</h2><ul>
<li>信息量</li>
</ul>
<p>“信息量”的概念对应着包含在价格数据中的“含金量”：</p>
<blockquote>
<ol>
<li><p>任何市场资料所信息量均有限</p>
</li>
<li><p>任何技术分析手段所提取的信息量只可能少于信息量的极限，绝不可能多于信息量的极限；</p>
</li>
<li><p>对于相同的市场资料，虽然可能采取不同的技术分析手段，但是所得信息量均限于上述极限之内，因此它们的结果有可能是相互重叠的。</p>
</li>
</ol>
</blockquote>
<hr>
<ul>
<li>杰西·利弗莫尔：只有离开研究对象一定的距离，才能更好地观察它的全貌。技术分析就是让我们退后一步来观察市场，如此才使我们对市场获得了一份不同寻常的，或许也更加贴切的观感。<a id="more"></a>
</li>
</ul>
<hr>
<ul>
<li>如果我们要观察总体的供给–需求关系，那么，观察价格变化显然是最直观、最容易进行的一种方法，有些基本面的消息，普通的投资大众可能根本无缘得知，但是您可以正确地预期，它们一定已经包含在价格信息之内了。如果有人先于大家掌握了某种推动市场变化的情报，那么，他极可能抢先在市场上买进或者卖出，直到价格变化抵消了他的情报才会罢手。如此一来，在有些情况下，这类消息可能早在当初事件的时候就被市场消化吸收掉了。一言以蔽之，当前的市场价格应当充分反应了当前发送的一切市场信息，不论这些信息是普通大众已经知晓的，还是仅仅掌握在极少数人手重的。</li>
</ul>
<hr>
<ul>
<li>“市场永远不会错”，绝不可带着“市场错了”的成见进行交易。</li>
</ul>
<p>千万不要将自己的主观臆断强加于市场。举例来说，即使您坚定地判断原油市场即将上涨也必须等到市场趋势果真向上出头的时候才能买进。</p>
<p>绝不可将自己的意愿强加于市场，一定要做一个追随趋势者，不要做一个预测趋势者。如果您怀着看涨的预期，那么就在上升趋势中入市；如果您持有看跌的预期，那么就在下降趋势中入市。</p>
<hr>
<ul>
<li>采取保护性止损措施的重要性</li>
</ul>
<p>我们应当在最初建立交易头寸的时候，就设置好止损水平，只有在这个时候，我们才是最冷静、客观的。只有在市场的演变符合我们本来的预期的条件下才能继续持有当初的交易头寸。如果后来的价格变化与我们的预期相反，或者哪怕只是未能证实我们的预期，届时应当当机立断，平仓出市。</p>
<pre><code><span class="bullet">- </span>请不要忘记下列两项事实：

<span class="blockquote">&gt; 1. 所有的长期趋势都是由短期趋势开头的</span>

<span class="blockquote">&gt; 2. 市场上绝无一厢情愿的余地，市场自行其是，既不在意您的想法，也不关心您的头寸。</span>
</code></pre><hr>
<ul>
<li><p>市场并不在乎您是不是顺从了它的趋势。有一件事比犯错误还要命，那便是坚持错误。宁可放弃您的高见，不要丧失您的金钱。有能力及早纠正自己的错误，其实是一件值得自豪的事。被市场落实了止损指令，就意味着认错服输。人们对承认错误深恶痛绝，因为这里面往往牵扯上了个人的自尊心和名声等。优秀的交易商从不过于固执己见。据说，沃伦巴菲特信奉两项原则：</p>
<blockquote>
<ol>
<li><p>保全资本金。</p>
</li>
<li><p>绝不可忘记原则1.</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<p>拿日本人的话来说，“只要钓得上蛙鱼，丢个把鱼钩是值得的。”如果您被止损出市，那就当失去一把鱼钩，没准，下一钩就能钓上一条大家伙。</p>
<hr>
<ul>
<li>下面这句话常常挂在房地产经纪人的嘴边：“对房地产最有影响力的三项因素是：地点，地点，地点。”。如果我们把这句话借用到我们这个行业来，那就是，市场最重要的三个方面是：趋势、趋势、趋势。</li>
</ul>
<hr>
<h2 id="二、技术指标">二、技术指标</h2><h3 id="1，极限转换原则">1，极限转换原则</h3><p>日本人有句谚语：“大红的真漆盘子无需另加装饰”。这种“简单的就是美好的”的概念，道破了市场技术分析理论的真谛。</p>
<p>这一原则既简单明白，又犀利、得力——过去的支撑水平演化为新的阻挡水平；过去的阻挡水平演化为新的支撑水平。这就是所说的“极性转换原则”。</p>
<p>下图左卫支撑水平转化为阻挡水平的情形。下图右室过去的阻挡水平转化为新的支撑水平的情形。</p>
<h4 id="极性转换现象的技术潜力的大小与以下几个方面成正比：">极性转换现象的技术潜力的大小与以下几个方面成正比：</h4><blockquote>
<p>1、市场对过去的支撑/阻挡水平曾进行试探的次数；</p>
<p>2、每次试探时的交易量、持仓量的大小。</p>
</blockquote>
<h3 id="2，百分比回撤水平">2，百分比回撤水平</h3><p>通常，市场既不会直线上升，也不会径直跌落，而是进两步、退一步。在当前趋势继续发展之前，市场通常先要对已经形成的上涨进程或下跌进程作出一定程度的回撤。</p>
<p>在这类回撤水平中，较为常用的是50%回撤水平，以及38%和62%的斐波那契回撤水平。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210huiche.png" alt=""></p>
<h3 id="3，移动平均线">3，移动平均线</h3><p>在比较流行的移动平均线中，对短线的交易商来说，包括4天、9天、18天移动平均线；对操作长期头寸的市场参与者来说，包括13周、26周、40周移动平均线。</p>
<p>在日本，13周和40周移动平均线最为常用。</p>
<ul>
<li>移动平均线的用法</li>
</ul>
<blockquote>
<p>1、通过比较价格与移动平均线的相对位置，构成一个趋势目标。举例来说，如果我们判断市场正处于中期的上升趋势中，那么有一个很好的衡量标准，就看价格是不是居于65天移动平均线的上方。而对于更长期的上升趋势来说，价格必须高于40周移动平均线。</p>
</blockquote>
<p>2、利用移动平均线构成支撑水平或阻挡水平。当收市价向上超越某一条特定的移动平均线时，可能构成看涨的信号。而当收市价向下低于某个移动平均线时，构成看跌的信号。</p>
<p>3、跟踪移动平均线波幅带（也称为包络线）。这些波幅带是将移动平均线向上或向下平移一定的百分比后形成的，它们也起到支撑或阻挡作用。</p>
<p>4、观察移动平均线的斜率。举例来说，如果移动平均线在一段持续稳步的上升之后转向水平发展，乃至开始下降，那么可能构成了一个看跌信号。在移动平均线上作趋势线，是监测其斜率变化的一个简单易行的办法。</p>
<p>5、利用双移动平均线系统来交易。</p>
<h3 id="4，双移动平均线">4，双移动平均线</h3><p>两根移动平均线组合在一起，可构造成一个超买/超卖指标，也就是摆动指数。</p>
<p>把较短期的移动平均线减去较长期的移动平均线，就得到了这个摆动指数的值。该指数既可以是正值，也可以为负值。</p>
<blockquote>
<p>1、如果短期移动平均线相对来说较大幅度地高于（或低于）长期移动平均线，那么我们就认为市场处于超买状态（或超卖状态）。</p>
</blockquote>
<p>2、如果短期移动平均线向上穿越了长期移动平均线，这就是一个看涨信号。在日本，这样的移动平均线交叉信号称为黄金交叉。与上述相反的情形，当短期移动平均线向下穿越长期移动平均线时，构成了一个看跌的死亡交叉信号。</p>
<h3 id="5，相对力度指数">5，相对力度指数</h3><p>在期货交易商中，相对力度指数（RSI）是最流行的技术工具之一。在RSI研究中9天和14天是最常用的两种时间参数。</p>
<ul>
<li>如何计算RSI</li>
</ul>
<p>首先分布累加出一定时间之内上涨的价格幅度之和与下跌的价格幅度之和，然后再求得两者的比值。在计算过程中，一般仅采用收市价作为价格数据。它的计算公式是：</p>
<p>RSI = 100 - 100 /  ( 1 + RS ) </p>
<p>其中，RS = 该时期上涨价格幅度的平均值/该时期内下跌价格幅度的平均值。</p>
<ul>
<li>如何运用RSI</li>
</ul>
<p>RSI的两个主要用途是：构成超买/超卖指标，作为监测相互背离现象的工具。</p>
<p>当RSI向上趋近其取值范围的上边界时（即，当它高于70或80时），表明市场处于超买状态。在这样的情况下，市场也许变得比较脆弱，容易引发向下回落的过程，或者即将转入横向调整阶段；与此相反，当RSI处于其取值范围的下边界时（通常低于30或20），则认为RSI反映了超卖状态。在这样的环境下，市场有可能形成空头买入平仓行情。</p>
<p>利用RSI揭示相互背离现象的具体方法是：当价格向上创出当前趋势的新高时，RSI却没有形成新高，未能与之配合，这就构成了一个负面相互背离信号，可能是一个看跌信号；当价格向下跌出当前趋势的新低时，RSI却没有形成新低，则构成了正面的相互背离现象。 </p>
<h3 id="6，随机指数">6，随机指数</h3><p>随机（摆动）指数，既提供了超买和超卖状态的读数指示，也能够揭示相互背离现象，还提供了一套比较短期趋势与长期趋势的机制。</p>
<p>随机指数把最近的收市价格，同一定时间范围内市场的总的价格范围进行比较。随机指数的数值处在0到100之间。</p>
<p>当随机指数的读数较高时，就意味着当前的收市价在一定时期的整个价格范围中接近上端的水平。</p>
<p>当随机指数的读数较低时，就意味着当前的收市价在一定时期的整个价格范围中接近下端的水平。</p>
<p>随机指数的设计思想是：<strong>当市场向上运动时，收市价格倾向于接近上述价格区间的高点；当市场向下运动时，价格往往集中在上述价格区间的低点附近。</strong></p>
<ul>
<li>如何计算随机指数</li>
</ul>
<p>随机指数的图表由两根曲线组成，它们分别是%K线和%D线。其中，%K线称为原始随机线，或者称为快%K线。这条曲线最为灵敏，%K线值的计算公式是：</p>
<pre><code>%<span class="keyword">K</span> =（收市价 - <span class="keyword">N</span>天内的最低价） / （<span class="keyword">N</span>天内的最高价 - <span class="keyword">N</span>天内的最低价）* <span class="number">100</span>%
</code></pre><p>N值，取9、14、21个时间单位是几个较为常见的时间参数。</p>
<p>以快%K线为基础，每三个数值计算出一个移动平均值，得出一条较为平滑的三时间单位移动平均线。这条%K线的三时间单位移动平均线就称为慢%K线。</p>
<p>以慢%K线再进行一次三时间单位的移动平均，得到了慢%K线的三时间单位移动平均线，称为%D线。</p>
<ul>
<li><p>如何应用随机指数</p>
<ul>
<li><p>当慢%K线向下穿过%D线时，构成卖出信号；</p>
</li>
<li><p>当慢%K线向上穿过%D线时，构成买入信号。</p>
<p>具体来说，为了构成一个买入信号，需要满足以下三个条件：</p>
</li>
</ul>
<ul>
<li><p>首先，市场必须处在超卖状态（随机指数的%D值为25%或更低）；</p>
</li>
<li><p>其次，市场已经发生了正面相互背离现象；</p>
</li>
<li><p>最后，慢%K线向上穿越了%D线。</p>
</li>
</ul>
</li>
</ul>
<h3 id="7，动力指数">7，动力指数</h3><p>又称为价格速度指数。该指数度量的是，当前的收市价与一定天数之前的收市价之差。如果我们研究10日动力指数，那么我们比较的就是今天的收市价与10日之前的收市价。</p>
<p>在上升趋势的发展过程中，上述价格差应当以逐步加快的速度增长。这样的情况显示了该上升趋势具有逐步增长的驱动力。如果价格上涨，而动力指数转为持平，那么说明当前的价格趋势处于减速状态。这可能构成了一个早期的警告信号，说明当前的价格趋势可能会结束。如果动力指数向下越过零线，则形成了一个看跌信号；而当它向上穿越零线时，则是一个看涨信号。</p>
<p>动力指数也是一种现成的超买/超卖指标。举例来说，当动力指数为一个相对较大的正值时，市场可能处在超买状态，容易发生回落行情。<strong>动力指数通常在价格达到顶峰之前预先达到顶点。根据这一特点，当动力指数处于极为超买的读数状况时，可能预示着一个价格高峰的形成。</strong></p>
<p>动力指数的另一种用途是，它能够为市场的超买或超卖状体提供一个具体尺度。</p>
<h3 id="8，交易量">8，交易量</h3><p>交易量的技术意义是，一段行情的交易量越重，则这段行情背后的市场力量越强大。只要交易量保持增长的态势，那么，当前的价格趋势就将持续下去。但是如果在价格趋势发展时，交易量不增反降，那么，判断当前趋势仍将继续发展的理由就不充分了。另外，我们还可以通过交易量来验证市场的顶部或底部过程。当市场向下试探某一支撑水平时，如果交易量较轻，则意味着卖出压力减弱了，因此构成了一个看涨信号。反过来，当市场向上试探先前的高点时，如果交易量较轻，则证明买进力量减弱了，构成了一个看跌信号。</p>
<h3 id="9，权衡交易量（OBV）">9，权衡交易量（OBV）</h3><p>权衡交易量（OBV）是一种交易量的累计净值。从一个基准日开始，当某一天的收市价高于前一天的收市价时，则将该日的交易量数值加到前一天的权衡交易量数值上；如果某一天的收市价低于前一日的收市价，则该日的交易量就从前一天累计的权衡交易量数值中减去。<br>OBV验证趋势。OBV应当朝着当前主要趋势的方向运动。如果价格与OBV双双上涨，则说明由买方引起的交易量正在上升，即便在较高的价位上，也能达成较高的交易量。这可能构成一个看涨信号。</p>
<p>如果情况与上述方向相反，价格与OBV一齐下跌，就反映出在较低的价位上，由卖方引起的交易量也在增长，说明价格下降的过程仍将持续。</p>
<p>在横向交易区间中，也可以应用OBV。如果在价格保持稳定时（最好是在较低的价位上保持稳定），OBV开始升高，这可能揭示了一个筹码搜集的过程。这种局面预示着上涨行情的到来。</p>
<p>如果价格持平运动，而OBV正在下跌，则反映出一个筹码派发的过程。这种局面可能具有看跌的意义，特别是当它发生在高价格水平时。</p>
<h3 id="10，持仓量">10，持仓量</h3><p>持仓量的作用与交易量有些类似，也有助于衡量价格运动背后的市场力度。根据持仓量的增减，我们就可以判断资金是流入某一市场，还是流出某一市场。因此，它就具备了上述用途。持仓量的上升或下降，取决于两方面因素的消长对比：新入市的买入者或卖出者的数额，与新出市的原有交易者的数额。</p>
<p>如果在上升趋势中持仓量是上升的，则一般来说，牛方占据主动，上涨行情仍将持续；如果在下降趋势中持仓量是上升的，则说明熊方占据主动，下跌行情仍将持续。</p>
<p>如果在市场上扬时，持仓量下降，那么这段上涨行情是由于空头买入平仓行为所引起的（以及原来的多头者趁机对冲头寸）。等到原有的这群空头者逃离了该市场，那么上述上涨行情（即空头买进平仓行情）背后的驱动力也随之瓦解，这就意味着当前的市场较为脆弱，容易诱发进一步的疲弱行情。</p>
<p>我们不妨打个比方，假定有一根水管接在自来水干线上。在自来水干线与这条水管之间安装了一个水龙头。上升的持仓量相当于打开了水龙头，从自来水干线向水管里输入自来水，那么，只要水龙头是开着的，就会不断地从水管里面流出水来（这就相当于上升的持仓量将价格进一步推高或推低）。下降的持仓量好像是关上了水龙头，开始，还有水从水管子里面流出来（因为水管于里面还有一些剩水），但是一旦剩水全部滴出来了，就不再有新的来源维持水流了。结果，水流（相当于价格趋势）就会枯竭。</p>
<p>当市场处于新高水平时，如果持仓量恰巧也达到了异乎寻常的高水平，可能预示着市场即将陷入困境，这是因为，上升的持仓量意味着新的空头者和新的多头者正在进入市场。如果市场处于稳步上涨的上升趋势中，那么，这些新的多头者将会随着价格水平的逐步上升，逐步提高卖出止损指令的水平。万一价格突然下滑，将引发执行止损指令的连锁反应，有可能导致价格的狂泻。</p>
<h3 id="11，_期权">11， 期权</h3><p>为了确定一份期货期权合约的理论价格，我们需要五个方面的参数。它们分别是：</p>
<pre><code>-<span class="ruby"> 执行价格
</span>
-<span class="ruby"> 有效期限
</span>
-<span class="ruby"> 基本市场的预测价格
</span>
-<span class="ruby"> 基本市场的波动性
</span>
-<span class="ruby"> 短期利率的水平</span>
</code></pre><p>在这些自变量中，有三项是已知的（有效期限、执行价格、短期利率）。</p>
<p>在决定期权价格的所有因素中，绝不可以低估波动性的重要性。事实上，在某些情况下，波动性的变化对期权价格的影响，甚至超过了相应的期货合约的价格变化所带来的影响。</p>
<p>所谓波动性，指的是人们预期今后一年之内对应基本市场的价格变化范围（波动性水平式按年计算的）。</p>
<p>在期权交易中，必须对未来的市场波动性作出预测。预测市场波动性的一种方法是，由市场价格提供这样的预测值。事实上，这就是所谓蕴含波动性的来历。蕴含波动性，就是市场对期权有效期内相应的基本期货合约的波动性的估计，是蕴含在当前期权价格之中的波动性水平。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、基本理论及原则">一、基本理论及原则</h2><ul>
<li>信息量</li>
</ul>
<p>“信息量”的概念对应着包含在价格数据中的“含金量”：</p>
<blockquote>
<ol>
<li><p>任何市场资料所信息量均有限</p>
</li>
<li><p>任何技术分析手段所提取的信息量只可能少于信息量的极限，绝不可能多于信息量的极限；</p>
</li>
<li><p>对于相同的市场资料，虽然可能采取不同的技术分析手段，但是所得信息量均限于上述极限之内，因此它们的结果有可能是相互重叠的。</p>
</li>
</ol>
</blockquote>
<hr>
<ul>
<li>杰西·利弗莫尔：只有离开研究对象一定的距离，才能更好地观察它的全貌。技术分析就是让我们退后一步来观察市场，如此才使我们对市场获得了一份不同寻常的，或许也更加贴切的观感。]]>
    
    </summary>
    
      <category term="K线" scheme="http://www.kekefund.com/tags/K%E7%BA%BF/"/>
    
      <category term="期货" scheme="http://www.kekefund.com/tags/%E6%9C%9F%E8%B4%A7/"/>
    
      <category term="股票" scheme="http://www.kekefund.com/tags/%E8%82%A1%E7%A5%A8/"/>
    
      <category term="蜡烛图" scheme="http://www.kekefund.com/tags/%E8%9C%A1%E7%83%9B%E5%9B%BE/"/>
    
      <category term="Stock" scheme="http://www.kekefund.com/categories/Stock/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[日本蜡烛线形态]]></title>
    <link href="http://www.kekefund.com/2015/12/10/japan-candle-diagram-technique/"/>
    <id>http://www.kekefund.com/2015/12/10/japan-candle-diagram-technique/</id>
    <published>2015-12-10T03:09:01.000Z</published>
    <updated>2015-12-17T08:10:33.000Z</updated>
    <content type="html"><![CDATA[<p>日本蜡烛线形态</p>
<h3 id="1，纺锤线">1，纺锤线</h3><p>实体较短，说明熊方与牛方正处于胶着状态，一时难分高下。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210fangchuixian2.jpg" alt=""></p>
<h3 id="2，锤子线与上吊线">2，锤子线与上吊线</h3><p>下图中的蜡烛图线具有明显的特点：它们的下影线较长，而实体较小并且在其全天价格区间里，实体处在接近顶端的位置上。</p>
<p><strong>锤子线</strong>：出现在下降趋势中时，成为锤子线，意思是说“市场正用锤子穷砸底部”。在日语中，这类蜡烛线原来的名称是“深水竿”，大体的意思是“试一下水的深浅”。 </p>
<p><strong>上吊线</strong>：出现在上冲行情之后，就表明之前的市场运动也许结束，称为上吊线。这类蜡烛线看上去像吊在绞刑架上双腿晃荡的一个死人。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210cuizhixian.png" alt=""></p>
<blockquote>
<p>注：锤子线或上吊线的实体颜色不重要，可以是白色或黑色。<br><a id="more"></a></p>
</blockquote>
<h4 id="锤子线和上吊线的识别标准">锤子线和上吊线的识别标准</h4><blockquote>
<p>1、实体处于整个价格区间的上端。而实体本身的颜色是无所谓的。</p>
<p>2、下影线的长度至少达到实体高度的2倍。</p>
<p>3、在这类蜡烛线中，应当没有上影线，即使有上影线，其长度也是极短的。</p>
<p>4、锤子线之前，必定先有一段下降趋势（哪怕是较小规模的下降趋势），这样锤子线才能逆转这个趋势。</p>
<p>5、上吊线必须出现在一段上升趋势之后。</p>
<p>6、在上吊线出现后，还需要其它看跌信号的验证。这一原则的重要性，在下图中也得到了体现。在上吊线的看跌验证信号中，有一种情况是，次日的开市价低于上吊线的实体，这是为上吊线求得证实的第一个方法。</p>
</blockquote>
<p><em>上吊线的实体与上吊线次日的开市价之间向下的缺口越大，那么上吊线就越有可能构成市场的顶部。在上吊线之后，如果市场形成了一条黑色的实体，并且它的收市价低于上吊线的收市价，那么，这也可以看作上吊线成立的一种佐证。</em></p>
<blockquote>
<p>PS：上吊线的下影线长度并不是非得达到实体高度的2倍不可，才足以构成反转信号。一般来说，在这类形态中，下影线越长，形态就越完美。</p>
</blockquote>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210shangdiaoxian.png" alt=""></p>
<h3 id="3，吞没形态">3，吞没形态</h3><ul>
<li>看涨吞没形态</li>
</ul>
<p>下图左中，市场本来处于下降趋势之中，但是后来出现了一根坚挺的白色实体，这个白色实体将它前面的那根黑色实体“抱进怀里了”，或者说把它吞没了。这种情形说明市场上买进的压力已经压倒了卖出压力。</p>
<ul>
<li>看跌吞没形态</li>
</ul>
<p>下图右中，市场原本正向着更高的价位趋升，但是当前一个白色实体被后一个黑色实体吞没后，就构成了顶部反转信号。这种情形说明，熊方已经从牛方手中夺走了统治权。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210tunmo.png" alt=""></p>
<h4 id="吞没形态的判别标准:"><strong>吞没形态的判别标准:</strong></h4><blockquote>
<ol>
<li><p>在吞没形态之前，市场必须处在清晰可辨的上升趋势或下降趋势中，哪怕这个趋势只是短期的。</p>
</li>
<li><p>吞没形态必须由2条蜡烛线组成。其中第二根蜡烛线的实体必须覆盖第一根蜡烛线的实体（但是不一定需要吞没前者的上下影线）。</p>
</li>
<li><p>吞没形态的第二个实体必须与第一个实体的颜色相反。这一条标准有例外的情况，条件是，第一条蜡烛线的实体必须非常小，小得几乎构成了一根十字线（或者它就是一根十字线）。如此一来，如果在长期的下降趋势之后，一个小小的白色实体为一个巨大的白色实体所吞没，那么也可能构成了底部反转形态。反之，在上升趋势中，如果一个小小的黑色实体为一个巨大的黑色实体所吞没，那么也可能构成顶部反转形态。</p>
</li>
</ol>
</blockquote>
<h4 id="如果吞没形态具有下面的特征，那么它们构成重要反转信号的可能性将大大地增强:"><strong>如果吞没形态具有下面的特征，那么它们构成重要反转信号的可能性将大大地增强: </strong></h4><blockquote>
<ol>
<li><p>在吞没形态中，第一天的实体非常小，而第二天的实体非常大。这种情况可能说明原有趋势的驱动力正在消退，而新趋势的潜在力量正在壮大。</p>
</li>
<li><p>吞没形态出现在超长期的或非常急剧的市场运动之后。如果存在超长期的上升趋势，则增加了以下这种可能性，潜在的买家已经入市买进，持有多头。在这种情况下，市场可能缺少足够的新的多头头寸的供应，无力继续推动市场上升。如果存在非常急剧的市场运动，则市场可能已经朝一个方向走得太远，容易遭受获利平仓头寸的打击。</p>
</li>
<li><p>在吞没形态中，第二个实体伴有超额的交易量这种情形可能属于胀爆现象。</p>
</li>
<li><p>在吞没形态中，第二天的实体向前吞没的实体不止一个。</p>
</li>
</ol>
</blockquote>
<h3 id="4，乌云盖顶形态（乌云线形态）">4，乌云盖顶形态（乌云线形态）</h3><p>这种形态是由两根蜡烛线组成的，属于顶部反转形态。它们一般出现在上升趋势之后，在有些情况下也可能出现在水平调整区间的顶部。在这一形态中，第一天是一根坚挺的白色实体；第二天的开市价超过了第一天的最高价（这就是超过了第一天的上影线的顶端），但是，市场却收市在接近当日的最低价的水平，并且收市价明显地向下扎入到第一天白色实体的内部。</p>
<p>有些日本技术分析师要求，第二天黑色实体的收市价必须向下穿过前一天白色实体的50%。如果黑色实体的收市价没有向下穿过白色蜡烛线的中点，那么，我们最好等一等，看看是否还有进一步的看跌验证信号。</p>
<h4 id="如果乌云盖顶形态具有这样的特征，则有助于增强其技术分量："><strong>如果乌云盖顶形态具有这样的特征，则有助于增强其技术分量：</strong></h4><blockquote>
<p>1、在乌云盖顶形态中，黑色实体的收市价向下穿入前一个白色实体的程度越深则该形态构成市场顶部的机会越大。如果黑色实体覆盖了前一天的整个白色实体，那就是看跌吞没形态。</p>
<p>2、乌云盖顶形态发生在一个超长期的上升趋势中，它的第一天是一根坚挺的白色实体，其开市价就是最低价（就是说，是秃脚的），而且其收市价就是最高价（就是说，是秃头的）；它的第二天是一根长长的黑色实体，其开市价位于最高价，而但收市价位于最低价（这是一个秃头秃脚黑色蜡烛线）。</p>
<p>3、在乌云盖顶形态中，如果第二个实体（即黑色的实体）的开市价高于某个重要的阻挡水平，但是市场未能成功地坚守住，那么可能证明牛方已经无力控制市场了。</p>
<p>4、如果在第二天开市的时候，市场的交易量非常大，那么这里就可能发生胀爆现象。具体说来，当日开市价创出了新高。而且开市时的成交量极重，可能意味着很多新买家终于下决心入市，踏上了牛市的“船”。随后，市场却发生了抛售行情。对期货交易商来说，极高的持仓量也是一种警告信号。</p>
</blockquote>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210wuyun.png" alt=""></p>
<h3 id="5，刺透形态（斩回线形态）">5，刺透形态（斩回线形态）</h3><p>刺透形态是乌云盖顶形态的反面形态，是底部反转信号。</p>
<p>斩回线形态出现在下跌的市场上，也是由两根蜡烛线组成的。其中第一根蜡烛线具有黑色实体，而第二根蜡烛线则具有长长的白色实体。在白色蜡烛线这一天，市场的开市价曾急剧地下跌至前一个黑色蜡烛线的最低价之下，但是不久市场又将价格推升回来，形成了一根相对较长的白色实体，并且其收市价已经向上超越了前一天的黑色实体的中点。</p>
<p>在斩回线形态中，白色蜡烛线的实体必须向上推进到黑色蜡烛线实体的中点之上。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210citou.png" alt=""></p>
<h3 id="6，星线">6，星线</h3><p>星线的实体较小，并且在它的实体与它前面的较大的蜡烛线的实体之间形成了价格跳空。只要星线的实体与前一个实体没有任何重叠，那么这个星线就是成立的。</p>
<p>星线本身的颜色并不重要。星线既可能出现在市场的顶部，也可能出现在市场的底部。如果星线的实体已经缩小为十字线，称为十字星线。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210xingxian.png" alt=""></p>
<p>当星线，尤其是十字星线出现时，就是一个警告信号，表明当前的趋势获取好景不长了。星线的较小的实体显示，熊方和牛方的较量已经转入僵持状态。</p>
<h4 id="a、启明星形态">a、启明星形态</h4><p>启明星形态属于底部反转形态。它的名称的由来是，这个形态预示着价格的上涨就像启明星（水星）预示着太阳的升起一样。在本形态中，先是一根长长的黑色实体，随后是一根小小的实体，并且在这两个实体之间形成了一个向下跳空（这两条蜡烛线组成了基本的星线形态）。第三天是一根白色实体，它明显地向上推进到了第一天的黑色实体之内。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210qimingxing.png" alt=""></p>
<p>在理想的启明星形态中，中间蜡烛线（即星线）的实体，与它前、后两个实体之间均有价格跳空。后面的那个价格跳空较为少见，不过，即使没有后面这个价格跳空，似乎也不会削减启明星形态的技术效力。</p>
<h4 id="b、黄昏星形态">b、黄昏星形态</h4><p>黄昏星是启明星的顶部对等形态，是看跌的、它的名称的由来也是显而易见的。因为黄昏星（金星）恰好出现在夜幕即将降临之际，既然黄昏星是顶部反转形态，那么，它只有出现在上升趋势之后，才能发挥其技术效力。</p>
<p>黄昏星形态是由三根蜡烛线组成的。在前面两根蜡烛线中，第一根是一根长长的白色实体，后一根是一根星线。星线的出现，是顶部形态的第一个征兆。第三根蜡烛线证实了顶部过程的发生，完成了这个三线形态的黄昏星形态。第三根蜡烛线具有黑色实体，它剧烈地向下扎入第一天的白色实体的内部。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210huanghunxing.png" alt=""></p>
<h5 id="黄昏星形态或启明星形态兼具这样的特征。则有助于增加它们构成反转信号的机会。"><strong>黄昏星形态或启明星形态兼具这样的特征。则有助于增加它们构成反转信号的机会。</strong></h5><blockquote>
<p>1、如果在第一根蜡烛线的实体与星蜡烛线的实体之间存在价格跳空，并且在星线的实体与第三根蜡烛线的实体之间也存在价格跳空。</p>
<p>2、如果第三根蜡烛线的收市价深深地向下扎入第一根蜡烛线的实体之内。</p>
<p>3、如果第一根蜡烛线的交易量较轻，而第三根蜡烛线的交易量较重。这一点表明了原先趋势力量的衰减，以及新趋势力量的增长。</p>
</blockquote>
<h4 id="c、十字线形态">c、十字线形态</h4><p>如果在上升趋势中出现了一根十字线，并且这个十字线与前一个实体之间形成了向上的价格跳空；或者在下降趋势中出现了一根十字线，并且与前一个实体之间形成了向下的价格跳空，那么这根十字线就称为十字星线。</p>
<p>十字星线的出现，构成了潜在的警告信号，表明市场的当前趋势已经易于发生变化了。</p>
<p>在上升趋势中，如果在十字星线后跟随着一根长长的黑色实体，并且它的收市价深深地向下扎入十字星线之前的白色实体的内部，那么，这根黑色实体就构成了市场顶部反转过程的验证信号。这样的形态就称为<strong>十字黄昏星形态</strong>。</p>
<p>在下降趋势中，如果在一根黑色实体之后，跟随着一根十字星线，第三根蜡烛线是一根坚挺的白色蜡烛线，并且它的收市价显著地向上穿入第一根黑色实体之内，那么，该底部反转信号就得到了第三根蜡烛线的验证，这个三蜡烛线形态称为十字启明星形态。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210shizixing.png" alt=""></p>
<p>如果市场上出现了一根向上跳空的十字星线，它的后面再跟着一条向下跳空的黑色蜡烛线，并且在这根黑色蜡烛线的上影线与十字星线的下影线直接也形成了价格跳空，那么，这根十字星线就构成了一个主要顶部反转信号。这种形态称为弃婴顶部形态。非常罕见！</p>
<p>弃婴底部形态与顶部对应。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210qiying.png" alt=""></p>
<h4 id="d、流星形态">d、流星形态</h4><p>流星形态是一种二蜡烛线形态，它发出警告信号，表明市场顶部就再眼前。它的外观如其名称，象一颗流星，本形态的技术意义不如黄昏星形态强，通常不构成主要反转信号。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210liuxing.png" alt=""></p>
<p>在流星形态中，流星线具有较小的实体，而且实体处于其价格区间的下端，同时，流星线的上影线较长。</p>
<p>在理想的流星形态中，流星线的实体与前一根蜡烛线的实体之间存在价格跳空。不过价格跳空并不是非有不可。       </p>
<h4 id="e、倒锤子线">e、倒锤子线</h4><p>在下降趋势后，如果出现了与流星线外观一致的蜡烛线，则可能构成一个看涨信号。这样的蜡烛线称为<strong>倒锤子线</strong>。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210daochuizi.png" alt=""></p>
<p>倒锤子线看上去与流星线颇为相象，它也具有较长的上影线，较小的实体，并且实体居于整个价格范围的下端。但不同的是，流星线是一根顶部反转蜡烛线，而倒锤子线却是一根底部反转蜡烛线。如果倒锤子线出现在下降趋势之后，则构成一个看涨的蜡烛图形态。</p>
<p>在分析倒锤子线时，有一点非常重要：当倒锤子线出现后，必须等待下一个时间单位的看涨信号对它加以验证。</p>
<h5 id="倒锤子线的验证信号可能采取下面的形式：">倒锤子线的验证信号可能采取下面的形式：</h5><blockquote>
<ol>
<li><p>倒锤子线次日的开市价向上跳空，超过了倒锤子线的实体。向上跳空的距离越大，验证信号就越强烈。</p>
</li>
<li><p>倒锤子线次日是一根白色蜡烛线，并且它的价格均处在较高的水平。</p>
</li>
</ol>
</blockquote>
<h3 id="7，孕线形态">7，孕线形态</h3><p>后一根蜡烛线的实体较小，并且被前一根相对较长的实体包容进去。</p>
<p>孕线形态与吞没形态相比，两根蜡烛线的顺序恰好颠倒过来。在吞没形态中，后面是一根长长的实体，它将前一个小实体覆盖进去了。而在孕线形态中，前一个是非常长的实体，它将后一个小实体包容起来。</p>
<p>在吞没形态中，两根蜡烛线的实体的颜色应当互不相同，而在孕线形态中，这一点倒不是一项必要条件。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210yunxian.png" alt=""></p>
<h4 id="十字孕线形态">十字孕线形态</h4><p>指的是在孕线形态中，第二天是一根十字线，而不是一个小实体。因为十字孕线形态包含了一根强有力的十字蜡烛线，所以这类形态被视为主要反转信号。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210shizi.png" alt=""></p>
<p>十字孕线形态所蕴含的技术意义，比普通的孕线形态重要得多。一般的孕线形态并不属于主要反转形态，但是，十字孕线形态恰恰是一种主要反转形态。</p>
<h3 id="8，平头顶部形态和平头底部形态">8，平头顶部形态和平头底部形态</h3><p>平头形态是由具有几乎相同水平的最高点的两根蜡烛线组成，或者是由具有几乎相同的最低点的两根蜡烛线组成的。</p>
<p>图6.13，在上升趋势中，先是一根长长的白色蜡烛线，后是一根十字线。这个二蜡烛线形态既是一个十字孕线形态，又是一个平头形态，因为这两根蜡烛线具有同样的最高点。综合来看，这个形态可能构成了重要的反转信号。</p>
<p>图6.14，在这个平头形态中，先是一根长长的白色蜡烛线，后是一根上吊线。下一天，如果市场开市于上吊线的实体之下，那么，把这个形态判断为一个顶部反转信号，就有了很大的胜算。只要市场的收市价不高于这个平头形态的顶部，那么这种看跌的态度就不可动摇。</p>
<p>图6.15，在这个平头顶部形态中，第二根蜡烛线同时又是一根看跌的流星线，尽管它不是一根真正的流星线，但根据形成这根蜡烛线的价格变化过程，这根线本身是看跌的。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210pingtou.png" alt=""></p>
<h3 id="9，捉腰带线">9，捉腰带线</h3><p>捉腰带线形态是单独一根蜡烛线构成的，既可能具有看涨的意义，也可能具有看跌的意义。</p>
<ul>
<li><p>看涨捉腰带线形态是一根坚挺的白色蜡烛线，其开市价位于当日的最低点（或者，这根蜡烛线只有极短的下影线），然后市场一路上扬。如果市场处于低价区域，出现了一根长长的看涨捉腰带线，则预示着上冲行情的到来。</p>
</li>
<li><p>看跌捉腰带线形态是一根长长的黑色蜡烛线，它的开市价位于当日的最高点（或者这根蜡烛线只有极短的上影线），然后市场一路下跌。在市场处于高价区的条件下，看跌捉腰带形态的出现，构成了顶部反转信号。</p>
</li>
</ul>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210zhuoyao.png" alt=""></p>
<h3 id="10，向上跳空二只乌鸦">10，向上跳空二只乌鸦</h3><p>下图为向上跳空二只乌鸦形态。“向上跳空”指的是图示的小黑色实体与它们之前的实体（即第一个小黑色实体之前的实体，通常是一根长长的白色实体）之间的价格跳空。</p>
<p>在理想的向上跳空二只乌鸦形态中，第二个黑色实体的开市价高于第一个黑色实体的开市价，并且它的收市价低于第一个黑色实体的收市价</p>
<p>这个形态在技术上看跌的理论依据大致如下：市场本来处于上升趋势中，并且这一天的开市价同前一天的收市价相比，是向上跳空的，可是市场不能维持这个新高水平，结果当天反而形成了一根黑色蜡烛线。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210wuya.png" alt=""></p>
<h3 id="11，铺垫形态">11，铺垫形态</h3><p>其外形与向上跳空二只乌鸦形态相似，但不同的是，在上升行情中，这类形态是看涨的。在这个形态中，头三根蜡烛线与向上跳空二只乌鸦形态相似，但此后，又跟了一根黑色蜡烛线。如果接下来的一根蜡烛线是白色的，并向上跳空，向上超过了上述最后一根黑色蜡烛的上影线，或者这根白色蜡烛线的收市价高于最后一根黑色蜡烛的最高价，则形成了买入信号。</p>
<p>在铺垫形态中，可以有2根、3根乃至4根黑色蜡烛线。</p>
<p>相对而言，向上跳空二只乌鸦形态和铺垫形态都很少见。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210pudian.png" alt=""></p>
<blockquote>
<p><strong>建议：当向上跳空二只乌鸦形态出现后，应当在该形态的第二根黑色蜡烛线的最高点上方设置止损保护指令，以防备市场收市于该水平之下。</strong> P166</p>
</blockquote>
<h3 id="12，三只乌鸦">12，三只乌鸦</h3><p>类似于向上跳空两只乌鸦形态，连续出现了三根依次下降的黑色蜡烛线，则构成了所谓的三只乌鸦形态。如果三只乌鸦出现在高价格水平上，或者出现在经历了充分发展的上涨行情中，就预示着价格即将下跌。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210sanzhiwuya.png" alt=""></p>
<h3 id="13，反击线形态（约会线形态）">13，反击线形态（约会线形态）</h3><p>当两根颜色相反的蜡烛线具有相同的收市价时，就形成了一个反击线形态（也称为约会线形态）。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210fanjixian.png" alt=""></p>
<p>刺透形态与本图所示的看涨反击线形态一样，也是由两根蜡烛线组成的。它们之间主要的区别是，看涨反击线通常并不把收市价向上推进到前一天的白色实体的内部，而是仅仅回升到前一天的收市价的位置。而在透刺形态，第二根蜡烛线深深地向上穿入了前一个黑色实体之内。因此，透刺形态与看涨反击线形态相比较，透刺形态是一种更为重要的底部反转信号。</p>
<p>在看跌反击线形态中，第二天的开市价高于前一天的最高点，这一点与乌云盖顶形态是一致的。但是，与乌云盖顶形态不同的是，这一天的收市价并没有向下穿入前一天的白色蜡烛线之内。由此看来，乌云盖顶形态所发出的顶部反转信号，比看跌反击线形态更强。</p>
<p>在反击线形态中，一项重要的考虑因素是，第二天的开市价是否强劲地上升到较高的水平（在看跌反击线形态中），或者是否剧烈地下降到较低的水平（在看涨反击线形态中）。其核心思想是，在该形态第二天开市时，市场本来已经顺着既有趋势向前迈了一大步，但是后来，却发生了意想不到的变故！到当日收市时，市场竟然完全返回到了前一天收市价的水平！</p>
<h3 id="14，塔形顶部形态">14，塔形顶部形态</h3><ul>
<li><p><strong>塔形顶部形态</strong>属于顶部反转形态。市场本来处在上升趋势中，在某个时刻，出现了一根坚挺的白色蜡烛线（或者出现了一系列高高的白色蜡烛线）。后来，市场先是放缓了上涨的步调，然后，蜡烛线的高点开始下降。最后，市场上出现了一根或数根长长的黑色蜡烛线，于是，塔形顶部形态就完成了。在本形态中，两侧的长长的蜡烛线形似高塔，因此得名。</p>
</li>
<li><p><strong>塔形底部形态</strong>发生在低价格水平上，市场在形成了一根或数根长长的黑色蜡烛线之后，经历了一阵短暂的平静。然后，出现了一根或数根长长的白色蜡烛线。</p>
</li>
</ul>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210taxing.png" alt=""></p>
<h3 id="15，窗口">15，窗口</h3><p>所谓窗口，是指在前一根蜡烛线的端点与后一根蜡烛线的端点之间存在一个价格缺口。如图左是在上升趋势中形成的一个“打开的”窗口。图右是在下降趋势中的一个窗口。</p>
<p>同时，窗口还将演化为支撑区或阻挡区。因此，在上涨行情中，如果出现了一个窗口，则意味着价格将进一步上升。并且，今后当市场向下回撤时，这个窗口将形成其底部支撑水平。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210chuangkou.png" alt=""></p>
<p>如果连续出现了8个新高而没有发生任何有意义的调整，那么，日本分析师便将这种市场状况描述为“胃口已经填满了八成”。</p>
<p>传统的日本技术分析理论断言：在一个趋势中，如果已经出现了3个向上的或向下的窗口（即所谓三空形态），那么，市场即将形成顶部（如果这三个窗口发生在上升趋势中）或底部（如果这三个窗口发生在下降趋势中）的机会是极大的，特别是在第三个窗口之后，如果出现了某种转折性的蜡烛图形态或蜡烛线（比如说十字线，透刺形态，或者乌云盖顶形态等），那么市场见顶或见底的机会更大了。</p>
<p>日本分析师认为，如果一个窗口（在上升趋势过程中）没有在三天之内被市场关闭，那么市场将上涨。**</p>
<h3 id="16，向上跳空和向下跳空并列阴阳线形态">16，向上跳空和向下跳空并列阴阳线形态</h3><p>是一种持续形态，它的形成过程大体是这样的。市场本处于上升趋势中，这时，出现了一根向上跳空的白色蜡烛线。在这根白色蜡烛线后，紧跟着另一根黑色的蜡烛线。这根黑色蜡烛线的开市价位于前一个白色实体之内，收市价位于前一个白色实体之下，在这样的情况下，这根黑色蜡烛线的收市价，就构成了一个买入点。如果在市场回头填补了这里的跳空（即关闭了该窗口）后，抛售压力依然很明显的话，那么这个向上跳空并列黑白蜡烛线形态的看涨意义就不再成立了。</p>
<p>在向下跳空并列阴阳线形态中，基本概念与上述向上跳空并列阴阳线是相同的，只不过方向相反。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210tiaokong.png" alt=""></p>
<h3 id="17，高价位和低价位跳空突破形态">17，高价位和低价位跳空突破形态</h3><p>在上升趋势中，当市场经历了一两个急剧上涨的交易日后，在正常情况下都需要一个调整消化的过程。有时，这个整理过程是通过一系列小实体来完成的。如果在一根坚挺的蜡烛线之后，出现了一群小实体的蜡烛线则表明市场已经变得犹豫不决了。然而，一旦后来某一天的开市价从这群小实体处向上跳空（也就是说，形成了一个窗口），那么买进的时机就成熟了。</p>
<p>低价位跳空突破形态正是高价位跳空突破形态的反面角色。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210tupo.png" alt=""></p>
<h3 id="18，跳空并列白色蜡烛线形态">18，跳空并列白色蜡烛线形态</h3><p>在上升趋势中，先出现了一根向上跳空的白色蜡烛线，随后又是一根白色蜡烛线，并且后面这根线与前一根大小相当，两者的开市价也差不多处在同样的水平上，这样就形成了一种看涨的持续状态。这种二蜡烛线形态称为向上跳空并列白色蜡烛线形态（或者称为向上跳空并列阳线形态）。如果市场收市在并列白色蜡烛线的最高点之上，则意味着下一波上涨行情即将展开。</p>
<p>在下降趋势中，这类并列的白色蜡烛线也构成了一个持续状态。也就是说，当这类形态出现时，价格将继续走低。为什么这种形态不是看涨的，而是看跌的呢？这是因为在下降的市场中，这两根白色蜡烛线是由空头平仓过程造成的。一旦空头平仓的过程完成了，价格就要进一步下跌。</p>
<p>这两种形态非常少见。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210binglie.png" alt=""></p>
<h3 id="19，上升三法和下降三法形态">19，上升三法和下降三法形态</h3><h4 id="上升三法形态的判别标准，包括以下几个方面：">上升三法形态的判别标准，包括以下几个方面：</h4><blockquote>
<p>1，首先出现的是一根长长的白色蜡烛线</p>
<p>2，在这根白色蜡烛线之后，紧跟着一群依次下降的小实体蜡烛线。这群小实体蜡烛线的理想数目是3根。而且这群小实体蜡烛线基本上都局限在前面那根长长的白色蜡烛线的价格范围之内。小蜡烛线既可以是白色的，也可以是黑色的，不过，黑色蜡烛线最常见。</p>
<p>3，最后一天应当是一根具有坚挺的白色实体的蜡烛线，并且它的收市价高于第一天的收市价。同时，最后这根蜡烛线的开市价也应当高于前一天的收市价。</p>
</blockquote>
<p>下降三法形态与上升三法形态在图形上完全是对等的，只不过方向相反而已。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210sanfa.png" alt=""></p>
<h3 id="20，前进白色三兵形态">20，前进白色三兵形态</h3><ul>
<li>前进白色三兵形态</li>
</ul>
<p>本形态由接连出现的三根白色蜡烛线组成，它们的收市价依次上升。当市场在某个低价位稳定了一段时间后，如果出现了这样的形态，就标志着市场即将转强。</p>
<ul>
<li>前方受阻形态</li>
</ul>
<p>如果其中第二根和第三根蜡烛线，或者仅仅是第三根蜡烛线，表现出上涨势头减弱的迹象，就构成了一个前方受阻（白色三兵）形态。这就意味着这轮上涨行情碰到了麻烦，持有多头头寸者应当采取一些保护性措施。在前方受阻形态中，作为上涨势头减弱的具体表现，既可能是其中的白色实体一个比一个小，也可能是后两根蜡烛线具有相对较长的上影线。</p>
<ul>
<li>停顿状态</li>
</ul>
<p>如果在后两根蜡烛线中，前一根为长长的白色实体，并且向上刨出了新高，后一根只是一个小的白色蜡烛线，那么就构成了一个（白色三兵）停顿形态。当这一形态出现时，说明牛方的力量至少暂时已经消耗尽了。当停顿形态发生时，便构成了多头头寸平仓获利的紧要时机。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210sanbing.png" alt=""></p>
<p>虽然前方受阻形态与停顿形态在一般情况下都不属于顶部反转形态，但是有时候，它们也能引起不容忽视的下跌行情。我们应当利用前方受阻形态和停顿形态来平仓了结已有的多头头寸，或者为多头头寸采取保护措施，但是不可据之开立空头头寸。一般来说，如果这两类形态出现在较高的价格水平上，则更有预测意义。</p>
<h3 id="21，分手蜡烛线形态">21，分手蜡烛线形态</h3><p>反击线形态是一种二蜡烛线形态，前后两根蜡烛线颜色相反，并且后一根蜡烛线的收市价与前一根的收市价处于同一水平。这一形态属于反转信号。如下图的分手线形态也是由两根颜色相反的蜡烛线组成的，但是同反击线形态不同的是，分手线形态的两根蜡烛线具有相同的开市价。分手蜡烛线形态属于持续信号。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210fenshou.png" alt=""></p>
<h3 id="22，十字线">22，十字线</h3><p>十字线是一种不同凡响的趋势反转信号。如果十字线之后的蜡烛线发出了验证信号，证实了它的反转信号的话，就进一步加大了趋势反转的可能性。</p>
<p>需要指出的是，<strong>只有在一个市场不经常出现十字线的条件下，十字线才具有重要意义。如果在某张蜡烛图上有许多十字线，那么当这个市场形成了一根新的十字线的时候，我们就不应当将它视为一条有意义的技术线索。</strong></p>
<p>十字线之所以极具价值，是因为它在揭示市场顶部方面有过人之长。在上升趋势中，如果前面出现一根长长的白色蜡烛线，后面跟着一根十字线，这种情况尤其值得注意。为什么十字线出现在上升趋势中具有负面意义呢?这是因为十字线代表着市场处于犹豫不决心理状态。</p>
<p>但是根据我们的经验来看，在下降趋势中，十字线往往丧失了发挥反转作用的潜力。其中的原因可能是这样的：十字线反映了买方与卖方在力量对比上处于相对平衡状态。由于市场参与者抱着骑墙的态度，市场往往因为自身的重力而下坠。因此，当十字线出现时，在上升趋势中，市场可能向下反转，而在下降趋势中，市场则可能继续下跌。</p>
<ul>
<li>长腿十字线</li>
</ul>
<p>位于市场顶部的长腿十字线是一种特别重要的十字线。这类十字线具有长长的上影线和下影线，鲜明地表露出市场举棋不定的心理状态。</p>
<p>如果当日的开市价和收市价正好处在全日价格范围的中点，那么这种蜡烛线就称为<strong>黄包车夫（线）</strong>。</p>
<p>如果某根非十字线的蜡烛线具有很长的上影线，或者具有很长的下影线，并且其实体较小，这种蜡烛线就称为<strong>风高浪大线</strong>。如果出现了一群风高浪大线，也构成了一种反转形态。对日本分析师来说，非常长的上影线或非常长的下影线的形成——借用他们的话来描述——就表示市场“失去了方向感”。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210changtuishizi.png" alt=""></p>
<ul>
<li>墓碑十字线</li>
</ul>
<p>当开市价和收市价位于当日的最低点时，就形成了一根墓碑十字线。</p>
<p>这类形态最突出的长处在于昭示市场顶部。在上涨行情中，该形态的上影线越长，所处的价格水平愈高，那么，这根墓碑十字线的技术意义就愈疲弱。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210mubeishizi.png" alt=""></p>
<p>墓碑十字线与流星形态颇为相像。发生在市场顶部的墓碑十字线，实际上是流星形态的一种特殊情况。流星蜡烛线具有较小的实体，而墓碑十字线——作为一根十字线，甚至没有实体。墓碑十字线比流星形态更为疲软。</p>
<ul>
<li>三星形态</li>
</ul>
<p>三星形态非常罕见，但是是一种意义极其重大的反转形态。三星形态是由三根十字线组成的，中间的十字线是一根十字星蜡烛线。理想的三星形态如下图：</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210sanxing.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>日本蜡烛线形态</p>
<h3 id="1，纺锤线">1，纺锤线</h3><p>实体较短，说明熊方与牛方正处于胶着状态，一时难分高下。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210fangchuixian2.jpg" alt=""></p>
<h3 id="2，锤子线与上吊线">2，锤子线与上吊线</h3><p>下图中的蜡烛图线具有明显的特点：它们的下影线较长，而实体较小并且在其全天价格区间里，实体处在接近顶端的位置上。</p>
<p><strong>锤子线</strong>：出现在下降趋势中时，成为锤子线，意思是说“市场正用锤子穷砸底部”。在日语中，这类蜡烛线原来的名称是“深水竿”，大体的意思是“试一下水的深浅”。 </p>
<p><strong>上吊线</strong>：出现在上冲行情之后，就表明之前的市场运动也许结束，称为上吊线。这类蜡烛线看上去像吊在绞刑架上双腿晃荡的一个死人。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210cuizhixian.png" alt=""></p>
<blockquote>
<p>注：锤子线或上吊线的实体颜色不重要，可以是白色或黑色。<br>]]>
    
    </summary>
    
      <category term="K线" scheme="http://www.kekefund.com/tags/K%E7%BA%BF/"/>
    
      <category term="期货" scheme="http://www.kekefund.com/tags/%E6%9C%9F%E8%B4%A7/"/>
    
      <category term="股票" scheme="http://www.kekefund.com/tags/%E8%82%A1%E7%A5%A8/"/>
    
      <category term="蜡烛图" scheme="http://www.kekefund.com/tags/%E8%9C%A1%E7%83%9B%E5%9B%BE/"/>
    
      <category term="Stock" scheme="http://www.kekefund.com/categories/Stock/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PyQt4 生成exe打包文件]]></title>
    <link href="http://www.kekefund.com/2015/11/26/pyqt4-build-exe/"/>
    <id>http://www.kekefund.com/2015/11/26/pyqt4-build-exe/</id>
    <published>2015-11-26T09:00:51.000Z</published>
    <updated>2015-11-27T02:14:21.000Z</updated>
    <content type="html"><![CDATA[<p><strong>PyQt4 生成exe打包文件</strong></p>
<p>pyqt是跨平台的GUI平台，本文的UI设计，代码编写在mac下进行，编译成exe，并打包在win7下做的。<br>python脚本语言，图形化平台不是其擅长的领域，一般都是直接运行脚本，这次因为客户需要一个“成型”的程序去外面给别人展示，故有了此文的背景。<br>QT作为一个跨平台的开发环境，编写出一个窗口程序，然后打包成python文件是比较迅速的。麻烦的是打包成windows的exe文件，试过py2exe,pyinstaller，都不是很好用，py2exe根本出不来图形界面，最后用到cxfreeze这个工具，才得以顺利打包。</p>
<h2 id="前言">前言</h2><p>环境搭建参考：<a href="http://www.cnblogs.com/zouzf/p/4308912.html" target="_blank" rel="external">http://www.cnblogs.com/zouzf/p/4308912.html</a></p>
<h2 id="一、Qt_Designer设计界面">一、Qt Designer设计界面</h2><p><em>安装Qt Designer，我的版本是5.2.1。</em><br>设计出的界面如下，保存为.ui文件。<br><img src="http://7xo67b.com1.z0.glb.clouddn.com/qt_main.png" alt="Qt_UI"></p>
<p>Qt的界面布局和MFC的比较类似，但它多了一层容器的概念。控件都放在容器Layout中，这点又和Android的手机布局比较相近。</p>
<blockquote>
<p><em>UI布局教程参考：<a href="http://www.linuxidc.com/Linux/2012-06/63652.htm" target="_blank" rel="external">PyQt4 精彩实例分析</a></em></p>
</blockquote>
<a id="more"></a>
<h2 id="二、Qt布局文件-ui转换成-py文件">二、Qt布局文件.ui转换成.py文件</h2><p>mac和win系统下先将pyuic4命令加入环境变量。mac中我是直接把/etc/paths拷贝到桌面，添加pyuic4路径后再拷贝覆盖回去。（ps: etc下不能直接修改）<br>在终端中执行：</p>
<pre><code><span class="tag">pyuic4</span> <span class="tag">-x</span> <span class="tag">aaaaaaa</span><span class="class">.ui</span> <span class="tag">-o</span> <span class="tag">bbbbbb</span><span class="class">.py</span>
</code></pre><p>即可将.ui文件转成py文件。</p>
<h2 id="三、添加按钮动作">三、添加按钮动作</h2><p>这里实现了三个功能：上传文件，运行py脚本，打开另一个Qt窗口</p>
<h3 id="1，上传文件">1，上传文件</h3><h4 id="a，post上传">a，post上传</h4><pre><code>dlg = QFileDialog()
<span class="keyword">filename</span> = dlg.getOpenFileName()
from os.path import isfile
<span class="keyword">if</span> isfile(<span class="keyword">filename</span>):
    <span class="keyword">filename</span> = str(<span class="keyword">filename</span>)
    print type(<span class="keyword">filename</span>)
<span class="comment">    #dir_f = os.path.dirname(str(filename))</span>

<span class="comment">    # ------ web post -----</span>
<span class="comment">    # 在 urllib2 上注册 http 流处理句柄</span>
    register_openers()

<span class="comment">    # headers 包含必须的 Content-Type 和 Content-Length</span>
<span class="comment">    # datagen 是一个生成器对象，返回编码过后的参数</span>
    datagen, headers = multipart_encode({<span class="string">"myfile"</span>: <span class="keyword">open</span>(str(<span class="keyword">filename</span>), <span class="string">"rb"</span>)})

<span class="comment">    # 创建请求对象</span>
    request = urllib2.Request(<span class="string">"http://yourwebsite:8080/upload"</span>, datagen, headers)
<span class="comment">    # 实际执行请求并取得返回</span>
    print urllib2.urlopen(request).<span class="keyword">read</span>()
</code></pre><h4 id="b，通过_ftp_上传">b，通过 ftp 上传</h4><pre><code>dlg = QFileDialog()
filename = dlg.getOpenFileName()
<span class="built_in">from</span> os.path import isfile
<span class="keyword">if</span> isfile(filename):
    filename = str(filename)

    <span class="comment"># ------- ftp --------</span>
    <span class="built_in">from</span> ftplib import FTP

    <span class="keyword">ftp</span>=FTP()
    <span class="keyword">ftp</span>.set_debuglevel(<span class="number">2</span>)<span class="comment">#打开调试级别2，显示详细信息;0为关闭调试信息</span>
    <span class="keyword">ftp</span>.connect(<span class="string">'127.0.0.1'</span>,<span class="string">'21'</span>)<span class="comment">#连接</span>
    <span class="keyword">ftp</span>.login(<span class="string">'Administrator'</span>,<span class="string">'password'</span>)<span class="comment">#登录，如果匿名登录则用空串代替即可</span>
    print <span class="keyword">ftp</span>.getwelcome()<span class="comment">#显示ftp服务器欢迎信息</span>
    <span class="comment">#ftp.cwd(dir_f) #选择操作目录</span>
    <span class="comment">#filename='keys.xlsx'</span>
    bufsize = <span class="number">1024</span><span class="comment">#设置缓冲块大小</span>
    file_handler = <span class="built_in">open</span>(filename,<span class="string">'rb'</span>)<span class="comment">#以读模式在本地打开文件</span>
    <span class="keyword">ftp</span>.storbinary(<span class="string">'STOR %s'</span> % os.path.basename(filename),file_handler,bufsize)<span class="comment">#上传文件</span>
    <span class="keyword">ftp</span>.set_debuglevel(<span class="number">0</span>)
    file_handler.<span class="built_in">close</span>()
    <span class="keyword">ftp</span>.quit()
    print <span class="string">"ftp up OK"</span>
</code></pre><h3 id="2，运行py脚本">2，运行py脚本</h3><p>在服务器上用web.py搭建web服务器，通过网页请求运行py文件。</p>
<pre><code><span class="comment">#运行</span>
<span class="function"><span class="keyword">def</span> <span class="title">on_run_clicked</span><span class="params">(self)</span>:</span>
    self.pushButton_run.setText(_translate(<span class="string">"Dialog"</span>, <span class="string">"运行中"</span>, <span class="keyword">None</span>))
    self.pushButton_run.setEnabled(<span class="keyword">False</span>)
    response = urllib2.urlopen(<span class="string">'http://%s:8080/run_video_search'</span> % self.ip, timeout=<span class="number">3</span>)
    <span class="keyword">print</span> response
</code></pre><p>这里采用的是同步的方式请求，服务器端的py脚本没执行完，则程序一直等待。不过设置了超时，过了3s返回超时错误，这种情况适合不需要得到服务器的反馈，只是执行远程py脚本而已。</p>
<h3 id="3，打开另一个Qt窗口">3，打开另一个Qt窗口</h3><p>pyqt 用起来的比较简单，直接run qt对应的py类</p>
<pre><code>#结果
def <span class="function"><span class="title">on_show_result</span><span class="params">(self)</span></span>:

    Dialog = QtGui.<span class="function"><span class="title">QDialog</span><span class="params">()</span></span>
    ui = <span class="function"><span class="title">Ui_Result_Dialog</span><span class="params">()</span></span>
    ui.<span class="function"><span class="title">setupUi</span><span class="params">(Dialog)</span></span>
    Dialog.<span class="function"><span class="title">show</span><span class="params">()</span></span>
    Dialog.<span class="function"><span class="title">exec_</span><span class="params">()</span></span>
</code></pre><p>跳转过来的窗口如下，是一个数据库的查询界面。<br><img src="http://7xo67b.com1.z0.glb.clouddn.com/qt_result.png" alt="result ui">                        </p>
<h2 id="四、打包">四、打包</h2><p>cx_Freeze 支持跨平台，可在windows、linux，mac下使用。下载地址为(<a href="http://sourceforge.net/projects/cx-freeze/files/),,也可以直接通过pip安装" target="_blank" rel="external">http://sourceforge.net/projects/cx-freeze/files/),,也可以直接通过pip安装</a></p>
<pre><code>pip <span class="keyword">install</span> cx_freeze
</code></pre><p>安装成功后，在C:\Python27\Lib\site-packages\cx_Freeze\samples\PyQt4中找到pyqt4的使用例子。<br>查看setup.py</p>
<pre><code><span class="keyword">import</span> sys
<span class="keyword">from</span> cx_Freeze <span class="keyword">import</span> setup, Executable

base = None
<span class="keyword">if</span> sys.platform == <span class="string">'win32'</span>:
    base = <span class="string">'Win32GUI'</span>

<span class="keyword">options</span> = {
    <span class="string">'build_exe'</span>: {
        <span class="string">'includes'</span>: <span class="string">'atexit'</span>
    }
}

executables = [
    Executable(<span class="string">'PyQt4app.py'</span>, base=base)
]

setup(name=<span class="string">'simple_PyQt4'</span>,
      version=<span class="string">'0.1'</span>,
      <span class="keyword">description</span>=<span class="string">'Sample cx_Freeze PyQt4 script'</span>,
      <span class="keyword">options</span>=<span class="keyword">options</span>,
      executables=executables
      )
</code></pre><p>把这个setup.py文件拷贝到你要打包py文件的目录，然后将setup.py中的“PyQt4app.py”改成你要打包的py文件。<br>在cmd命令行，cd到当前目录，运行:</p>
<pre><code>python setup<span class="class">.py</span> build
</code></pre><p>打包exe成功后，在当前目录下会生成build文件夹，在\build\exe.win32-2.7\中找到exe后缀的文件，执行。</p>
<h2 id="五、制作安装包">五、制作安装包</h2><p>采用的是Inno Setup 制作安装包，按照向导来生成.iss脚本，傻瓜化操作。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>PyQt4 生成exe打包文件</strong></p>
<p>pyqt是跨平台的GUI平台，本文的UI设计，代码编写在mac下进行，编译成exe，并打包在win7下做的。<br>python脚本语言，图形化平台不是其擅长的领域，一般都是直接运行脚本，这次因为客户需要一个“成型”的程序去外面给别人展示，故有了此文的背景。<br>QT作为一个跨平台的开发环境，编写出一个窗口程序，然后打包成python文件是比较迅速的。麻烦的是打包成windows的exe文件，试过py2exe,pyinstaller，都不是很好用，py2exe根本出不来图形界面，最后用到cxfreeze这个工具，才得以顺利打包。</p>
<h2 id="前言">前言</h2><p>环境搭建参考：<a href="http://www.cnblogs.com/zouzf/p/4308912.html">http://www.cnblogs.com/zouzf/p/4308912.html</a></p>
<h2 id="一、Qt_Designer设计界面">一、Qt Designer设计界面</h2><p><em>安装Qt Designer，我的版本是5.2.1。</em><br>设计出的界面如下，保存为.ui文件。<br><img src="http://7xo67b.com1.z0.glb.clouddn.com/qt_main.png" alt="Qt_UI"></p>
<p>Qt的界面布局和MFC的比较类似，但它多了一层容器的概念。控件都放在容器Layout中，这点又和Android的手机布局比较相近。</p>
<blockquote>
<p><em>UI布局教程参考：<a href="http://www.linuxidc.com/Linux/2012-06/63652.htm">PyQt4 精彩实例分析</a></em></p>
</blockquote>]]>
    
    </summary>
    
      <category term="PyQt" scheme="http://www.kekefund.com/tags/PyQt/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/tags/Python/"/>
    
      <category term="exe" scheme="http://www.kekefund.com/tags/exe/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IP代理池的Python实现]]></title>
    <link href="http://www.kekefund.com/2015/11/17/pytho-ip-proxy/"/>
    <id>http://www.kekefund.com/2015/11/17/pytho-ip-proxy/</id>
    <published>2015-11-17T09:41:46.000Z</published>
    <updated>2015-11-19T04:53:31.000Z</updated>
    <content type="html"><![CDATA[<p>爬虫采集数据时，如果频繁的访问某个网站，会被封IP，有些是禁止访问3小时，有些是直接拉黑名单。为了避免被禁，一般采取的措施有三种：</p>
<blockquote>
<ol>
<li>放慢抓取的速度，设置一个时间间隔；</li>
<li>模拟浏览器行为，如采用Selenium + PhantomJS；</li>
<li>设置IP代理，定期更换代理IP，让网站不认为来自一个IP。</li>
</ol>
</blockquote>
<p>本文实现其中的第三种方法。<br>国内提供IP代理的网站有很多，我们以其中的一个为例：<a href="http://www.haodailiip.com" target="_blank" rel="external">http://www.haodailiip.com</a><br>分为三步来实现这个IP抓取类：</p>
<blockquote>
<ol>
<li>解析网页中的IP和端口</li>
<li>Ping所有IP地址的连接速度 </li>
<li>按速度从快到慢排序，保存到文件</li>
</ol>
</blockquote>
<a id="more"></a>
<h2 id="一、解析网页中的IP和端口">一、解析网页中的IP和端口</h2><p>抓取网页采用的是<font color="red"> urlib + BeautifulSoup</font>。<br>解析网站：<a href="http://www.haodailiip.com/guonei/page" target="_blank" rel="external">http://www.haodailiip.com/guonei/page</a>，page=1,2…,10</p>
<pre><code>def <span class="function"><span class="title">parse</span><span class="params">(url)</span></span>:
        try:
            page = urllib.<span class="function"><span class="title">urlopen</span><span class="params">(url)</span></span>
            data =  page.<span class="function"><span class="title">read</span><span class="params">()</span></span>
            soup = <span class="function"><span class="title">BeautifulSoup</span><span class="params">(data, <span class="string">"html5lib"</span>)</span></span>
            print soup.<span class="function"><span class="title">get_text</span><span class="params">()</span></span>
            body_data = soup.<span class="function"><span class="title">find</span><span class="params">(<span class="string">'table'</span>, attrs={<span class="string">'class'</span>:<span class="string">'content_table'</span>})</span></span>
            res_list = body_data.<span class="function"><span class="title">find_all</span><span class="params">(<span class="string">'tr'</span>)</span></span>
            <span class="keyword">for</span> res <span class="keyword">in</span> res_list:
                each_data = res.<span class="function"><span class="title">find_all</span><span class="params">(<span class="string">'td'</span>)</span></span>
                <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(each_data)</span></span> &gt; <span class="number">3</span> and not <span class="string">'IP'</span> <span class="keyword">in</span> each_data[<span class="number">0</span>].<span class="function"><span class="title">get_text</span><span class="params">()</span></span> and <span class="string">'.'</span> <span class="keyword">in</span> each_data[<span class="number">0</span>].<span class="function"><span class="title">get_text</span><span class="params">()</span></span>:
                    print each_data[<span class="number">0</span>].<span class="function"><span class="title">get_text</span><span class="params">()</span></span>.<span class="function"><span class="title">strip</span><span class="params">()</span></span>, each_data[<span class="number">1</span>].<span class="function"><span class="title">get_text</span><span class="params">()</span></span>.<span class="function"><span class="title">strip</span><span class="params">()</span></span>
                    item = <span class="function"><span class="title">IPItem</span><span class="params">()</span></span>
                    item<span class="class">.ip</span> = each_data[<span class="number">0</span>].<span class="function"><span class="title">get_text</span><span class="params">()</span></span>.<span class="function"><span class="title">strip</span><span class="params">()</span></span>
                    item<span class="class">.port</span> = each_data[<span class="number">1</span>].<span class="function"><span class="title">get_text</span><span class="params">()</span></span>.<span class="function"><span class="title">strip</span><span class="params">()</span></span>
                    item<span class="class">.addr</span> = each_data[<span class="number">2</span>].<span class="function"><span class="title">get_text</span><span class="params">()</span></span>.<span class="function"><span class="title">strip</span><span class="params">()</span></span>
                    item<span class="class">.tpye</span> = each_data[<span class="number">3</span>].<span class="function"><span class="title">get_text</span><span class="params">()</span></span>.<span class="function"><span class="title">strip</span><span class="params">()</span></span>
                    self<span class="class">.ip_items</span><span class="class">.append</span>(item)
        except Exception,e:
            print e
</code></pre><p>BeautifulSoup默认的解析器是lxml，但对于这个网址，发现网页内容解析的不完整，于是用了解析性最好的 html5lib，速度上会稍慢。<br>关于BeautifulSoup解析器的介绍见<a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/#id9" target="_blank" rel="external">http://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/#id9</a>。<br>BS解析的过程是：</p>
<ul>
<li>先找到table class=”content_table”的标签；</li>
<li>在从上面的内容中找所有tr</li>
<li>我们需要的信息在tr的td中</li>
<li>结果存入IPItem类。</li>
</ul>
<p><strong>IPItem的定义</strong></p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">IPItem</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>
        self.ip = <span class="string">''</span>    <span class="comment"># IP</span>
        self.port = <span class="string">''</span>  <span class="comment"># Port</span>
        self.addr = <span class="string">''</span>  <span class="comment"># 位置</span>
        self.tpye = <span class="string">''</span>  <span class="comment">#类型:http; https</span>
        self.speed = -<span class="number">1</span> <span class="comment">#速度</span>
</code></pre><h2 id="二、Ping所有IP地址的连接速度">二、Ping所有IP地址的连接速度</h2><pre><code>import pexpect
def <span class="function"><span class="title">test_ip_speed</span><span class="params">(ip_items)</span></span>:
    tmp_items = []
    <span class="keyword">for</span> item <span class="keyword">in</span> ip_items:

        (command_output, exitstatus) = pexpect.<span class="function"><span class="title">run</span><span class="params">(<span class="string">"ping -c1 %s"</span> % item.ip, timeout=<span class="number">5</span>, withexitstatus=<span class="number">1</span>)</span></span>
        <span class="keyword">if</span> exitstatus == <span class="number">0</span>:
            print command_output
            m = re.<span class="function"><span class="title">search</span><span class="params">(<span class="string">"time=([\d\.]+)"</span>, command_output)</span></span>
            <span class="keyword">if</span> m:
                print <span class="string">'time='</span>, m.<span class="function"><span class="title">group</span><span class="params">(<span class="number">1</span>)</span></span>
                item<span class="class">.speed</span> = <span class="function"><span class="title">float</span><span class="params">(m.group(<span class="number">1</span>)</span></span>)
                tmp_items.<span class="function"><span class="title">append</span><span class="params">(item)</span></span>

   ip_items = tmp_items
</code></pre><p>主要是利用pexpect模块调用系统的ping命令，上面代码在mac 10.11.1下测试通过。</p>
<h2 id="三、按速度从快到慢排序，保存至文件">三、按速度从快到慢排序，保存至文件</h2><p>保存至文件利用pandas模块，只需一句代码即可搞定。</p>
<ol>
<li>先把ip_items转换成pandas的DataFrame；</li>
<li>排序，df.sort_index()，按’Speed’列排序；</li>
<li>结果写入Excel文件，to_excel()</li>
</ol>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">save_data</span><span class="params">(self)</span>:</span>
        df = DataFrame({<span class="string">'IP'</span>:[item.ip <span class="keyword">for</span> item <span class="keyword">in</span> ip_items],
                        <span class="string">'Port'</span>:[item.port <span class="keyword">for</span> item <span class="keyword">in</span> self.ip_items],
                        <span class="string">'Addr'</span>:[item.addr <span class="keyword">for</span> item <span class="keyword">in</span> self.ip_items],
                        <span class="string">'Type'</span>:[item.tpye <span class="keyword">for</span> item <span class="keyword">in</span> self.ip_items],
                        <span class="string">'Speed'</span>:[item.speed <span class="keyword">for</span> item <span class="keyword">in</span> self.ip_items]
                        }, columns=[<span class="string">'IP'</span>, <span class="string">'Port'</span>, <span class="string">'Addr'</span>, <span class="string">'Type'</span>, <span class="string">'Speed'</span>])
        <span class="keyword">print</span> df[:<span class="number">10</span>]
        df[<span class="string">'Time'</span>] = GetNowTime()
        df = df.sort_index(by=<span class="string">'Speed'</span>)

        now_data = GetNowDate()


        file_name = self.dir_path +<span class="string">'ip_proxy_'</span> + now_data + <span class="string">'.xlsx'</span>

        df.to_excel(file_name)
</code></pre><p>生成的excel文件如下：<br><img src="http://7xo67b.com1.z0.glb.clouddn.com/ip_results.png" alt="results"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>爬虫采集数据时，如果频繁的访问某个网站，会被封IP，有些是禁止访问3小时，有些是直接拉黑名单。为了避免被禁，一般采取的措施有三种：</p>
<blockquote>
<ol>
<li>放慢抓取的速度，设置一个时间间隔；</li>
<li>模拟浏览器行为，如采用Selenium + PhantomJS；</li>
<li>设置IP代理，定期更换代理IP，让网站不认为来自一个IP。</li>
</ol>
</blockquote>
<p>本文实现其中的第三种方法。<br>国内提供IP代理的网站有很多，我们以其中的一个为例：<a href="http://www.haodailiip.com">http://www.haodailiip.com</a><br>分为三步来实现这个IP抓取类：</p>
<blockquote>
<ol>
<li>解析网页中的IP和端口</li>
<li>Ping所有IP地址的连接速度 </li>
<li>按速度从快到慢排序，保存到文件</li>
</ol>
</blockquote>]]>
    
    </summary>
    
      <category term="IP代理" scheme="http://www.kekefund.com/tags/IP%E4%BB%A3%E7%90%86/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://www.kekefund.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python正则表达式]]></title>
    <link href="http://www.kekefund.com/2015/11/10/python-regex/"/>
    <id>http://www.kekefund.com/2015/11/10/python-regex/</id>
    <published>2015-11-10T07:09:20.000Z</published>
    <updated>2015-11-19T04:53:13.000Z</updated>
    <content type="html"><![CDATA[<p>许多语言处理任务都涉及模式匹配。例如,可以使用endswith(‘ed’)找出以“ed”结尾的词。正则表达式提出了一个更加强大和灵活的方法描述感兴趣的字符模式。在Python中使用正则表达式，需要使用import re导入re函数库。</p>
<p><strong>下表为正则表达式基本元字符，其中包括通配符、范围和闭包</strong><br><img src="http://7xo67b.com1.z0.glb.clouddn.com/regex1.png" alt="正则模式"></p>
<a id="more"></a>
<h2 id="贪婪模式与非贪婪模式">贪婪模式与非贪婪模式</h2><p>Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。<br>例如：正则表达式 “ab<em>”，如果用于查找“abbbc”，将找到“abbb”。而如果使用非贪婪的数量词“ab\</em>?“，将找到”a“</p>
<ol>
<li><p>*? 是一个固定的搭配，.和*代表可以匹配任意无限多个字符，加上？表示使用非贪婪模式进行匹配，也就是我们会尽可能短地做匹配。</p>
</li>
<li><p>(.*?)代表一个分组，在这个正则表达式中我们匹配了五个分组，在后面的遍历item中，item[0]就代表第一个(.*?)所指代的内容，item[1]就代表第二个(.*?)所指代的内容，以此类推。</p>
</li>
<li><p>re.S 标志代表在匹配时为点任意匹配模式，点 . 也可以代表换行符。</p>
</li>
</ol>
<h2 id="re模块">re模块</h2><h3 id="一、re-search()">一、re.search()</h3><p>使用正则表达式&lt;<ed$>&gt;查找以ed结尾的词汇。使用函数re.search(p, s) 检查字符串s中是否有模式p。</ed$></p>
<pre><code><span class="keyword">import</span> re
<span class="keyword">import</span> nltk
In[<span class="number">12</span>]: wsj = sorted(set(nltk.corpus.treebank.word()))
In[<span class="number">13</span>]: ws = [w <span class="keyword">for</span> w <span class="keyword">in</span> wsj <span class="keyword">if</span> re.search(<span class="string">'ed$'</span>, w)]

In[<span class="number">15</span>]: ws[:<span class="number">10</span>]
Out[<span class="number">15</span>]: 
[<span class="string">u'62%-owned'</span>,<span class="string">u'Absorbed'</span>,<span class="string">u'Advanced'</span>,<span class="string">u'Alfred'</span>, <span class="string">u'Allied'</span>, <span class="string">u'Annualized'</span>, <span class="string">u'Arbitrage-related'</span>,
 <span class="string">u'Asked'</span>,<span class="string">u'Atlanta-based'</span>, <span class="string">u'Bermuda-based'</span>]
</code></pre><p>通配符“.”可以用来匹配任何单个字符。假设有一个8个字母组成的字谜，j是第三个字母，t是第六个字母。每个空白单元格用句点隔开。</p>
<pre><code>In[<span class="number">16</span>]: ws = [w <span class="keyword">for</span> w <span class="keyword">in</span> wsj <span class="keyword">if</span> re.search(<span class="string">'^..j..t..$'</span>, w)]
In[<span class="number">18</span>]: ws
Out[<span class="number">18</span>]: [<span class="string">u'adjusted'</span>, <span class="string">u'rejected'</span>]
</code></pre><p>匹配除元音字母之外的所有字母</p>
<pre><code><span class="collection">[<span class="comment">^aeiouAEIOU</span>]</span>
</code></pre><p><strong>?:</strong><br>如果要使用括号来指定连接的范围，又不想选择要输出字符串，必须添加“?:”。</p>
<pre><code>In[<span class="number">20</span>]: re.findall(<span class="string">r'^.*(?:ing|ly|ed|ies)$'</span>, <span class="string">'processing'</span>)
Out[<span class="number">20</span>]: [<span class="string">'processing'</span>]
</code></pre><p>演示如何使用符号：\，{}，() 和 |</p>
<pre><code>In[<span class="number">20</span>]: ws = [w <span class="keyword">for</span> w <span class="keyword">in</span> wsj <span class="keyword">if</span> re.search(<span class="string">'^[0-9]+\.[0-9]+$'</span>, w)]
In[<span class="number">21</span>]: ws[:<span class="number">5</span>]
Out[<span class="number">21</span>]: [<span class="string">u'0.0085'</span>, <span class="string">u'0.05'</span>, <span class="string">u'0.1'</span>, <span class="string">u'0.16'</span>, <span class="string">u'0.2'</span>]

In[<span class="number">22</span>]: ws = [w <span class="keyword">for</span> w <span class="keyword">in</span> wsj <span class="keyword">if</span> re.search(<span class="string">'^[A-Z]+\$$'</span>, w)]
In[<span class="number">23</span>]: ws
Out[<span class="number">23</span>]: [<span class="string">u'C$'</span>, <span class="string">u'US$'</span>]

In[<span class="number">24</span>]: ws = [w <span class="keyword">for</span> w <span class="keyword">in</span> wsj <span class="keyword">if</span> re.search(<span class="string">'^[0-9]{4}$'</span>, w)]
In[<span class="number">26</span>]: ws[:<span class="number">5</span>]
Out[<span class="number">26</span>]: [<span class="string">u'1614'</span>, <span class="string">u'1637'</span>, <span class="string">u'1787'</span>, <span class="string">u'1901'</span>, <span class="string">u'1903'</span>]

In[<span class="number">27</span>]: ws = [w <span class="keyword">for</span> w <span class="keyword">in</span> wsj <span class="keyword">if</span> re.search(<span class="string">'(ed|ing)$'</span>, w)]
In[<span class="number">28</span>]: ws[:<span class="number">5</span>]
Out[<span class="number">28</span>]: [<span class="string">u'62%-owned'</span>, <span class="string">u'Absorbed'</span>, <span class="string">u'According'</span>, <span class="string">u'Adopting'</span>, <span class="string">u'Advanced'</span>]
</code></pre><h3 id="二、re-split()">二、re.split()</h3><p>按照能够匹配的子串将string分割后返回列表。</p>
<h4 id="re-split(pattern,_string[,maxsplit])">re.split(pattern, string[,maxsplit])</h4><pre><code>In[<span class="number">13</span>]: raw = <span class="string">"""'When I'M a Duchess,' she said to herself, (not in a very hopeful tone
<span class="prompt">... </span>though), 'I won't have any pepper in my kitchen AT ALL. Soup does very
<span class="prompt">... </span>well without--Maybe it's always pepper that makes people
<span class="prompt">... </span>hot-tempered,'..."""</span>
In[<span class="number">16</span>]: re.split(<span class="string">r' '</span>, raw)
Out[<span class="number">16</span>]: 
[<span class="string">"'When"</span>,
 <span class="string">"I'M"</span>,
 <span class="string">'a'</span>,
 <span class="string">"Duchess,'"</span>,...]
In[<span class="number">17</span>]: re.split(<span class="string">'[ \t\n]'</span>, raw)
Out[<span class="number">17</span>]: 
[<span class="string">"'When"</span>,
 <span class="string">"I'M"</span>,
 <span class="string">'a'</span>,
 <span class="string">"Duchess,'"</span>,...]
</code></pre><h4 id="split(string[,_maxsplit])">split(string[, maxsplit])</h4><pre><code>In [<span class="number">1</span>]: <span class="keyword">import</span> re

In [<span class="number">2</span>]: p = re.compile(<span class="string">r'\d+'</span>)

In [<span class="number">3</span>]: p.split(<span class="string">'one1two2three3four4'</span>)
Out[<span class="number">3</span>]: [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>, <span class="string">''</span>]
</code></pre><h4 id="切分字符串">切分字符串</h4><p>Python自带的字符分割函数</p>
<pre><code><span class="string">'a b   c'</span>.<span class="function"><span class="title">split</span><span class="params">(<span class="string">' '</span>)</span></span>
[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'c'</span>]
</code></pre><p>嗯，无法识别连续的空格</p>
<pre><code><span class="keyword">import</span> re
<span class="prompt">&gt;&gt;&gt; </span>re.split(<span class="string">r'\s+'</span>, <span class="string">'a b    c'</span>)
[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]
</code></pre><p>使用re，无论多少个空格都可正常分割</p>
<h3 id="三、findall()">三、findall()</h3><p>findall函数返回的总是正则表达式在字符串中所有匹配结果的列表。</p>
<pre><code>In [<span class="number">2</span>]: <span class="tag">p</span> = re.<span class="function"><span class="title">compile</span><span class="params">(r<span class="string">'\d+'</span>)</span></span>

In [<span class="number">4</span>]: <span class="tag">p</span>.<span class="function"><span class="title">findall</span><span class="params">(<span class="string">'one1two2three3four4'</span>)</span></span>
Out[<span class="number">4</span>]: [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>]

In [<span class="number">5</span>]: ss = <span class="string">"adfad asdfasdf asdfas asdfawef asd adsfas "</span>

In [<span class="number">6</span>]: <span class="tag">p</span> = re.<span class="function"><span class="title">compile</span><span class="params">(<span class="string">'((\w+)\s+\w+)'</span>)</span></span>

In [<span class="number">7</span>]: <span class="tag">p</span>.<span class="function"><span class="title">findall</span><span class="params">(ss)</span></span>
Out[<span class="number">7</span>]:
[(<span class="string">'adfad asdfasdf'</span>, <span class="string">'adfad'</span>),
 (<span class="string">'asdfas asdfawef'</span>, <span class="string">'asdfas'</span>),
 (<span class="string">'asd adsfas'</span>, <span class="string">'asd'</span>)]

In [<span class="number">8</span>]: <span class="tag">p</span> = re.<span class="function"><span class="title">compile</span><span class="params">(<span class="string">'(\w+)\s+\w+'</span>)</span></span>

In [<span class="number">9</span>]: <span class="tag">p</span>.<span class="function"><span class="title">findall</span><span class="params">(ss)</span></span>
Out[<span class="number">9</span>]: [<span class="string">'adfad'</span>, <span class="string">'asdfas'</span>, <span class="string">'asd'</span>]
</code></pre><ol>
<li><p>当给出的正则表达式中不带括号时，列表的元素为字符串，此字符串为整个正则表达式匹配的内容。 </p>
</li>
<li><p>当正则表达式中带有多个括号时，列表的元素为多个字符串组成的tuple，tuple中字符串个数与括号对数相同，字符串内容与每个括号内的正则表达式相对应，并且排放顺序是按括号出现的顺序。</p>
</li>
<li><p>当给出的正则表达式中带有一个括号时，列表的元素为字符串，此字符串的内容与括号中的正则表达式相对应。</p>
</li>
</ol>
<h3 id="四、re-search()">四、re.search()</h3><p>re.search函数会在字符串内查找模式匹配，只要找到第一个匹配就返回，如果字符串没有匹配，则返回None。</p>
<pre><code>In [<span class="number">15</span>]: text = <span class="string">"JGood is a handsome boy, he is cool, clever, and so on..."</span>

In [<span class="number">16</span>]: m = re.search(<span class="string">r'(\w+)ome'</span>, text)

In [<span class="number">20</span>]: <span class="keyword">if</span> m:
   ....: <span class="keyword">print</span> m.group(<span class="number">0</span>), m.group(<span class="number">1</span>)
   ....: <span class="keyword">else</span>:
   ....: <span class="keyword">print</span> <span class="string">'not search'</span>
</code></pre><p>其中 group(0）或group()匹配的是整个字符串，group(1)匹配的是第一个括号中内容。   </p>
<h3 id="五、re-match()">五、re.match()</h3><p>re.match()和re.search()的区别：re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</p>
<pre><code><span class="keyword">In</span> [30]: s1 = <span class="string">"helloworld, i am 30!"</span>

<span class="keyword">In</span> [31]: w1 = 'world'

<span class="keyword">In</span> [32]: m1 = re.<span class="literal">match</span>(w1, s1)

<span class="keyword">In</span> [33]: <span class="keyword">if</span> m1:
   ....:     <span class="keyword">print</span> m1.<span class="literal">group</span>()
   ....: <span class="keyword">else</span>:
   ....:     <span class="keyword">print</span> <span class="string">"not find"</span>
   ....:
not find
</code></pre><h3 id="六、re-sub()">六、re.sub()</h3><p>re.sub用于替换字符串中的匹配项。<br>下面的例子将字符串中的空格’ ‘替换成’-‘</p>
<pre><code>In [<span class="number">2</span>]: text = <span class="string">"JGood is a handsome boy, he is cool, clever, and so on..."</span>

In [<span class="number">3</span>]: re.sub(<span class="string">r'\s+'</span>, <span class="string">'-'</span>, text)
Out[<span class="number">3</span>]: <span class="string">'JGood-is-a-handsome-boy,-he-is-cool,-clever,-and-so-on...'</span>
</code></pre><p><strong>re.sub的函数原型为：re.sub(pattern, repl, string, count)</strong></p>
<pre><code>其中第二个参数时替换后的字符串；
第四个参数为替换个数。默认为<span class="number">0</span>，表示每个匹配项都替换。
</code></pre><p>re.sub还允许使用函数对匹配项的替换进行复杂的处理。如：</p>
<pre><code>re.sub(<span class="string">r'\s'</span>, <span class="keyword">lambda</span> m : <span class="string">'['</span> + m.group(<span class="number">0</span>) + <span class="string">']'</span>, text, <span class="number">0</span>)
</code></pre><p>将字符串中的空格’‘替换为’[]’。</p>
<h3 id="七、re-compile()">七、re.compile()</h3><p>可以把正则表达式编译成一个正则表达式对象。对于经常要用的正则表达式，可以提高一定的效率。</p>
<pre><code>In [<span class="number">4</span>]: text = <span class="string">"JGood is a handsome boy, he is cool, clever, and so on..."</span>

In [<span class="number">6</span>]: regex = re.compile(<span class="string">r'\w*oo\w*'</span>)

In [<span class="number">7</span>]: regex.findall(text) <span class="comment">#查找所有包含’oo‘的单词</span>
Out[<span class="number">7</span>]: [<span class="string">'JGood'</span>, <span class="string">'cool'</span>]

In [<span class="number">8</span>]: regex.sub(<span class="keyword">lambda</span> m : <span class="string">'['</span> + m.group(<span class="number">0</span>) + <span class="string">']'</span>, text) <span class="comment"># 将字符串中含有’oo‘的单词用[]括起来</span>
Out[<span class="number">8</span>]: <span class="string">'[JGood] is a handsome boy, he is [cool], clever, and so on...'</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>许多语言处理任务都涉及模式匹配。例如,可以使用endswith(‘ed’)找出以“ed”结尾的词。正则表达式提出了一个更加强大和灵活的方法描述感兴趣的字符模式。在Python中使用正则表达式，需要使用import re导入re函数库。</p>
<p><strong>下表为正则表达式基本元字符，其中包括通配符、范围和闭包</strong><br><img src="http://7xo67b.com1.z0.glb.clouddn.com/regex1.png" alt="正则模式"></p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://www.kekefund.com/tags/Python/"/>
    
      <category term="re" scheme="http://www.kekefund.com/tags/re/"/>
    
      <category term="模式匹配" scheme="http://www.kekefund.com/tags/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    
      <category term="正则表达式" scheme="http://www.kekefund.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[期货大作手风云录 读书笔记]]></title>
    <link href="http://www.kekefund.com/2015/11/06/fengyunlu-md/"/>
    <id>http://www.kekefund.com/2015/11/06/fengyunlu-md/</id>
    <published>2015-11-06T07:09:20.000Z</published>
    <updated>2015-11-19T04:52:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="期货大作手风云录">期货大作手风云录</h1><h3 id="读书笔记">读书笔记</h3><h2 id="一、趋势">一、趋势</h2><ol>
<li><strong>投机法则之一：放鱼头，弃鱼尾，吃鱼肚。一个品种的趋势行情分为鱼头、鱼肚和鱼尾行情。鱼头行情往往是趋势行情初始起步阶段，你很难分期是反转还是反弹，所以很难吃到。鱼尾行情往往是一波趋势行情的末端，最大的特点是连续的逼空或者逼多，一方认输出局，所谓多头不死空头不止，这种鱼尾行情随时有可能反转或者巨幅震荡，不吃也罢。而在我看来，我们期货作手真正需要去大吃、狠吃的阶段是鱼肚行情，此时趋势已成，行情进三退一，这是才是我们需要重仓且不断浮盈加仓大口吃肉的好时机。</strong><a id="more"></a></li>
<li><strong>判断大势的方法有很多，有通过技术面判断的，也有通过基本面判断的，但今天要强调只有两点：第一，政治大于经济。当你做多或者做空某商品时，首先考虑的不应该是供需关系，而是该商品的政治因素。简单点说，现在的世界超级大国仍然是美国，如果你发现近期由于政治原因需要石油价格上涨时，即使供需和技术面都支持你做空，你也应该果断放弃。特别是石油、铜、黄金这类关系到美国切身利益的期货品种，尤其不能和美国政府对着干。</strong></li>
<li><strong>关于如何判断大势的第二点，我要强调的是：整体趋势大于个体趋势。具体来说，当大多数商品都处于上涨周期时，不要轻易去做空任何一个商品，特别是对于股票市场来说，如果现在大势处于熊市，即使基本面和技术面再好的股票，也不要去做多。切记这一点。</strong></li>
<li><strong>如果市场处于牛市中，而某个商品或者股票没有上涨，这反而是去做多它的好时机呢？ 错。做多只做龙头，做空只做熊头。记住，股价永远不会因为太高二停止上涨，同样的，股价也永远不会因为太低而停止下跌。重势不重价。只有龙头和熊头才会带给你超额的利润，其他的品种根本没必要去关注他们。</strong></li>
<li><strong>期货市场的行情分为趋势行情和震荡行情。市场的80%的时间都处于震荡行情之中，只有20%的趋势行情才能让我们赚大钱。但遗憾的是，绝大多数投机者总想抓住市场的每一个机会，总想像上班一样每天都能赚到钱，结果是在80%的震荡行情中赔掉了大部分的钱。周而复始，恶性循环。</strong></li>
</ol>
<h2 id="二、法则">二、法则</h2><ol>
<li><strong>“止语”的修行方法来自佛法的戒定慧：先戒，戒能生定，而定后能生慧。此乃佛法的博大精深也！</strong></li>
<li><p><strong>行情在绝望中产生，行情在犹豫中发展，行情在热闹中高潮，行情在兴奋中灭亡。</strong></p>
</li>
<li><p><strong>有人的地方就有江湖，有资金的地方就有大行情。这句话在期货里一点不假。</strong></p>
</li>
<li><strong>草原生物链中最厉害的角色是鳄鱼。因为鳄鱼有足够的耐心、信心和狠心。所谓耐心，就是指鳄鱼从来不随便游来游去去寻找猎物，这样多半是白白耗费体力。鳄鱼总是耐心的潜伏在水塘里，趴在猎物必须要喝水的地方，静静地耐心等待猎物自己找上门来；所谓信心，就是指鳄鱼不管几天没有遇到猎物，即使他已经饥肠辘辘，但他还会继续有信心的待在原地等待猎物，直到猎物出现；所谓狠心，就是指一旦猎物出现在鳄鱼的射程之内，它会毫不犹豫的发起攻击，一击致命，绝不嘴软，直到把猎物彻底咬死。鳄鱼的这三个特点，决定了他能在物竞天择的生物链里顽强的活到现在。而这三个特点，也是我们期货作手最需要具备的。</strong></li>
<li><strong>简单的事实是，行情总是先发生变化，然后才有经济新闻，市场不会对经济新闻作出反应。市场是活的，它反映的是将来。因此，企图genuine当前的经济新闻和当前的事件预测股市的走势是非常愚蠢的。贪婪和恐惧一样，都会扭曲理性。股市只讲事实，只讲现实，只讲理性，股市永远不会错，错的是交易者。</strong></li>
<li><strong>投资法则：只相信自己的眼睛，不要相信自己的耳朵！只相信自己的大脑，不要相信别人的建议！</strong></li>
<li><strong>期货最怕的就是快！很多时候，快就是慢！快的同义词就是风险。当你的账户盈利曲线越陡峭，你越应该引起高度的警惕，因为快速的都是短暂的，只有缓慢的才是稳定的。切记，做期货比的不是谁赢得多，而是看谁活得长。切记！</strong></li>
<li><strong>人如果犯错误，那用不了一个月就能拥有整个世界。但是反过来，如果一个人不能从自己的错误中汲取经验教训，他迟早一文不名。</strong></li>
<li><strong>投机于赌博的最大区别在于是否拥有大局观。</strong></li>
</ol>
<h2 id="三、操作">三、操作</h2><ol>
<li><p><strong>期货的魅力在于浮盈加仓，只有不断的浮盈加仓，我们才能赚取超额的巨大利润。但浮盈加仓的勇气来源于哪里？只有不断的盈利才是我们加仓的勇气！这就像你去带一支军队打仗，什么才是你们官兵不断勇敢冲锋的动力？唯有胜利！只有你的账户不断盈利了，你才有勇气去加仓，去继续以小搏大。</strong></p>
</li>
<li><p><strong>期货行业内有一句话，叫做：赚或赔靠本事，赚多赚少靠运气。也就是说，如果你赔了，那是你分析不到位，说明你没本事，如果你赚了，那么赚多赚少就要靠运气和天意了。</strong></p>
</li>
<li><p><strong>从某种意义上来说，投资并不是一个天道酬勤的行业。这个行业的秘诀在于节奏。会买的是徒弟，会卖的是师父，会空仓休息的是大事。对于期货作手来说，等待和寂寞也许是陪伴他一生的修炼法门。</strong></p>
</li>
<li><p><strong>既然是重仓，为什么利弗莫尔还要逐步建仓？为什么不能一次性重仓呢？那是因为谁也不敢保证自己一定是对的。只有账单上的盈利数字会告诉你对还是错，盈利了就加仓，亏损了就止损，让盈利奔跑，让亏损尽快了结。这是投机的不二法则。</strong></p>
</li>
<li><p><strong>一旦我们试仓之后市场朝着有利于我们的方向行进，我们有了浮盈，那么就开始倒金字塔加仓，就像利弗莫尔那样，1，2，4，8似的加仓，这样你的仓位自然就上来了，记住，股票永远不会因为价格太高而不可买进，或者因为价格太低而不可卖出。在你第一笔交易之后，除非第一笔交易有利润，否则就不可做第二笔。切记！</strong></p>
</li>
<li><p><strong>股市不是法庭，他不会跟你讲道理。股市更像是战场，他只会用实力去说话。打仗靠枪，炒股靠钱。所以，钱就是股票上涨的最终动力。当你发现一只股票价格开始不断上涨时，我们不用去刻意分析股票上涨的背后原因是什么，不要去打探他的消息，也不用去分析他的基本面有何变化，你只需去判断一个问题，是不是有大资金入场买股票了？只要有钱进来，什么技术面，什么基本面，什么重组消息，都会陆陆续续浮出水面的。原因很简单，大资金绝不会随随便便买入一只股票，他一定会把后面的故事给你讲得圆圆满满的！</strong></p>
</li>
<li><p><strong>原来人面来到投机市场的目的是不同的：有人是来过瘾的，因为频繁交易本身会带来快感；有的是来逛街的，只看不买，娱乐而已；还有极少数人是来赚钱的，他们需要时刻克制自己交易的冲动。。。</strong></p>
</li>
<li><p><strong>有句话说得好：在市场里，多头可以赚钱，空头也可以赚钱，但滑头早晚会死掉。</strong></p>
</li>
<li><p><strong>市场趋势显示下跌，但政府希望绿豆止跌，当市场和政府观点相反时，我选择空仓观望。期货比的不是谁赚的最多，而是比谁活得最长。方向不明时，空仓就是最好的策略。</strong></p>
</li>
<li><p><strong>期货往往就是这样，一开始就出现浮亏的持仓往往最终都很难赚钱。好的开始是成功的一半，这话在期货市场一点不假。</strong></p>
</li>
<li><p><strong>期货是个概率游戏。我们这些期货作手终生追求的目标只有一个：大赚小赔。也就是说，100次交易中，你失败90次也没关系，关键是如何在你作对的10次交易中，把盈利放大到远远超过你做错的90次亏损。</strong></p>
</li>
<li><p><strong>绝不能让自己盈利的单子变为亏损！这是期货投机的重要原则。以做多为例，随着你的分步建仓，你的持仓成本是在不断提高的，由于你是浮盈加仓，所以你应该是一直处于盈利中的，而盈利中的单子需要设立止盈点，这个止盈点就应该设立在你的持仓成本之上。一旦市场发生反向波动，如果触及到你的止盈点，你就应该毫不犹豫的平仓止盈。绝对不能让你原来盈利的单子面临亏损的可能，这是原则问题。止盈点因人而异，我的个人习惯是把止盈点设在最近的一次加仓点上。我的逻辑很简单：如果市场价格跌破了我的最近一次加仓点，那至少说明我这最后一次加仓的时机是错误的。既然错误了，我就要付出代价，所谓的代价就是全部平仓出局观望。我绝对不允许自己的盈利单变成亏损单。</strong></p>
</li>
<li><p><strong>在我看来，股票基本面分析的精髓不在于分析公司未来的盈利能力，而在于分析公司股票的供求关系。简单来说，就是在股市里，到底是买股票的人多？还是卖股票的人多？如果在一段时间内，主动卖股票的人大大多于卖股票的人，那就是供不应求，股价就会持续上涨，反之，如果主动卖股票的人多于买股票的人，那就是供大于求，股价就会持续下跌。供求决定价格，这才是我理解的基本面分析。</strong></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="期货大作手风云录">期货大作手风云录</h1><h3 id="读书笔记">读书笔记</h3><h2 id="一、趋势">一、趋势</h2><ol>
<li><strong>投机法则之一：放鱼头，弃鱼尾，吃鱼肚。一个品种的趋势行情分为鱼头、鱼肚和鱼尾行情。鱼头行情往往是趋势行情初始起步阶段，你很难分期是反转还是反弹，所以很难吃到。鱼尾行情往往是一波趋势行情的末端，最大的特点是连续的逼空或者逼多，一方认输出局，所谓多头不死空头不止，这种鱼尾行情随时有可能反转或者巨幅震荡，不吃也罢。而在我看来，我们期货作手真正需要去大吃、狠吃的阶段是鱼肚行情，此时趋势已成，行情进三退一，这是才是我们需要重仓且不断浮盈加仓大口吃肉的好时机。</strong>]]>
    
    </summary>
    
      <category term="期货" scheme="http://www.kekefund.com/tags/%E6%9C%9F%E8%B4%A7/"/>
    
      <category term="股票" scheme="http://www.kekefund.com/tags/%E8%82%A1%E7%A5%A8/"/>
    
      <category term="Stock" scheme="http://www.kekefund.com/categories/Stock/"/>
    
  </entry>
  
</feed>
