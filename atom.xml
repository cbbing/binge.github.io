<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Keke‘s Blog]]></title>
  <subtitle><![CDATA[Python and Quant]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.kekefund.com/"/>
  <updated>2016-05-03T08:40:56.000Z</updated>
  <id>http://www.kekefund.com/</id>
  
  <author>
    <name><![CDATA[Binger]]></name>
    <email><![CDATA[cbbing@163.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[基金从业资格考试笔记]]></title>
    <link href="http://www.kekefund.com/2016/05/03/fund-qualification-examination/"/>
    <id>http://www.kekefund.com/2016/05/03/fund-qualification-examination/</id>
    <published>2016-05-03T07:51:54.000Z</published>
    <updated>2016-05-03T08:40:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="第一章_金融、资产管理与投资基金">第一章 金融、资产管理与投资基金</h1><h2 id="1，金融资产">1，金融资产</h2><p>一般分为债券类金融资产和股权类金融资产。</p>
<p>债券类金融资产以票据、债券等契约型投资工具为主，股权类金融资产以各类股票为主。</p>
<h2 id="2，投资基金的主要类别">2，投资基金的主要类别</h2><p>主要按照所投资的对象的不同进行区分：</p>
<ol>
<li><p>证券投资基金<br>基金所投资的有价证券主要是在证券交易所或银行间市场上公开交易的证券，包括股票、债券、货币、金融衍生工具等。<br>可分为公募证券投资基金和私募证券投资基金等种类。</p>
</li>
<li><p>私募股权基金<br>私募股权基金（private equity，PE）指通过私募形式对私有企业，即非上市企业进行的权益性投资。</p>
</li>
<li><p>风险投资基金<br>风险投资基金（venture capital，VC），又叫创业基金，它以一定的方式吸收机构和个人的资金，投向与那些不具备上市资格的初创期的或者是小型的新型企业，尤其是高新技术企业，帮助所投资的企业尽快成熟，取得上市资格，从而使资本增值。</p>
</li>
<li><p>对冲基金（hedge fund），意为“风险对冲过的基金”，它是基于投资理论和极其复杂的金融市场操作技巧，充分利用各种金融衍生产品的杠杆作用，承担高风险、追求高收益的投资模式。</p>
</li>
<li><p>另类投资基金<br>是指投资于传统的股票、债券之外的金融和实物资产的基金，如房地产、证券化资产、对冲基金、大宗商品、黄金、艺术品等。</p>
</li>
</ol>
<a id="more"></a>
<h1 id="第二章_证券投资基金概述">第二章 证券投资基金概述</h1><h2 id="1，证券投资基金的特点">1，证券投资基金的特点</h2><ol>
<li><p>集合理财、专业管理</p>
</li>
<li><p>组合投资、分散风险</p>
</li>
<li><p>利益共享、风险共担</p>
</li>
<li><p>严格管理、信息透明</p>
</li>
<li><p>独立托管、保障安全</p>
</li>
</ol>
<h2 id="2,_基金与股票、债券的差异">2, 基金与股票、债券的差异</h2><p>股票反映的是一种所有权关系，是一种所有权凭证，投资者购买股票后就成为公司的股东；<br>债券反映的是债权债务关系，是一种债权凭证，投资者购买债券后就成为公司的债权人；<br>基金反映的则是一种信托关系，是一种受益凭证，投资者购买基金份额就成为基金的受益人。</p>
<h2 id="3，封闭式基金与开放式基金">3，封闭式基金与开放式基金</h2><p>依据运作方式的不同，可以将基金分为封闭式基金与开放式基金。</p>
<p>封闭式基金是指基金份额在基金合同期限内固定不变，基金份额可以在依法设立的证券交易所交易，但基金份额持有人不得申请赎回的一种基金运作方式。</p>
<p>开放式基金是指基金份额不固定，基金份额可以在基金合同约定的时间和场所进行申购或赎回的一种基金运作方式。这里所指的开放式基金专指传统的开放式基金，不包括交易型开放式指数基金（ETF）和上市开放式基金（LOF）等新型开放式基金。</p>
<ul>
<li>开放式基金与封闭式基金的比较</li>
</ul>
<table>
<thead>
<tr>
<th>项目</th>
<th>开放式基金</th>
<th>封闭式基金</th>
</tr>
</thead>
<tbody>
<tr>
<td>规模</td>
<td>不固定</td>
<td>固定</td>
</tr>
<tr>
<td>存续期限</td>
<td>不确定，理论上可以无限期存续</td>
<td>确定</td>
</tr>
<tr>
<td>交易方式</td>
<td>一般不上市，通过向基金管理公司和代销机构进行申购赎回</td>
<td>上市流通</td>
</tr>
<tr>
<td>交易价格</td>
<td>按照每日基金单位资产净值</td>
<td>根据市场行情变化，相对于单位资产净值可能折价或溢价，多为折价</td>
</tr>
<tr>
<td>信息披露</td>
<td>每日公布基金单位资产净值，每季度公布资产组合，每6个月公布变更的招募说明书</td>
<td>每周公布基金单位资产净值，每季度公布资产组合</td>
</tr>
<tr>
<td>投资策略</td>
<td>强调流动性管理，基金资产中要保持一定现金及流动性资产</td>
<td>全部资金可进行长期投资</td>
</tr>
</tbody>
</table>
<h2 id="4，基金起源">4，基金起源</h2><p>第一只公认的证券投资基金——英国“海外及殖民地政府信托”</p>
<p>第一只开放式公司型基金 —— 美国“马萨诸塞投资信托基金”</p>
<h1 id="第三章_证券投资基金的类型">第三章 证券投资基金的类型</h1><h2 id="1，基金的分类">1，基金的分类</h2><p>（一）根据运作方式分类：</p>
<ul>
<li><p>封闭式基金</p>
</li>
<li><p>开放式基金</p>
</li>
</ul>
<p>（二）根据投资对象分类：</p>
<ul>
<li><p>股票基金：基金资产80%以上投资于股票</p>
</li>
<li><p>债券基金：基金资产80%以上投资与债券</p>
</li>
<li><p>货币市场基金：仅投资于货币市场工具</p>
</li>
<li><p>混合基金：投资于股票、债券和货币市场工具，但股票投资和债券投资的比例不符合股票基金、债券基金规定的为混合基金。</p>
</li>
<li><p>基金中的基金：80%以上的基金资产投资于其他基金份额</p>
</li>
</ul>
<p>（三）根据投资理念分类：</p>
<ul>
<li><p>主动型基金：一类力图取得超越基准组合表现的基金。</p>
</li>
<li><p>被动（指数）型基金：不主动寻求取得超越市场的表现，而是试图复制指数的表现。被动型基金一般选取特定的指数作为跟踪的对象，因此通常又被称为指数型基金。</p>
</li>
</ul>
<p>（四）根据募集方式分类：</p>
<ul>
<li><p>公募基金</p>
</li>
<li><p>私募基金</p>
</li>
</ul>
<p>（五）特殊类型基金</p>
<ul>
<li><p>系列基金：又称伞形基金，是指多个基金共用一个基金合同，子基金独立运作，基金直接可以进行相互转换的一种基金结构形式。</p>
</li>
<li><p>保本基金：指通过一定的保本投资策略进行运作，同时引入保本保障机制，以保住基金份额持有人在保本周期到期时，可以获得投资本金保住的基金。</p>
</li>
<li><p>上市交易型开放式指数基金（ETF）：又称为交易所交易基金（exchange traded funds，ETF），是一种在交易所上市交易的、基金份额可变的一种开放式基金。</p>
</li>
<li><p>上市开放式基金：（listed open-ended funds， LOF），是一种既可以在场外市场进行基金份额申购、赎回，又可以在交易所（场内市场）进行基金份额交易和基金份额申购或赎回的开放式基金。</p>
</li>
<li><p>QDII基金：（qualified domestic institutional investors，合格境内机构投资者），是指在一国境内设立，经该国有关部门批准从事境外证券市场的股票、债券等有价证券投资的基金。</p>
</li>
<li><p>分级基金：指通过事先约定基金的风险收益分配，将基础份额分为预期风险收益不同的子份额，并可将其中部分或全部份额上市交易的结构化证券投资基金。</p>
</li>
</ul>
<h2 id="2，股票基金">2，股票基金</h2><p>价值型股票通常是指收益稳定、价值被低估、安全性较高的股票，其市盈率、市净率通常较低。</p>
<p>成长型股票通常是指收益增长速度快、未来发展潜力大的股票，其市盈率、市净率通常较高。</p>
<h2 id="3，债券基金">3，债券基金</h2><p>根据债券发行者，可以将债券分为政府债券、企业债券、金融债券等。</p>
<p>根据债券到期日，可以将债券分为短期债券、长期债券等。</p>
<p>根据债券信用等级，可以将债券分为低等级债券、高等级债券等。</p>
<p>我国市场上的债券基金分类，常见的有以下类型：</p>
<ul>
<li><p>标准债券型基金，仅投资于固定收益类金融工具，不能投资股票市场，常称“纯债基金”。</p>
</li>
<li><p>普通债券型基金，即主要进行债券投资（80%以上基金资产），但也投资于股票市场，这类基金在我国市场上占主要部分。</p>
</li>
</ul>
<h2 id="4，货币市场基金">4，货币市场基金</h2><p>与其他类型基金相比，货币市场基金具有风险低、流动性好的特点。</p>
<p>货币市场工具通常指到期日不足1年的短期金融工具。</p>
<h2 id="5，保本基金">5，保本基金</h2><p>保本策略：</p>
<p>国际上比较流行的投资组合保险策略主要有对冲保险策略与固定比例投资组合保险策略（constant proportion portfolio insurance， CPPI）</p>
<p>对冲保险策略主要依赖金融衍生产品，如股票期权、股指期货等，实现投资组合价值的保本与增值。国内保本基金主要选择恒定比例投资组合保险策略作为投资的保本策略。</p>
<p>例子：</p>
<p>若某投资者投资10万元认购南方保本基金，加上该笔认购按照100%比例全部予以确认，并且持有到保本期到期，认购费率为1.0%。假设募集期间产生的利息为50元，持有期间基金累计分红0.08元/基金份额。则认购份额为：</p>
<pre><code>净认购金额 = <span class="number">100</span> <span class="number">000</span> / (<span class="number">1</span>+<span class="number">1.0</span>%) = <span class="number">99009.90</span> （元）

认购费用 = <span class="number">100</span> <span class="number">000</span> - <span class="number">99009.90</span> = <span class="number">990.1</span> （元）

认购份额 = （<span class="number">99009.90</span> + <span class="number">50</span>）/ <span class="number">1.00</span> = <span class="number">99059.90</span>（份）
</code></pre><p>（1）若保本期到期日，基金份额净值为0.90元</p>
<p>保本金额 = 基金份额持有人认购并持有到期的基金份额的投资金额 = 100000 + 50 = 100050.00 （元）</p>
<p>到期的基金份额与净值的乘积 = 99059.90 * 0.9 = 89153.91（元）</p>
<p>累计分红 = 99059.90 * 0.08 =  7924.79（元）</p>
<p>总金额 = 89153.91 + 7924.79 = 97078.70（元）</p>
<p>即：总金额 &lt; 保本金额</p>
<p>担保人应赔付的差额 = 100050.00 - 97078.70 = 2971.30（元）</p>
<p>（2）若保本期到期日，基金份额净值为1.38元</p>
<p>基金份额与净值的乘积 = 99059.90 * 1.38 = 136702.66（元）</p>
<p>累计分红 = 99059.90 * 0.08 =  7924.79（元）</p>
<p>总金额 = 136702.66 + 7924.79 = 144627.45（元）</p>
<p>即：总金额 &gt; 保本金额</p>
<p>到期日可赎回金额 = 136702.66（元）</p>
<h2 id="6，交易型开放式指数基金（ETF）">6，交易型开放式指数基金（ETF）</h2><p> 三大特点：</p>
<ol>
<li>被动操作的指数基金</li>
</ol>
<p>ETF是以某一选定的指数所包含的成分证券为投资对象，依据构成指数的股票种类和比例，采取完全复制或抽样复制，进行被动投资的指数基金。</p>
<ol>
<li>独特的实物申购、赎回机制。</li>
</ol>
<p>申购ETF时，需拿这只ETF指定的一篮子股票来换取；赎回时得到的不是现金，而是相应的一篮子股票，如果想变现，需要再卖出这些股票。</p>
<ol>
<li>实行一级市场与二级市场并存的交易制度。</li>
</ol>
<h3 id="ETF与LOF的区别">ETF与LOF的区别</h3><p>LOF与ETF都具备开放式基金可以申购、赎回和场内交易的特点，但两者存在本质区别，主要表现在：</p>
<p>(1) 申购、赎回的标的不同。ETF与投资者交换的是基金份额与一篮子股票，LOF的申购、赎回是基金份额与现金的对价。</p>
<p>(2) 申购、赎回的场所不同。ETF的申购、赎回通过交易所进行；LOF的申购、赎回既可以在代销网点进行，也可以在交易所进行。</p>
<p>(3) 对申购、赎回限制不同。只要资金在一定规模以上的投资者（基金份额通常要求在50万份以上）才能参与ETF的申购、赎回交易，LOF没有特别要求。</p>
<p>(4) 基金投资策略不同。ETF通常采用完全被动式管理方法，以拟合某一指数为目标；LOF可以是指数型基金，也可以是主动型基金。</p>
<p>(5) 在二级市场的净值报价上，ETF每15秒提供一个基金参考净值（IOPV）报价，LOF的净值报价频率要比ETF低，通常1天只提供1次或几次基金净值报价。</p>
<h3 id="ETF联接基金">ETF联接基金</h3><p>ETF联接基金是讲绝大部分基金财产投资于某一ETF（称为目标ETF），密切跟踪标的指数表现，可以在场外（银行渠道等）申购赎回的基金。</p>
<h2 id="7，QDII基金">7，QDII基金</h2><p>在境内募集资金进行境外证券投资的机构称为合格境内机构投资者（qualified domestic institutional investor，QDII）。</p>
<h2 id="8，分级基金">8，分级基金</h2><p>分级基金是指通过事先约定基金的风险收益分配，将母基金份额分为预期风险收益不同的子份额，并可将其中部分或全部类别份额上市交易的结构化证券投资基金。其中，分级基金的基础份额称为母基金份额，预期风险收益较低的子份额称为A类份额，预期风险收益较高的子份额称为B类份额。</p>
<p>基金成立后，投资者在场内认购的母基金份额自动分离为A类份额和B类份额，并上市交易；对于从场内申购的母基金份额，投资者即可选择将其分拆为A类份额和B类份额并上市交易，也可选择不进行基金份额分拆而保留母基金份额。</p>
<p>因此，证券交易所场内可存在三类份额：母基金份额、A类份额和B类份额，其中母基金份额通常只能够被申购和赎回，而A类份额和B类份额则只可上市交易。</p>
<ul>
<li><p>A类份额具有低风险、收益稳定的特征，比较适合保守型、偏好固定收益品种的投资者；</p>
</li>
<li><p>B类份额具有高风险、高预期收益的特征，比较适合偏好杠杆投资的激进型投资者；</p>
</li>
<li><p>母基金份额等同于普通股票指数基金份额，具有较高风险、较高预期收益的特征，比较适合具有较高风险承受能力的配置型投资者。</p>
</li>
</ul>
<h1 id="第四章_证券投资基金的监管">第四章 证券投资基金的监管</h1><h2 id="1，基金管理人">1，基金管理人</h2><p>依据《证券投资基金法》的规定，基金管理人由依法设立的公司或者合伙企业担任。而担任公开募集基金的基金管理人的主体资格受到严格限制，只能由基金管理公司或者经中国证监会按照规定核准的其他机构担任。所谓“中国证监会按照规定核准的其他机构”，是指依据中国证监会2013年2月18日发布的《资产管理机构开展公募证券投资基金管理暂行规定》，在股东、高级管理人员、经营期限、管理的基金财产规模等方面符合规定条件的证券公司、保险资产管理公司以及专门从事非公开募集基金管理业务的资产管理机构。</p>
<h2 id="2，基金经理任职条件：">2，基金经理任职条件：</h2><ul>
<li><p>取得基金从业资格；</p>
</li>
<li><p>通过中国证监会或者其授权机构组织的证券投资法律知识考试；</p>
</li>
<li><p>具有3年以上证券投资管理经历；</p>
</li>
<li><p>没有《公司法》《证券投资基金法》等法律、行政法规规定的不得担任公司董事、监事、经理和基金从业人员的情形；</p>
</li>
<li><p>最近3年没有受到证券、银行、工商和税务等行政管理部门的行政处罚。</p>
</li>
</ul>
<p>2013年《证券投资基金法》借鉴发达国家的监管思路和做法，一方面允许基金从业人员进行证券投资，另一方面强化对其监管。即在避免利益冲突的情况下，允许基金从业人员投资股票、债权、封闭式基金、可转债等证券；同时，要求相关人员进行事先申报，披露其投资行为，接受各方面的监督。</p>
<h2 id="3，公开募基金">3，公开募基金</h2><h3 id="募集期限">募集期限</h3><p>基金管理人应当自收到准予注册文件之日起6个月内进行基金募集。</p>
<h3 id="投资范围：">投资范围：</h3><ul>
<li><p>上市交易的股票、债券</p>
</li>
<li><p>中国证监会规定的其他证券及其衍生品种。</p>
</li>
</ul>
<h2 id="4，非公开募集基金">4，非公开募集基金</h2><p>依据《证券投资基金法》的规定，非公开募集基金应当向合格投资者募集，合格投资者累计不得超过200人。</p>
<h3 id="私募基金的合格投资者">私募基金的合格投资者</h3><p>指具备相应风险识别能力和风险承担能力，投资于单只私募基金的金额不低于100万元且符合下列相关标准的单位和个人：</p>
<ul>
<li><p>净资产不低于1000万元的单位；</p>
</li>
<li><p>金融资产不低于300万元或者最近3年个人年均收入不低于50万元的个人。</p>
</li>
</ul>
<p>上述金融资产包括银行存款、股票、债券、基金份额、资产管理计划、银行理财产品、信托计划、保险产品、期货权益等。</p>
<h3 id="私募基金投资范围">私募基金投资范围</h3><p>包括买卖公开发行的股票、债券、基金份额，以及中国证监会规定的其他证券及其衍生品种。</p>
<h1 id="第5章_基金职业道德">第5章 基金职业道德</h1><h2 id="1，内蒙交易的定义">1，内蒙交易的定义</h2><p>内幕信息的构成三要素：</p>
<ol>
<li><p>来源可靠的信息。<br>来源不可靠、模棱两可的信息，即便对证券价格产生影响，也不构成内幕信息。</p>
</li>
<li><p>“重要”的信息。<br>即该信息对于证券价格的影响明确。如果该信息的披露会对证券价格产生影响或者属于理性投资者在做投资决策前希望知悉的，那么该信息就是“重要”的。</p>
</li>
<li><p>“非公开”的信息。<br>一般认为，在市场得到一个信息之前，这个信息就是“非公开”的。</p>
</li>
</ol>
<h1 id="第6章_投资管理基础">第6章 投资管理基础</h1><h2 id="1，资产负债表">1，资产负债表</h2><p>balance sheet 称为企业的“第一会计报表”。资产负债表报告了企业在某一时点的资产、负债和所有者权益的状况，报告时点通常为会计季末、半年末或者会计年末。</p>
<pre><code><span class="attribute">资产 </span>=<span class="string"> 负债 + 所有者权益</span>
</code></pre><h3 id="所有者权益">所有者权益</h3><p>又称股东权益或净资产，是指企业总资产中扣除负债所余下的部分，表示企业的资产净值，即在清偿各种债务以后，企业股东所拥有的资产价值。</p>
<p>包括以下四部分：</p>
<ul>
<li><p>股本，即按照面值计算的股本金；</p>
</li>
<li><p>资本公积，包括股票发行溢价、法定财产重估增值、接受捐赠资产、政府专项拨款转入等；</p>
</li>
<li><p>盈余公积，又分为法定盈余公积和任意盈余公积；</p>
</li>
<li><p>未分配利润，指企业留待以后年度分配的利润或待分配利润。</p>
</li>
</ul>
<h2 id="2，利润表">2，利润表</h2><p>income statement，亦称损益表，反映一定时期（如一个会计季度或会计年度）的总体经营成果，揭示企业财务状况发生变动的直接原因。</p>
<p>利润表由三部分构成：</p>
<ul>
<li><p>营业收入；</p>
</li>
<li><p>与营业收入相关的生产性费用、销售费用和其他费用；</p>
</li>
<li><p>利润</p>
</li>
</ul>
<p>在评价企业的整体业绩时，重点在于企业的净利润，即息税前利润（earning before interest and tax，EBIT）减去利息费用和税费。</p>
<h2 id="3，现金流量表">3，现金流量表</h2><p>cash flow statement，也叫账务状况变动表，所表达的是在特定会计期间内，企业的现金（包含现金等价物）的增减变动等情形。</p>
<p>现金流量表的基本结构分为三部分：</p>
<ul>
<li><p>经营活动产生的现金流量（cash flow from operation，CFO）</p>
</li>
<li><p>投资活动产生的现金流量（cash flow from investment，CFI）</p>
</li>
<li><p>筹资（也称融资）活动产生的现金流量（cash flow from financing，CFF）</p>
</li>
</ul>
<p>净现金流 （net cash flow，NCF）的公式</p>
<pre><code>NCF = <span class="built_in">CFO</span> + <span class="built_in">CFI</span> + <span class="built_in">CFF</span>
</code></pre><p>净现金流（NCF）为正或为负并非判断企业财务现金流量健康的唯一标准，关键要分析现金流量结构。</p>
<p>现金流量结构可以反映企业的不同发展阶段。在企业的起步、成长、成熟和衰退等不同周期阶段，企业现金流量模式不同，企业的现金流量也存在较大的差异性。</p>
<ul>
<li><p>初创企业：新兴的、快速成长的企业，由于需要不断进行资本投资，其经营活动现金流量可能为负，而筹资活动产生的现金流量可能为正。</p>
</li>
<li><p>发展中的企业：而随着企业的成长，依赖外部融资的程度会逐渐减低。典型成熟的企业会产生经营活动现金净流量，并将其部分或全部用于再投资，因此在财务特征上表现为经营活动现金净流量为正，投资活动现金流量为负。</p>
</li>
<li><p>成熟的企业：随着企业不断发展并迈入成熟阶段，则可能会减少外部融资，甚至为减少外部融资成本而更多使用现金偿还债务。</p>
</li>
</ul>
<h2 id="4，财务比率分析">4，财务比率分析</h2><p>财务比率分析是指用财务比率来描述企业财务状况、盈利能力以及流动性的分析方法。</p>
<h3 id="（一）流动性比率">（一）流动性比率</h3><p>流动性比率是用来衡量企业的短期偿债能力的比率，旨在分析短期内企业在不致使财务状况恶化的前提下，利用手中持有的流动资产偿还短期负债的能力大小。</p>
<p>流动资产主要包括现金及现金等价物、应收票据、应收账款和存货等几项资产；</p>
<p>流动负债是指企业要在一年或一个营业周期内偿付的各类短期债务，包括短期借款、应付票据、应付账款等。</p>
<h4 id="1，流动比率">1，流动比率</h4><pre><code><span class="attribute">流动比率 </span>=<span class="string"> 流动资产 / 流动负债</span>
</code></pre><p>对于短期债权人来说，流动比率越高越好，因为越高意味着他们回收债款的风险越低；但对于企业来说，因为流动资产的收益率较低，这部分比重过大势必影响到企业的经营获利或者投资盈利状况。</p>
<h4 id="2，速动比率">2，速动比率</h4><p>相对于其他流动资产来说，存货的流动性较差。因为存货的变现需要通过销售来实现。</p>
<pre><code><span class="attribute">速动比率 </span>=<span class="string"> （流动资产 - 存货）/ 流动负债</span>
</code></pre><p>相对于流动比率来说，速动比率对于短期偿债能力的衡量更加直观可信。一般来说，速动比率大于2时，企业才能维持较好的短期偿债能力和财务稳定状况。</p>
<h3 id="（二）财务杠杆比率">（二）财务杠杆比率</h3><p>财务杠杆比率衡量的是企业长期偿债能力。由于企业的长期负债与企业的资本结构即使用的财务杠杆有关，所以称为财务杠杆比率。</p>
<h4 id="1，资产负债率">1，资产负债率</h4><p>资产负债率是负债总额（包括短期负债和长期负债）占总资产的比例，即：</p>
<pre><code><span class="attribute">资产负债率</span>=<span class="string"> 负债 / 资产</span>
</code></pre><p>资产负债率在同行业企业的比较重有较大的参考价值。</p>
<h4 id="2，权益乘数和负债权益比">2，权益乘数和负债权益比</h4><pre><code><span class="attribute">权益乘数 </span>=<span class="string"> 资产 / 所有者权益

负债权益比 = 负债 / 所有者权益</span>
</code></pre><p>其中，权益乘数又称杠杆比率。</p>
<p>由于资产 = 负债 + 所有者权益，所以：</p>
<pre><code>权益乘数 = <span class="number">1</span> / ( <span class="number">1</span> - 资产负债率）

负债权益比 = 资产负债率 / ( <span class="number">1</span> - 资产负债率）
</code></pre><p>资产负债率、权益乘数和负债权益比三个比率其实是同一意思，由其中一个比率可以很容易计算出另外两个比率，并且都是数值越大代表财务杠杆比率越高，负债越重。</p>
<h4 id="3，利息倍数">3，利息倍数</h4><p>衡量企业对于长期债务利息保障程度的是利息倍数，其公式为：</p>
<pre><code><span class="attribute">利息倍数 </span>=<span class="string"> EBIT / 利息</span>
</code></pre><p>式中，EBIT是息税前利润。</p>
<p>为了维持正常的偿债能力，利息倍数至少应该为1，并且越高越好。若利息倍数过低，企业将面临亏损、偿债的稳定性与安全性下降的风险。</p>
<h3 id="（三）营运效率比率">（三）营运效率比率</h3><p>营运效率用来体现企业经营期间的资产从投入到产出的流转速度，可以反映企业资产的管理质量和利用效率。</p>
<h4 id="1，存货周转率">1，存货周转率</h4><p>存货周转率显示了企业在一年或者一个经营周期内存货的周转次数。其公式为：</p>
<pre><code><span class="attribute">存货周转率 </span>=<span class="string"> 年销售成本 / 年均存货</span>
</code></pre><p>年均存货通常是指年内期初存货和期末存货的算术平均数。例如假设企业年初存货是20000元，年末存货是5000元，那么年均存货就是(20000+5000)/2 = 12500元。</p>
<p>存货周转天数，其公式为：</p>
<pre><code>存货周转天数 = <span class="number">365</span>天 / 存货周转率
</code></pre><p>例如，如果一家企业的存货周转率是4，这意味着这家企业平均只要花 365 / 4 ≈ 92天就能将库存的存货全部销售出去。</p>
<h4 id="2，应收账款周转率">2，应收账款周转率</h4><p>存货周转率告诉我们存货的销售速度能有多块，而应收账款周转率则告诉我们能够以多快的速度回收销售收入。</p>
<p>应收账款周转率显示了企业在一年或一个经营周期内，应收账款的周转次数。其公式为：</p>
<pre><code>应收账款周转率 = 销售收入 / 年均应收账款

应收账款周转天数 = <span class="number">365</span>天 / 应收账款周转率
</code></pre><h4 id="3，总资产周转率">3，总资产周转率</h4><p>总资产周转率衡量的是一家企业所有资产的使用效率，它的计算公式是：</p>
<pre><code><span class="attribute">总资产周转率 </span>=<span class="string"> 年销售收入 / 年均总资产</span>
</code></pre><p>这里的年均总资产也是企业年内期初资产和期末资产的算术平均数。总资产周转率越大，说明企业的销售能力越强，资产利用效率越高。</p>
<h3 id="（四）盈利能力比率">（四）盈利能力比率</h3><p>评价企业盈利能力的比率有很多，其中最重要的有三种：销售利润率（ROS）、资产收益率（ROA）、净资产收益率（ROE）。这三种比率都使用的是企业的年度净利润。</p>
<h4 id="1，销售利润率">1，销售利润率</h4><p>销售利润率是指每单位销售收入所产生的利润，其计算公式为：</p>
<pre><code><span class="attribute">销售利润率 </span>=<span class="string"> 净利润 / 销售收入</span>
</code></pre><h4 id="2，资产收益率">2，资产收益率</h4><p>资产收益率计算的是每单位资产能带来的利润，其计算公式为：</p>
<pre><code><span class="attribute">资产收益率 </span>=<span class="string"> 净利润 / 总资产</span>
</code></pre><p>资产收益率是应用最为广泛的衡量企业盈利能力的指标之一。资产收益率高，表明企业有较强的利用资产创造利润的能力，企业在增加收入和节约资金使用等方面取得了良好的效果。</p>
<p>资产收益率的特点是，它所考虑的净利润仅仅是股东可以获得的利润，而资产却是包括股东资产和债权人资产在内的总资产。</p>
<h4 id="3，净资产收益率">3，净资产收益率</h4><p>净资产收益率也称权益报酬率，强调每单位的所有者权益能够带来的利润，其计算公式为：</p>
<pre><code><span class="attribute">净资产收益率 </span>=<span class="string"> 净利润 / 所有者权益</span>
</code></pre><p>由于现代企业最重要的经营目标就是最大化股东财富，因而净资产收益率是衡量企业最大化股东财富能力的比率。</p>
<h2 id="5，杜邦分析法">5，杜邦分析法</h2><p>杜邦分析法（DuPont Analysis）是一种用来评价企业盈利能力和股东权益汇报水平的方法，它利用主要的财务比率之间的关系来综合评价企业的财务状况。</p>
<p>杜邦分析法的基本思想是将企业净资产收益率逐级分解为多项财务比率乘积，从而有助于深入分析比较企业经营业绩。</p>
<pre><code>净资产收益率 = 净利润 / 所有者权益

            =<span class="ruby">  (净利润 / 总资产) * (总资产 / 所有者权益)
</span>
            =<span class="ruby"> 资产收益率 * 权益乘数
</span>
资产收益率 = 净利润 / 总资产

    =<span class="ruby"> (净利润 / 销售收入) * (销售收入 / 总资产)
</span>
    =<span class="ruby"> 销售利润率 * 总资产周转率</span>
</code></pre><p><strong>杜邦恒等式：</strong></p>
<pre><code>净资产收益率 = 销售利润率 <span class="keyword">*</span> 总资产周转率 <span class="keyword">*</span> 权益乘数
</code></pre><p>通过杜邦恒等式，我们可以看到一家企业的盈利能力综合取决于企业的销售利润率、使用资产的效率和企业的财务杠杆。</p>
<h2 id="6，终值、现值和贴现">6，终值、现值和贴现</h2><h3 id="终值">终值</h3><p>已知期初投入的现值为PV，求将来值即第n期期末的<strong>终值</strong>PV，其计算公式为：</p>
<p>$$ FV = PV * (1+i)^n $$</p>
<p>i表示年利率，</p>
<h3 id="现值">现值</h3><p>是指将来货币金额的现在价值。</p>
<p>$$ PV = \dfrac{FV}{(1+i)^n} $$</p>
<h3 id="贴现">贴现</h3><p>将未来某时点资金的价值折算为现在时点的价值称为贴现。在现值计算中，利率i也被称为贴现率。</p>
<p>例如，某公司发行了面值为1000元的5年期零息债券，现在的市场利率为8%，那么该债券的现值为：1000 / (1+ 8%)^5 = 680.58 (元)</p>
<h2 id="7，名义利率与实际利率">7，名义利率与实际利率</h2><p>实际利率是指在物价不变且购买力不变的情况下的利率，或者是指当物价有变化，扣除通货膨胀补偿以后的利息率。</p>
<p>名义利率是指包含对通货膨胀补偿的利率，当物价不断上涨时，名义利率比实际利率高。</p>
<h3 id="费雪方程式">费雪方程式</h3><p><img src="http://www.forkosh.com/mathtex.cgi?i_{r} = i_{n} - p"></p>
<p>式中：in为名义利率， ir 为实际利率，p为通货膨胀率</p>
<h2 id="8，单利与复利">8，单利与复利</h2><p>$$ FV = PV * (1+i)^n $$</p>
<p>(1+i)^n称为复利终值系数或1元的复利终值，用符号(FV, i, n)表示。例如(FV, 6%, 3)表示利率为6%，3期复利终值系数。</p>
<p>$$ PV = \dfrac{FV}{(1+i)^n} $$</p>
<p>(1+i)^(-n)称为复利现值系数或1元的复利现值，用符号(PV, i, n)表示。</p>
<p>利用复利现值系数可以计算按揭贷款的每期偿还数额。例如，以等额本息法偿还本金为100万元，利率为7%的5年期住房贷款。假设每年末需要偿还的本金利息总额为M元，则有：</p>
<p><img src="http://www.forkosh.com/mathtex.cgi?1 000 000 = M * (PV, 7\%, 1) + M * (PV, 7\%, 2) + M * (PV, 7\%, 3) + M * (PV, 7\%, 4) + M * (PV, 7\%, 5) = M * (1+7\%)^{-1}  + M * (1+7\%)^{-2} + M * (1+7\%)^{-3} + M * (1+7\%)^{-4} + M * (1+7\%)^{-5}"></p>
<p>计算可知，M = 243890.69</p>
<pre><code>In [<span class="number">16</span>]: <span class="number">1000000</span>/(<span class="number">1</span>/<span class="number">1.07</span>+<span class="number">1</span>/<span class="number">1.07</span>**<span class="number">2</span>+<span class="number">1</span>/<span class="number">1.07</span>**<span class="number">3</span>+<span class="number">1</span>/<span class="number">1.07</span>**<span class="number">4</span>+<span class="number">1</span>/<span class="number">1.07</span>**<span class="number">5</span>)

Out[<span class="number">16</span>]: <span class="number">243890.6944413741</span>
</code></pre><h2 id="9，即期利率与远期利率">9，即期利率与远期利率</h2><h3 id="即期利率(spot_rate)">即期利率(spot rate)</h3><p>是金融市场中的基本利率，常用St表示，是指已设定到期日的零息票债券的到期收益率。</p>
<h3 id="贴现因子">贴现因子</h3><p>$$ d<em>{t} = \dfrac{1}{(1+s</em>{t})^t} $$</p>
<p>其中，St为即期利率。</p>
<h3 id="远期利率">远期利率</h3><p>foward rate指的是资金的远期价格，它是指隐含在给定的即期利率中从未来的某一时点到另一时点的利率水平。具体表示为未来两个日期间借入货币的利率，也可以表示投资者在未来特定日期购买的零息票债券的到期收益率。</p>
<p>例如，1年和2年期的即期利率分别为S1=7%和S2=8%，求远期利率</p>
<p>根据无套利原则，存在</p>
<p>$$ (1+s<em>{2})^2 = (1+s</em>{1})(1+f) $$</p>
<p>$$ f = \dfrac{(1+s<em>{2})^2}{(1+s</em>{1})}-1 $$</p>
<p>f = 1.08*1.08/1.07 - 1 = 9.01%</p>
<h2 id="10，随机变量的统计量">10，随机变量的统计量</h2><h3 id="期望（均值）">期望（均值）</h3><p>随机变量X的期望（或称均值，记做 E(X) ）衡量了X取值的平均水平；它是对X所有可能取值按照其发生概率大小加权后得到的平均值。</p>
<p>$$ E(X) = \sum<em>{i=1}^{n}p</em>{i}x<em>{i} = p</em>{1}x<em>{1} + p</em>{2}x<em>{2} + … + p</em>{n}x_{n}  $$</p>
<p>在X的分布未知时，我们用抽取样本X1, … , Xn的算术平均数（也称样本均值）</p>
<p>$$ \overline X =\dfrac{1}{n}\sum<em>{i=1}^{n}X</em>{i} $$</p>
<p>作为E(X)的估计值。</p>
<h3 id="方差与标准差">方差与标准差</h3><p>对于投资收益率r，我们用方差<img src="http://www.forkosh.com/mathtex.cgi?\sigma^2">或者标准差<img src="http://www.forkosh.com/mathtex.cgi?\sigma">来衡量它偏离期望值的程度。</p>
<p>其中，</p>
<p>$$ \sigma^2 = E[(r - Er)^2] $$</p>
<p>它的数值越大，表示收益率r偏离期望收益率<img src="http://www.forkosh.com/mathtex.cgi?Er=\overline r">的程度越大，反之亦然。</p>
<h1 id="第7章_权益投资">第7章 权益投资</h1><h2 id="1，权益资本">1，权益资本</h2><p>两种最主要的权益证券是普通股和优先股</p>
<h3 id="普通股">普通股</h3><p>common shares 是股份有限公司发行的一种基本股票，代表公司股份中的所有权份额，其持有者享有股东的基本权利和义务。</p>
<h3 id="优先股">优先股</h3><p>preferred shares和普通股一样代表对公司的所有权，它的优先权主要指：持有人分得公司利润的顺序先于普通股，在公司解散或破产清偿时先于普通股获得剩余财产。优先股的股息率往往是事先规定好的、固定的，它不因公司经营业绩的好坏而有所变动。</p>
<h3 id="普通股和优先股的风险收益比较">普通股和优先股的风险收益比较</h3><p>优先股在分配股利和清算时剩余财产的索取权优先于普通股，因而风险较低。此外，固定的股息收益也降低了优先股的风险。然而，优先股的收益也因此被限定为固定的股息收益，当公司盈利多时，相比普通股而言，优先股获利更少。</p>
<p>普通股股东享有对剩余利润的要求权意味着其有较高的潜在收益率。当公司运营良好时，普通股股东可以获得丰厚的收益，而优先股股东只能取得固定的股息。因此，相比于优先股，普通股具有较高风险和较高收益的特征。</p>
<h2 id="2，莫迪利亚尼-米勒定理（MM定理）">2，莫迪利亚尼-米勒定理（MM定理）</h2><p>在不考虑税、破产成本、信息不对称并且假设在有效市场里面，企业价值不会因为企业融资方式改变而改变。</p>
<h2 id="修正的MM定理">修正的MM定理</h2><p>企业可以运用避税政策，通过改变企业的资本结构来改变企业的市场价值，即企业发行债券或获取贷款越多，企业市场价值越大。</p>
<h2 id="均衡理论">均衡理论</h2><p>认为随着企业债务增加而提高的经营风险和可能产生的破产成本，会增加企业的额外成本，而最佳的资本结构应当是负债和所有者权益之间的一个均衡点，这一均衡点D*就是最佳负债比率。</p>
<h2 id="3，股票的价值">3，股票的价值</h2><h3 id="(1)_股票的票面价值（face_value）">(1) 股票的票面价值（face value）</h3><p>又称面值，即在股票票面上标明的金额。股票的票面价值在初次发行时有一定参考意义。</p>
<h3 id="(2)_股票的账面价值（book_value）">(2) 股票的账面价值（book value）</h3><p>又称股票净值或每股净资产，是每股股票所代表的实际资产的价值。</p>
<h3 id="(3)_股票的清算价值（liquidation_value）">(3) 股票的清算价值（liquidation value）</h3><p>是公司清算时每一股份所代表的实际价值。</p>
<h3 id="(4)_股票的内在价值（intrinsic_value）">(4) 股票的内在价值（intrinsic value）</h3><p>即理论价值，是指股票未来收益的现值。股票的内在价值决定股票的市场价格，股票的市场价格总是围绕其内在价值波动。</p>
<h2 id="4，存托凭证">4，存托凭证</h2><p>存托凭证（depository receipt）是指在一国证券市场上流通的代表外国公司有价证券的可转让凭证。存托凭证一般代表外国公司股票。</p>
<p>全球存托凭证（global depository receipts，GDSs）</p>
<p>美国存托凭证（American depository receipts, ADSs)是以美元计价且在美国证券市场上交易的存托凭证。ADR是最主要的存托凭证，其流通量最大。</p>
<h2 id="5，可转换债券">5，可转换债券</h2><p>是指在一段时期内，持有者有权按照约定的转换价格（conversion price）或转换比率（conversion ratio）将其转换成普通股股票的公司债券。</p>
<pre><code><span class="attribute">转换价格 </span>=<span class="string"> 可转换债券价值 /  转换比例</span>
</code></pre><h2 id="6，权证">6，权证</h2><p>权证（warrant）是指标的证券发行人或其以外的第三人发行的，约定在规定期间内或特定到期日，持有人有权按约定价格向发行人购买或出售标的证券，或以现金结算方式收取结算差价的有价证券。</p>
<p>按基础资产的来源分类，权证可分为认股权证和备兑权证。</p>
<ul>
<li><p>认股权证是股份公司发行的，行权时上市公司增发新股售予认股权证的持有人。</p>
</li>
<li><p>备兑权证是由投资银行发行的，行权时备兑权证持有者认兑的是市场上已流通的股票而非增发的，上市公司股本不变。</p>
</li>
</ul>
<p>按照持有人权利的性质分类，权证可分为认购权证和认沽权证。</p>
<ul>
<li><p>认购权证近似于看涨期权，行权时其持有人可按照约定的价格购买约定数量的标的资产。</p>
</li>
<li><p>认沽权证近似于看跌期权，行权时其持有人可按照约定的价格卖出约定数量的标的资产。</p>
</li>
</ul>
<p>按行权时间分类：</p>
<ul>
<li><p>美式权证可在权证失效日之前任何交易日行权；</p>
</li>
<li><p>欧式权证仅可在失效日当日行权；</p>
</li>
<li><p>百慕大式权证可在失效日之前一段规定时间内行权。</p>
</li>
</ul>
<h2 id="7，权益类证券投资收益">7，权益类证券投资收益</h2><pre><code><span class="attribute">风险资产期望收益率 </span>=<span class="string"> 无风险资产收益率 + 风险溢价</span>
</code></pre><p>其中，无风险资产收益率即无风险利率（risk-free interest rate）。</p>
<h2 id="8，股票基本面分析">8，股票基本面分析</h2><p>三步估价法，宏观 —行业—个股，“自上而下”的层次分析法；</p>
<h3 id="（一）宏观经济分析">（一）宏观经济分析</h3><p>宏观经济指标：</p>
<ul>
<li><p>国内生产总值（GDP）</p>
<p>  GDP = C + I + （X - M）+ G</p>
</li>
</ul>
<p>式中，C代表消费；I代表投资；X-M代表净出口；G代表政府支出。</p>
<ul>
<li>通货膨胀</li>
</ul>
<p>居民消费价格指数、生产者物价指数、商品价格指数等。</p>
<ul>
<li><p>利率</p>
</li>
<li><p>汇率</p>
</li>
<li><p>预算赤字</p>
</li>
</ul>
<p>政府的预算赤字是政府支出和政府收入之间的差额。</p>
<ul>
<li><p>失业率</p>
</li>
<li><p>采购经理指数（purchasing managers’ index， PMI）</p>
</li>
</ul>
<h3 id="（二）行业分析">（二）行业分析</h3><p>任何一个行业都要经理一个生命周期：</p>
<ul>
<li><p>初创期</p>
</li>
<li><p>成长期</p>
</li>
<li><p>平台期（成熟期）</p>
</li>
<li><p>衰退期</p>
</li>
</ul>
<h3 id="（三）公司内在价值与市场价格">（三）公司内在价值与市场价格</h3><p>股票的内在价值即理论价值，是指股票未来收益的现值，由公司资产、收益、股息等因素所决定。</p>
<p>证券的市场价格是由市场供求关系所决定的，市场价格不仅受到资产内在价值与未来价值因素的影响，还可能受到市场情绪、技术、投机等因素的影响。</p>
<h2 id="9，超额收益贴现模型：经济附加值（EVA）模型">9，超额收益贴现模型：经济附加值（EVA）模型</h2><p>经济附加值（economic value added， EVA）指标源于企业经营绩效考核的目的。</p>
<p>经济附加值等于公司税后净营业利润减去全部资本成本（股本成本与债务成本）后的净值。计算公式为：</p>
<pre><code><span class="label">EVA</span> = <span class="keyword">NOPAT </span>- 资本成本
</code></pre><p>式中：NOPAT表示税后经营利润，或称息前税后利润，是指息税前利润EBIT扣除经营所得税；资本成本等于WACC乘以实际投入资本总额；WACC表示加权平均资本成本。</p>
<h1 id="第8章_固定收益投资">第8章 固定收益投资</h1><h2 id="1，债券市场">1，债券市场</h2><p>债券（bond），通常又称固定收益证券（fixed-income securities），因为这类金融工具能够提供固定数额或根据固定公式计算出的现金流。</p>
<p>货币市场证券主要是短期性、高流动性证券，例如银行拆借市场、票据承兑市场、回购市场等交易的债券；而固定收益资本市场中交易的则是长期债券。</p>
<h2 id="2，国债收益率曲线">2，国债收益率曲线</h2><p>国债收益率曲线是反映远期利率的有效途径，它的水平和斜率反映了经济主体对未来通货膨胀的预期和对未来基本的经济形势的判断。其实市场无风险利率最合适的替代，从而为其他债券和金融资产以及投资项目提供定价的基准。</p>
<h2 id="3，按债券持有人收益方式分类">3，按债券持有人收益方式分类</h2><ul>
<li><p>固定利率债券<br>固定收益债券（fixed-rate bond）是由政府和企业发行的主要债券种类，有固定的到期日，并在偿还期内有固定的票面利率和不变的面值。</p>
</li>
<li><p>浮动利率债券<br>浮动利率债券（floating-rate bond）和固定利率债券的主要不同是其票面利率不是固定不变的，而通常与一个基准利率挂钩，在其基础上加上利差（可正可负）以反映不同债券发行人的信用。浮动利率可表达为：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">浮动利率 </span>=<span class="string"> 基准利率 + 利差</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>基准利率，在国际金融市场上通常采用伦敦银行间同业拆解利率（Libor），在我国，上海银行间同业拆借利率（Shibor）是被广泛采纳的货币市场基准利率。<br>国际惯例将利差用基点（basis point）表示，1个基点（1bps）等于0.01%。</p>
<ul>
<li>零息债券<br>零息债券（zero-coupon bond）和固定利率债券一样有一定的偿还期限，但在期间不支付利息，而在到期日一次性支付利息和本金，一般其值为债券面值。因此，零息债券以低于面值的价格发行，到期日支付的面值和发行时价格的差额即为投资者的收益。</li>
</ul>
<h2 id="4，按计息与付息方式分类">4，按计息与付息方式分类</h2><p>债券可分为息票债券和贴现债券。</p>
<ol>
<li><p>息票债券是指债券发行时规定，在债券存续期内，在约定的时间以约定的利率按期向债券持有人支付利息的中、长期债券。</p>
</li>
<li><p>贴现债券则是无息票债券或零息债券，这种债券在发行时不规定利率，券面也不附息票，发行人以低于债券面额的价格出售债券，即这家发行，债券到期时发行人按债券面额兑付。</p>
</li>
</ol>
<h2 id="5，按嵌入的条款分类">5，按嵌入的条款分类</h2><ol>
<li><p>可赎回债券<br>可赎回债券（callable bond）为发行人提供在债券到期前的特定时段以事先约定价格买回债券的权力。约定的价格称为赎回价格（call price）</p>
</li>
<li><p>可回售债券<br>可回售债券（puttable bond）为债券持有者提供在债券到期前的特定时段以事先约定价格将债券回售给发行人的权力，约定的价格成为回售价格（put price）</p>
</li>
<li><p>可转换债券<br>可转换债券是指在一段时间后，持有者有权按约定的转换价格或转换比率将公司债券转换为普通股票。</p>
</li>
<li><p>通货膨胀联结债券</p>
</li>
<li><p>结构化债券</p>
</li>
</ol>
<p>资产证券化（asset securitization）指以其他债券组成的资产池尾支持，构建新的债券产品形式。此类新构建的债券成为结构化债券，主要是住房抵押贷款支持证券和资产支持证券。</p>
<h2 id="6，债券违约时的受偿顺序">6，债券违约时的受偿顺序</h2><p>有保证债券 &gt; 优先无保证债券 &gt; 优先次级债券 &gt; 次级债券 &gt; 劣后次级债券</p>
<h2 id="7，投资债券的风险">7，投资债券的风险</h2><h3 id="信用风险">信用风险</h3><p>信用风险（credit risk）又叫违约风险（default risk），是指债券发行人未按照契约的规定支付债券的本金和利息，给债券投资者带来损失的可能性。</p>
<p>国际上知名的独立信用评级机构有三家：</p>
<ul>
<li><p>穆迪投资者服务公司（Moody’s Investor Service）</p>
</li>
<li><p>标准·普尔评级服务公司（Standard &amp; Poor’s）</p>
</li>
<li><p>惠誉国际信用评级有限公司（Fitch Investor Service）</p>
</li>
</ul>
<p>国内主要的债券评级机构包括：</p>
<ul>
<li><p>大公国际资信评估有限公司</p>
</li>
<li><p>中诚信国际信用评级有限公司</p>
</li>
<li><p>联合资产评估有限公司</p>
</li>
<li><p>上海新世纪资信评估投资服务有限公司</p>
</li>
<li><p>中债资信评估有限责任公司</p>
</li>
</ul>
<h3 id="利率风险">利率风险</h3><p>利率风险（interest rate risk）是指利率变动引起债券价格波动的风险。</p>
<p>债券的价格与利率呈反向变动关系：利率上升时，债券价格下降；利率下降时，债券价格上升。</p>
<h3 id="通胀风险">通胀风险</h3><p>所有种类的债券都面临通胀风险（inflation risk），因为利息和本金都是不随通胀水平变化的名义金额。</p>
<h3 id="流动性风险">流动性风险</h3><p>是指债券投资者将手中的债券变现的能力。</p>
<h3 id="再投资风险">再投资风险</h3><p>指在市场利率下行的环境中，附息债券收回的利息或者提前于到期日收回的本金只能以低于原债券到期收益率的利率水平再投资于相同属性的债券，而产生的风险。</p>
<h3 id="提前赎回风险">提前赎回风险</h3><p>又称为回购风险，是指债券发行者在债券到期日前赎回有提前赎回条款的债券所带来的风险。</p>
<h2 id="8，中国债券交易市场体系">8，中国债券交易市场体系</h2><p>从20世纪80年代开始逐步发展起来的</p>
<ol>
<li><p>以柜台市场为主（1988 - 1991年）</p>
</li>
<li><p>以交易所市场为主（1992 - 2000年）</p>
</li>
<li><p>以银行间市场为主（2001年至今）</p>
</li>
</ol>
<h2 id="9，债券的估值方法">9，债券的估值方法</h2><h3 id="1，零息债券估值法">1，零息债券估值法</h3><p>由于面值是投资者未来唯一的现金流，所有贴现债务的内在价值由一下公式决定：</p>
<p>$$ V = M\dfrac{1}{(1+r)^t} $$</p>
<p>式中，V表示贴现债券的内在价值；M表示面值；r表示市场利率；t表示债券到期时间。</p>
<p>由于多数零息债券期限小于一年，因此上述贴现公式应简单调整为：</p>
<p>$$ V = M(1-\dfrac{t}{360}r) $$</p>
<p>某种贴现式国债面额为100元，贴现率为3.82%，到期时间为90天，则该国债的内在价值为100<em>(1-90/360 </em>3.82%) = 99.045 （元）</p>
<h3 id="2，固定利率债券估值法">2，固定利率债券估值法</h3><p>固定利率债券是一种按照票面金额计算利息，票面上附有（也可不附有）作为定期支付利息凭证的期票的债券。投资者未来的现金流包括两部分：本金和利息。其内在价值公式如下：</p>
<p>$$ V = \dfrac{C}{1+r} +  \dfrac{C}{(1+r)^2} + … + \dfrac{C}{(1+r)^n} + \dfrac{M}{(1+r)^2} $$</p>
<p>式中，C表示每期支付的利息；V表示贴现债券的内在价值；M表示面值；r表示市场利率；n表示债券到期时间。</p>
<p>例：</p>
<p>某种附息国债面额为100元，票面利率为5.21%，市场利率为4.89%，期限为3年，每年付息1次，则该国债的内在价值为：</p>
<p>$$ V = \dfrac{5.21}{1+0.0489} +  \dfrac{5.21}{(1+0.0489)^2}+  \dfrac{5.21}{(1+0.0489)^3} + \dfrac{100}{(1+0.0489)^3}  = 100.873 （元）$$</p>
<h3 id="3，统一公债估值法">3，统一公债估值法</h3><p>统一公债是一种没有到期日的特殊债券。在现代企业中，优先股的股东可以无期限地获得固定股息，因此，也相当于一种统一公债。其内在价值计算公式如下：</p>
<p>$$ V = \dfrac{C}{1+r} +  \dfrac{C}{(1+r)^2} + … +  \dfrac{C}{(1+r)^n} = \dfrac{C}{r} $$</p>
<h2 id="10，当期收益率、到期收益率与债券价格的关系">10，当期收益率、到期收益率与债券价格的关系</h2><h3 id="当期收益率">当期收益率</h3><p>current yield，又称当前收益率，是债券的年利息收入与当前的债券市场价格的比率。其计算公式为：</p>
<p>$$ I = \dfrac{C}{P} $$</p>
<p>式中：I表示当期收益率，C表示年息票利息，P表示债券市场价格。</p>
<p>当期收益率没有考虑债券投资所获得的资本利得或损失。</p>
<h3 id="到期收益率">到期收益率</h3><p>yield to maturity， YTM，又称内部收益率，是可以使投资购买债券获得的未来现金流的现值等于债券当前市价的贴现率。</p>
<p>到期收益率隐含两个重要假设：</p>
<ul>
<li><p>投资者持有至到期</p>
</li>
<li><p>利息再投资收益率不变</p>
</li>
</ul>
<p>到期收益率一般用y表示，债券市场价格和到期收益率的关系式为：</p>
<p>$$ P = \sum_{t=1}^{n}\dfrac{C}{(1+y)^t} + M(\dfrac{1}{1+y})^n $$</p>
<p>式中：P表示债券市场价格；C表示每期支付的利息，n表示时期数；M表示债券面值。</p>
<p>例：</p>
<p>票面金额为100元的2年期债券，第一年支付利息6元，第二年支付利息6元，当前市场价格为95元，则该债券的到期收益率和当前价格之间的关系可表达为：</p>
<pre><code><span class="number">95</span> = <span class="number">6</span>/(<span class="number">1</span>+y) + <span class="number">106</span>/(<span class="number">1</span>+y)^<span class="number">2</span>
</code></pre><p>求解得y=8.836%</p>
<h2 id="11，信用利差">11，信用利差</h2><p>信用利差（credit spread），是指除了信用评级不同外，其余条件全部相同（包括但不限于期限、嵌入条款等）两种债券收益率的差额。</p>
<h2 id="12，债券的久期和凸度">12，债券的久期和凸度</h2><p>利率变化是影响债券价格的主要因素之一，久期和凸度是衡量债券价格随利率变化特性的两个重要指标。</p>
<h3 id="久期">久期</h3><p>麦考利久期（duration），又称为存续期，指的是债券的平均到期时间，它是从现值角度度量了债券现金流的加权平均年限，即债券投资者收回其全部本金和利息的平均时间。</p>
<h3 id="凸性">凸性</h3><p>凸性是债券价格与到期收益率之间的关系用弯曲程度的表达方式。</p>
<h2 id="13，货币市场工具的特点">13，货币市场工具的特点</h2><ol>
<li><p>均是债务契约</p>
</li>
<li><p>期限在1年以内（含1年）</p>
</li>
<li><p>流动性高</p>
</li>
<li><p>大宗交易，主要由机构投资者参与，个人投资者很少有机会参与买卖</p>
</li>
<li><p>本机安全性高，风险较低</p>
</li>
</ol>
<h3 id="常用的货币市场工具">常用的货币市场工具</h3><h4 id="（一）银行定期存款">（一）银行定期存款</h4><h4 id="（二）短期回购协议">（二）短期回购协议</h4><p>回购协议是指资金需求方在出售证券的同时与证券的购买方约定在一定期限后按约定价格购回所卖证券的交易行为。</p>
<p>证券回购协议的主要功能有三个：</p>
<ol>
<li><p>中国人民银行以此为工具进行公开市场操作，方便中央银行投放（收回）基础货币，形成合理的短期利率；</p>
</li>
<li><p>为商业银行的流动性和资产结构的管理提供了必要的工具；</p>
</li>
<li><p>各类非银行金融机构可以通过证券回购协议实现套期保值、头寸管理、资产管理、增值等目的。</p>
</li>
</ol>
<p>回购协议是一种证券抵押贷款，以国债为主。证券的出售方为正回购方，证券的购买方为逆回购方。</p>
<h4 id="（三）中央银行票据">（三）中央银行票据</h4><p>是由中央银行发行的用于调节商业银行超额准备金的短期债务凭证，简称央行票据或央票。</p>
<h4 id="（四）短期政府债券">（四）短期政府债券</h4><p>期限在1年及1年以内的债务凭证。三个特点：</p>
<ul>
<li><p>违约风险小</p>
</li>
<li><p>流动性强</p>
</li>
<li><p>利息免税</p>
</li>
</ul>
<h4 id="（五）短期融资券">（五）短期融资券</h4><p>是境内具有法人资格的非金融企业发行的，仅在银行间债券市场上流通的短期债务工具。</p>
<h4 id="（六）_中期票据">（六） 中期票据</h4><p>中期票据的期限一般为1年以上、10年以下，我国的中期票据的期限通常为3年或5年。</p>
<p>中期票据采用注册发行，最大注册额度不超过企业净资产的40%。</p>
<h4 id="（七）证监会、中国人民银行认可的其他具有良好流动性的货币市场工具。">（七）证监会、中国人民银行认可的其他具有良好流动性的货币市场工具。</h4><ol>
<li>同业拆借<br>同业拆借是指金融机构之间以货币借贷方式进行短期资金融通的行为。</li>
</ol>
<p>上海银行间同业拆借利率（SHIBOR）</p>
<p>同业拆借的利息是按日结算的。</p>
<ol>
<li><p>银行承兑汇票<br>银行承兑汇票是由在承兑银行开立存款账户的存款人出票，向开户银行申请并经银行审查同意承兑的，保证在指定日期无条件支付确定的金额给收款人或持票人的票据。</p>
</li>
<li><p>商业票据<br>是指发行主体为满足流动资金的需求所发行的期限为2天至270天的、可流通转让的债务工具。</p>
</li>
<li><p>大额可转让定期存单</p>
</li>
<li><p>同业存单<br>是存款类金融机构在全国银行间市场上发行的记账式定期存款凭证。 </p>
</li>
</ol>
<h1 id="第9章_衍生工具">第9章 衍生工具</h1><h2 id="1，衍生工具的定义">1，衍生工具的定义</h2><p>衍生工具（derivatives），是指一种衍生类合约，其价值取决于一种或多种基础资产。这些基础资产通常被称作合约标的资产（underlying）。合约标的可以是股票、债券、货币等金融资产，也可以是黄金、原油等大宗商品或贵金属。</p>
<p>衍生工具的特点：</p>
<ol>
<li><p>跨期性</p>
</li>
<li><p>杠杆性</p>
</li>
<li><p>联动性</p>
</li>
<li><p>不确定性或高风险性</p>
</li>
</ol>
<h2 id="2，按合约特点分类">2，按合约特点分类</h2><ol>
<li><p>远期合约<br>forward contract 是指交易双发约定在未来的某一确定的时间，按约定的价格买入或卖出一定数量的某种合约标的资产的合约。是非标准化的合约。</p>
</li>
<li><p>期货合约<br>futures contract，相比于远期合约，期货合约是标准化合约。<br>2006年9月，中国金融期货交易所正式成立。2010年4月，推出沪深300指数期货。</p>
</li>
<li><p>期权合约<br>option contract，又称作选择权合约。</p>
</li>
<li><p>互换合约<br>swap contract。</p>
</li>
<li><p>结构化金融衍生工具。</p>
</li>
</ol>
<h2 id="3，期货市场的交易制度">3，期货市场的交易制度</h2><ol>
<li><p>保证金制度<br>比例通常在5%~10%</p>
</li>
<li><p>盯市制度<br>盯市（marking to market）是期货交易最大的特征，又称为“逐日结算”，即在每个营业日的交易停止以后，成交的经纪人之间不直接进行现金结算，而是将所有清算事务都交由清算机构办理。</p>
</li>
<li><p>对冲平仓制度</p>
</li>
<li><p>交割制度</p>
</li>
</ol>
<h2 id="4，期权合约">4，期权合约</h2><p>期权合约的要素</p>
<ol>
<li><p>标的资产</p>
</li>
<li><p>期权的买方<br>买方为买入期权的一方，即支付费用从而获得权利的一方，也称期权的多头。</p>
</li>
<li><p>期权的卖方<br>卖方为卖出期权的一方，即获得费用因而承担在规定的时间内履行该期权合约义务的一方，也称期权的空头。</p>
</li>
<li><p>执行价格<br>又称协议价格</p>
</li>
<li><p>期权费</p>
</li>
<li><p>通知日</p>
</li>
<li><p>到期日</p>
</li>
</ol>
<h3 id="按期权买方执行期权的时限分类">按期权买方执行期权的时限分类</h3><ul>
<li><p>欧式期权，指期权的而买房只有值期权到期日才能执行期权，既不能提取也不能推迟。</p>
</li>
<li><p>美式期权，允许期权买方在期权到期前的任何时间执行期权。</p>
</li>
</ul>
<h3 id="按期权买方的权利分类">按期权买方的权利分类</h3><ul>
<li><p>看涨期权</p>
</li>
<li><p>看跌期权</p>
</li>
</ul>
<h3 id="影响期权价格的因素">影响期权价格的因素</h3><ol>
<li><p>合约标的资产的市场价格与期权的执行价格</p>
</li>
<li><p>期权的有效期</p>
</li>
<li><p>无风险利率水平</p>
</li>
<li><p>标的资产价格的波动率</p>
</li>
<li><p>合约标的资产的分红</p>
</li>
</ol>
<p>表：影响期权价格的因素及其影响方向</p>
<table>
<thead>
<tr>
<th>影响因素</th>
<th>看涨期权</th>
<th>看跌期权</th>
</tr>
</thead>
<tbody>
<tr>
<td>合约标的资产的市场价格⬆️</td>
<td>⬆️</td>
<td>⬇️</td>
</tr>
<tr>
<td>期权的执行价格⬆️</td>
<td>⬇️</td>
<td>⬆️</td>
</tr>
<tr>
<td>期权的有效期⬆️</td>
<td>⬆️</td>
<td>⬆️</td>
</tr>
<tr>
<td>标的资产价格的波动率 ⬆️</td>
<td>⬆️</td>
<td>⬆️</td>
</tr>
<tr>
<td>无风险利率水平⬆️</td>
<td>⬆️</td>
<td>⬇️</td>
</tr>
<tr>
<td>合约标的的资产分红⬆️</td>
<td>⬇️</td>
<td>⬆️</td>
</tr>
</tbody>
</table>
<h2 id="5，互换合约">5，互换合约</h2><h3 id="（一）利率互换">（一）利率互换</h3><p>interest swap，是指互换合约双方同意在约定期限内按不同的利息计算方式向对方支付由币种相同的名义本金额所确定的利息。</p>
<p>双方进行利率互换的主要原因是双方在固定利率和浮动利率市场上分别具有比较优势。</p>
<h3 id="（二）货币互换">（二）货币互换</h3><h2 id="6，远期合约、期货合约、期权合约和互换合约的区别">6，远期合约、期货合约、期权合约和互换合约的区别</h2><h3 id="（1）交易场所与合约">（1）交易场所与合约</h3><p>期货合约只在交易所交易，期权合约大部分在交易所交易，远期合约和互换合约通常在场外交易，采用非标准形式进行。</p>
<h3 id="（2）损益特性">（2）损益特性</h3><p>远期合约、期货合约和大部分互换合约都包括买卖双方在未来应尽的义务，称为双边合约</p>
<p>而期权合约和信用违约互换合约只有一方在未来有义务，称为单边合约。</p>
<h3 id="（3）信用风险">（3）信用风险</h3><h3 id="（4）执行方式">（4）执行方式</h3><h3 id="（5）杠杆">（5）杠杆</h3><p>期货、期权有杠杆，远期合约和互换合约通常没有杠杆效应。</p>
<h1 id="第10章_另类投资">第10章 另类投资</h1><p>另类投资（alternative investment）是指传统公开市场交易的权益资产、固定收益类资产和货币类资产之外的投资类型。通常包括私募股权、房产与商铺、矿业与能源、大宗商品、基础设施、对冲基金、收藏市场等领域。</p>
<h2 id="1，私募股权投资的战略形式">1，私募股权投资的战略形式</h2><h3 id="（一）风险投资">（一）风险投资</h3><p>一般采用股权形式将资金投入提供具有创新性的专门产品或服务的初创型企业（start-up）</p>
<h3 id="（二）成长权益">（二）成长权益</h3><p>成长权益战略投资于已经具备成型的商业模型和较好的顾客群，同时具备正现金流的企业。成长权益投资者通过提供资金，帮助企业扩大规模。</p>
<h3 id="（三）并购投资">（三）并购投资</h3><p>是指专门进行企业并购的基金。</p>
<p>并购投资包含多种不同类型：</p>
<ul>
<li>杠杆收购，是指筹资过程当中所包含的债券融资比例较高的收购形式。</li>
</ul>
<p>并购投资者偏好于将那些最近经营不像预期一样好那具备可成长空间的企业设定为目标企业。</p>
<h3 id="（四）危机投资">（四）危机投资</h3><h3 id="（五）私募股权二级市场投资">（五）私募股权二级市场投资</h3><h1 id="第11章_投资者需求">第11章 投资者需求</h1><h2 id="1，企业年金基金">1，企业年金基金</h2><p>企业年金基金，是指企业年金计划筹集的资金及其投资运营收益形成的企业补充养老保险基金。企业年金基金财产的投资范围，限于银行存款、国债和其他具有良好流动性的金融产品，包括短期债券回购、信用等级在投资级以上的金融债和企业债、可转换债、投资性保险产品、证券投资基金、股票等。</p>
<h1 id="第12章_投资组合管理">第12章 投资组合管理</h1><h2 id="1，系统性风险">1，系统性风险</h2><p>一般为宏观层面的因素，主要包含政治因素、宏观经济因素、法律因素以及某些不可抗力因素。</p>
<h2 id="2，最小方差法">2，最小方差法</h2><p>最小方差法适应于投资者对预期收益率有一个最低要求的情形。投资者希望在投资组合的预期收益率达到给定目标的条件下最小化投资组合的风险，并且投资者以方差来度量投资组合的风险。</p>
<h2 id="3，有效前沿">3，有效前沿</h2><p>有效前沿是由全部有效投资组合构成的集合。如果一个投资组合在所有风险相同的投资组合中具有最高的预期收益率，或者在所有预期收益率相同的投资组合中具有最小的风险，那么这个投资组合就是有效的。</p>
<h2 id="4，资本资产定价模型">4，资本资产定价模型</h2><p>资本资产定价模型（capital asset pricing model，CAPM）以马克维茨证券组合理论为基础，研究如果投资者都按照分散化的理念去投资，最终证券市场达到均衡时，价格和收益率如何决定的问题。</p>
<ol>
<li>主要思想</li>
</ol>
<p>资本资产定价模型认为只有证券或证券组合的系统性风险才能获得收益补偿，其非系统性风险将得不到收益补偿。</p>
<ol>
<li>证券市场线</li>
</ol>
<p>证券市场线描述了一个资产或资产组合的预期收益率与其贝塔值之间的关系。贝塔值越高，则它的预期收益率越高，对于贝塔值为零的资产来说，它的预期收益率就应当等于无风险收益率。</p>
<h2 id="5，市场有效性">5，市场有效性</h2><ol>
<li>弱有效市场</li>
</ol>
<p>是指证券价格能够充分反映价格历史序列中包含的所有信息，如证券的价格、交易量等。如果这些历史信息对证券价格的变动不会产生任何影响，则意味着证券市场达到了弱有效。</p>
<ol>
<li>半强有效市场</li>
</ol>
<p>是指证券价格不仅已经反映了历史价格信息，而且反映了当前所有与公司证券有关的公开有效信息，例如盈利预测、红利发放、股票分析、公司并购等各种公告信息。</p>
<ol>
<li>强有效市场</li>
</ol>
<p>是指与证券有关的所有信息，包括公开发布的信息和未公开发布的内部信息，都已经充分、及时地反映到了证券价格之中。</p>
<h2 id="6，被动投资与跟踪误差">6，被动投资与跟踪误差</h2><p>跟踪误差是度量一个股票组合相对于某基准组合偏离程度的重要指标。该指标被广泛用于被动投资及主动投资管理者的业绩考核。跟踪误差（tracking error）是证券组合相对基准组合的跟踪偏离度的标准差，其中跟踪偏离度（tracking difference）的计算公式如下：</p>
<pre><code><span class="attribute">跟踪偏离度 </span>=<span class="string"> 证券组合的真实收益率 - 基准组合的收益率</span>
</code></pre><h2 id="7，主动投资">7，主动投资</h2><p>主动收益（active return）即相对于基准的超额收益，其计算方法如下：</p>
<pre><code><span class="attribute">主动收益 </span>=<span class="string"> 证券组合的真实收益 - 基准组合的收益</span>
</code></pre><h2 id="8，资产配置分类">8，资产配置分类</h2><ol>
<li><p>从范围上看，可分为全球资产配置、股票债券资产配置和行业风格资产配置等</p>
</li>
<li><p>从时间跨度和风格类别上看，可分为战略性资产配置、战术性资产配置和资产混合配置等</p>
</li>
<li><p>从配置策略上可分为买入并持有策略、恒定混合策略、投资组合保险策略和动态资产配置策略等</p>
</li>
</ol>
<h1 id="第13章_投资交易管理">第13章 投资交易管理</h1><h2 id="1，报价驱动市场">1，报价驱动市场</h2><p>报价驱动（quote driven）中，最为重要的角色就是做市商，因此报价驱动市场也被称为做市商制度。做市商通常由具备一定实力和信誉的证券投资法人承担，本身拥有大量可交易证券，买卖双方均直接与做市商交易，而买卖价格则由做市商报出。与股票不同的是，几乎所有的债券和外汇都是通过做市商交易的。</p>
<h2 id="2，保证金交易">2，保证金交易</h2><p>在我国，保证金交易被称为“融资融券”。</p>
<p>融资即投资者借入资金购买证券，也叫买空交易。融券即投资者借入证券卖出，也称卖空交易。</p>
<pre><code><span class="attribute">维持保证金比例 </span>=<span class="string"> （现金+信用证券账户内证券市值总和）/ （融资买入金额 + 融券卖出证券数量 * 当前市价 + 利息及费用总和）</span>
</code></pre><h1 id="第14章_投资风险的管理与控制">第14章 投资风险的管理与控制</h1><h2 id="1，市场风险">1，市场风险</h2><ol>
<li><p>政策风险</p>
</li>
<li><p>经济周期性波动风险</p>
</li>
<li><p>利率风险</p>
</li>
<li><p>购买力风险（通货膨胀风险）</p>
</li>
<li><p>汇率风险</p>
</li>
</ol>
<h2 id="2，贝塔系数">2，贝塔系数</h2><p>贝塔系数（β）是评估证券或投资组合系统性风险的指标，反映的是投资对象对市场变化的敏感度。</p>
<p>贝塔系数大于0时，该投资组合的价格变动方向与市场一致；贝塔系数小于0时，该投资组合的价格变动方向与市场相反。贝塔系数等于1时，该投资组合的价格变动幅度与市场一直。</p>
<h2 id="3，最大回撤">3，最大回撤</h2><p>最大回撤是从资产最高价格到接下来最低价格的损失。投资的期限越长，这个指标就越不利。</p>
<h2 id="4，风险价值">4，风险价值</h2><p>风险价值（value at risk， VaR），又称在险价值、风险收益、风险报酬，是指在一定的持有期和给定的置信水平下，利率、汇率等市场风险要素发生变化时可能对某项资金头寸、资产组合或投资机构造成的潜在最大损失。</p>
<h2 id="5，持股集中度">5，持股集中度</h2><p>$$ 持股集中度 = \dfrac{前十大重仓股投资市值}{基金股票投资总市值} * 100\% $$</p>
<h1 id="第15章_基金业绩评价">第15章 基金业绩评价</h1><h2 id="1，绝对收益">1，绝对收益</h2><h3 id="(1)_持有区间收益率">(1) 持有区间收益率</h3><p>持有区间所获得的收益通常来源于两部分：</p>
<ul>
<li><p>资产回报，是指股票、债券、房地产等资产价格的增加/减少</p>
</li>
<li><p>收入回报，包括分红、利息、租金等。</p>
</li>
</ul>
<p>$$ 资产回报率 = \dfrac{期末资产价格 - 期初资产价格}{期初资产价格} * 100\% $$</p>
<p>$$ 收入回报率 = \dfrac{期间收入}{期初资产价格} * 100\% $$</p>
<p>例：</p>
<p>假设某投资者在2013你那12月31日，买入1股A公司股票，价格为100元，2014年12月31日，A公司发放3元分红，同时其股价为105元，那么该区间内：</p>
<p>资产回报率 = (105 - 100) /100 * 100% = 5%</p>
<p>收入回报率 = 3/100 * 100% = 3%</p>
<p>总持有区间的收益率 = 5% + 3% = 8%</p>
<h3 id="(2)_基金收益率">(2) 基金收益率</h3><p>公募基金每天公布单位资产净值（NAV），其计算公式为：</p>
<pre><code><span class="attribute">期末基金单位资产净值 </span>=<span class="string"> 期末基金资产净值 / 期末基金单位总份额</span>
</code></pre><p>假设红利发放后立即对本基金进行再投资，且红利以除息前一日的单位净值为计算基准立即进行再投资，分别计算每次分红期间的分段收益率，考察期间的时间加权收益率可由分段收益率连乘得到：</p>
<p>例：</p>
<p>假设某基金在2012年12月3日的单位净值为1.4848元，2013年9月1日的单位净值为1.7886元。期间该基金曾于2013年2月28日每份额派发红利0.275元。该基金2013年2月27（除息前一天）的单位净值为1.8976元，则该基金在这段时间内的时间加权收益率为：</p>
<p>$$ R = \frac{1.8976}{1.4848} <em> \dfrac{1.7886}{1.8976-0.275}-1 </em> 100\% = 40.87\% $$</p>
<h3 id="(3)_平均收益率">(3)  平均收益率</h3><p>已知某基金近三年来累计收益率为26%，那么应用几何平均收益率计算的该基金的年(几何)平均收益率应为：</p>
<p>$$ R_{G} = [(1+26\%)^{1/3}-1] * 100\% = 8.01\% $$</p>
<h2 id="2，夏普比率">2，夏普比率</h2><p>夏普比率是诺贝尔经济学奖得主威廉·夏普于1966年根据资本资产定价模型（CAPM）提出的经风险调整的业绩测度指标。此比率是用某一时期内投资组合平均超额收益除以这个时期收益的标准差。用公式表示为：</p>
<p>$$ S<em>{p} = \dfrac{\overline R</em>{p} - \overline R<em>{f}}{\sigma</em>{p}} $$</p>
<p>式中：Sp表示夏普比率，Rp表示基金的平均收益率，Rf表示平均无风险收益率，sigma p表示基金收益率的标准差。</p>
<p>夏普比率数值越大，代表单位风险超额回报率越高，基金业绩越好。</p>
<h2 id="3，特雷诺比率">3，特雷诺比率</h2><p>特雷诺比率来源于CAPM理论，表示的是单位系统风险下的超额收益率。用公式表示为：</p>
<p>$$ T<em>{p} = \dfrac{\overline R</em>{p} - \overline R<em>{f}}{\beta</em>{p}} $$</p>
<p>特雷诺比率与夏普比率相似，两者的区别在于特雷诺比率使用的是系统风险，而夏普比率则是对全部风险进行了衡量。</p>
<h1 id="第16章_基金的募集、交易与登记">第16章 基金的募集、交易与登记</h1><h2 id="1，基金的募集程序">1，基金的募集程序</h2><ol>
<li>募集申请的注册</li>
</ol>
<p>证监会应当自受理基金募集申请之日起6个月内做出注册或不予注册的决定。</p>
<ol>
<li>基金份额的发售</li>
</ol>
<p>基金管理人应当自收到核准文件之日起6个月内进行基金份额的发售。</p>
<p>基金的募集期限自基金份额发售之日起计算，募集期限一般不得超过3个月。</p>
<ol>
<li>基金的合同生效</li>
</ol>
<p>封闭式基金需满足募集的基金份额总额达到核准规模的80%以上，并且基金份额持有人达到200人以上；</p>
<p>开放式基金需满足募集份额总额不少于2亿份，募集金额不少于2亿元人民币，基金份额持有人的人数不少于200人。</p>
<h2 id="2，基金的认购">2，基金的认购</h2><p>开放式基金的认购采取金额认购的方式，即投资者在办理认购申请时，不是直接以认购数量提出申请，而是以金额申请。</p>
<h2 id="3，封闭式基金折（溢）价率">3，封闭式基金折（溢）价率</h2><p>投资者常常使用折（溢）价率反映封闭式基金份额净值与其二级市场之间的关系。折（溢）价率的计算公式为：</p>
<p>$$ 折（溢）价率 = \dfrac{二级市场价格 - 基金份额净值} {基金份额净值}  = (\dfrac{二级市场价格}{基金份额净值} - 1) * 100\% $$</p>
<p>当基金二级市场价格高于基金份额净值时，为溢价交易，对应的是溢价率；当二级市场价格低于基金份额净值时，为折价交易，对应的是折价率。</p>
<h2 id="4，开放式基金的申购和赎回原则">4，开放式基金的申购和赎回原则</h2><h3 id="股票基金、债券基金的申购和赎回原则">股票基金、债券基金的申购和赎回原则</h3><ol>
<li><p>未知价交易原则</p>
</li>
<li><p>金额申购、份额赎回原则</p>
</li>
</ol>
<h3 id="货币市场基金的申购和赎回原则">货币市场基金的申购和赎回原则</h3><ol>
<li><p>确定价原则。货币市场基金申购和赎回基金份额以1元人民币为基准进行计算。</p>
</li>
<li><p>金额申购、份额赎回原则。</p>
</li>
</ol>
<h2 id="5，申购份额及赎回金额的计算">5，申购份额及赎回金额的计算</h2><p>某投资者通过场外（某银行）投资1万元申购某上市开放式基金，假设基金管理人规定的申购费率为1.5%，申购当日基金份额净值为1.025元，则其申购手续费和可得到的申购份额为：</p>
<pre><code>净申购金额 = <span class="number">10000</span>/(<span class="number">1</span>+<span class="number">1.5</span>%) = <span class="number">9852.22</span> 元

申购手续费 = <span class="number">10000</span> - <span class="number">9852.22</span> = <span class="number">147.78</span> 元

申购份额 = <span class="number">9852.22</span>/<span class="number">1.025</span> = <span class="number">9611.92</span> 份
</code></pre><p>某投资者赎回上市开放式基金1万份基金单位，持有时间为1年半，对应的赎回费率为0.5%。假设赎回当日基金单位净值为1.0250元，则其可得净赎回金额为：</p>
<pre><code>赎回总金额 = <span class="number">10000</span> * <span class="number">1.025</span> = <span class="number">10250</span> 元

赎回手续费 = <span class="number">10250</span> * <span class="number">0.005</span> = <span class="number">51.25</span> 元

净赎回金额 = <span class="number">10250</span> -<span class="number">51.25</span> = <span class="number">10198.75</span> 元
</code></pre><p>实现后端收费模式的基金，还应扣除后端认购/申购费，才是投资者最终得到的赎回金额。即：</p>
<pre><code><span class="attribute">赎回金额 </span>=<span class="string"> 赎回总额 - 赎回费用 - 后端收费金额</span>
</code></pre><h2 id="6，ETF基金份额折算的方法">6，ETF基金份额折算的方法</h2><p>基金管理人通常会以某一选定日期作为基金份额折算日，以标的指数的千分之一（或1%）作为份额净值，对原来的基金份额及其净值进行折算。</p>
<p>假设某投资者在某ETF基金募集期内认购了5000份ETF，基金份额折算日的基金资产净值为3127000230.95元，折算前的基金份额总额为3013057000份，当日标的指数收盘值为966.45元。</p>
<p>（1）折算比例 = (3127000230.95/3013057000) / (966.45/1000) = 1.07384395</p>
<p>（2）该投资者折算后的基金份额 = 5000 * 1.07384395 = 5369.22 份</p>
<h1 id="第17章_基金的投资交易与清算">第17章 基金的投资交易与清算</h1><h2 id="1，大宗交易">1，大宗交易</h2><p>大宗交易是指单笔数额较大的证券买卖。我国现行有关交易制度规定，如果证券单笔买卖申报达到一定数额的，证券交易所可以采用大宗交易方式进行。</p>
<p>上海证券交易所接受大宗交易的时间为每个交易日9:30 - 11:30、13:00 - 15:30。</p>
<h2 id="2，开盘价和收盘价">2，开盘价和收盘价</h2><ol>
<li><p>开盘价为当日证券的第一笔成交价，证券的开盘价通过集合竞价方式产生。不能产生开盘价的，以连续竞价方式产生。按集合竞价产生开盘价后，未成交的买卖申报仍然有效，并按原申报顺序自动进入连续竞价。</p>
</li>
<li><p>收盘价，上交所的收盘价为当日该证券最后一笔交易前1分钟所有交易的成交量加权平均价（含最后一笔交易）。深交所的收盘价通过集合竞价的方式产生。收盘集合竞价不能产生收盘价或未进行收盘集合竞价的，以当日该证券最后一笔交易前1分钟所有交易的成交量加权平均价（含最后一笔交易）为收盘价。</p>
</li>
<li><p>除权与除息</p>
</li>
</ol>
<p>因送股或配股而形成的剔除行为称为除权，因派息而引起的剔除行为称为除息。</p>
<h2 id="3，回购">3，回购</h2><ul>
<li><p>质押式回购，是指一方（正回购方）在讲回购债券出质给另一方（逆回购方），逆回购方在首期结算日向正回购方支付首期资金结算额的同时，交易双方约定在将来某一日期（即到期结算日）由正回购方向逆回购方支付到期资金结算额，同时逆回购方解除在回购债券上设定的质权的交易。</p>
</li>
<li><p>买断式回购，是指一方（正回购方）在将回购债券出售给另一方（逆回购方），逆回购方在首期结算日向正回购方支付首期资金结算额的同时，交易双方约定在将来某一日期（即到期结算日）由正回购方以约定价格（即到期资金结算额）从逆回购方购回回购债券的交易。期限最长不得超过91天。</p>
</li>
</ul>
<h1 id="第18章_基金的估值、费用与会计核算">第18章 基金的估值、费用与会计核算</h1><h2 id="1，基金资产估值">1，基金资产估值</h2><pre><code><span class="attribute">基金份额净值 </span>=<span class="string"> 基金资产净值 / 基金总份额</span>
</code></pre><h2 id="2，基金资产估值频率">2，基金资产估值频率</h2><p>开放式基金，于每个交易日估值，并于次日公告基金份额净值。封闭式基金每周披露一次基金份额净值，但每个交易日也都进行估值。</p>
<h2 id="3，基金费用">3，基金费用</h2><ul>
<li>管理费率</li>
</ul>
<p>我国股票基金大部分按照1.5%的比例计提基金管理费，债券基金的管理费率一般低于1%，货币市场基金的管理费率不高于0.33%</p>
<ul>
<li>托管费</li>
</ul>
<p>我国股票型封闭式基金按照0.25%的比例计提基金托管费；开放式基金根据基金合同的规定比例计提，通常低于0.25%；股票基金的托管费率要高于债券基金及货币市场基金的托管费率。</p>
<ul>
<li>基金销售服务费</li>
</ul>
<p>目前只有货币市场基金和一些债券型基金收取，费率一般为0.25%。收取销售服务费的基金通常不收取申购和赎回费。</p>
<ul>
<li>计提方法和支付方式</li>
</ul>
<p>目前，我国的基金管理费、基金托管费及基金销售服务费均是按前一日基金资产净值的一定比例逐日计算，按月支付。计算方法如下：</p>
<p>$$ H = \dfrac{E·R}{当年实际天数} $$</p>
<p>式中：H表示每日计提的费用；E表示前一日的基金资产净值；R表示年费率。</p>
<h2 id="4，基金会计核算">4，基金会计核算</h2><p>会计年度为公历每年1月1日至12月31日</p>
<p>基金会计核算的内容主要包括以下业务：</p>
<ol>
<li><p>证券和衍生工具交易核算</p>
</li>
<li><p>权益核算</p>
</li>
<li><p>利息和溢价核算</p>
</li>
<li><p>费用核算</p>
</li>
<li><p>基金申购与赎回核算</p>
</li>
<li><p>估值核算</p>
</li>
<li><p>利润核算</p>
</li>
<li><p>基金财务会计报告</p>
</li>
<li><p>基金会计核算的复核</p>
</li>
</ol>
<h1 id="第19章_基金的利润分配与税收">第19章 基金的利润分配与税收</h1><h2 id="1，与基金利润有关的财务指标">1，与基金利润有关的财务指标</h2><ul>
<li>本期利润</li>
</ul>
<p>是基金在一定时期内全部损益的总和，包括计入当期损益的公允价值变动损益。</p>
<ul>
<li>本期已实现收益</li>
</ul>
<p>指基金本期利息收入、投资收益、其他收入（不含公允价值变动损益）扣除相关费用后的余额，是将本期利润扣除本期公允价值变动损益后的余额，反映基金本期已经实现的损益。</p>
<ul>
<li>期末可供分配利润</li>
</ul>
<p>该指标是指期末可供基金进行利润分配的金额，为期末资产负债表中未分配利润与未分配利润中已实现部分的孰低数。</p>
<ul>
<li>未分配利润</li>
</ul>
<p>是基金进行利润分配后的剩余额。未分配利润将转入下棋分配。</p>
<h2 id="2，利润分配">2，利润分配</h2><p>《公开募集证券投资基金运作管理办法》规定：封闭式基金的收益分配，每年不得少于一次；封闭式基金年度收益分配比例不得低于基金年度可供分配利润的90%。基金收益分配后基金份额净值不得低于面值。</p>
<p>封闭式基金只能采用现金分红。</p>
<p>开放式基金可采用现金分红方式和分红后再投资转换为基金份额。</p>
<h1 id="第20章_基金的信息披露">第20章 基金的信息披露</h1><h2 id="1，信息披露时间">1，信息披露时间</h2><p>在每年结束后90日内，在指定报刊上披露年度报告摘要，在管理人网站上披露年度报告全文。在上半年结束后60日内，在指定报刊上披露半年度报告摘要，在管理人网站上披露半年度报告全文。在每季结束后15个工作日内，在指定报刊和管理人网站上披露基金季度报告。</p>
<h2 id="2，基金运作信息披露文件主要包括">2，基金运作信息披露文件主要包括</h2><ul>
<li><p>基金净值公告</p>
</li>
<li><p>基金定期公告</p>
</li>
<li><p>基金上市交易公告书</p>
</li>
</ul>
<h2 id="3，基金招募说明书内容">3，基金招募说明书内容</h2><ul>
<li><p>基金投资目标</p>
</li>
<li><p>投资范围</p>
</li>
<li><p>投资策略</p>
</li>
<li><p>业绩比较基准</p>
</li>
<li><p>风险收益特征</p>
</li>
<li><p>投资限制</p>
</li>
</ul>
<h1 id="基金销售行为规范及信息管理">基金销售行为规范及信息管理</h1><h2 id="赎回费">赎回费</h2><ul>
<li><p>对持续持有期少于7日的投资人收取不低于1.5%的赎回费</p>
</li>
<li><p>对持续持有期少于30日的投资人收取不低于0.75%的赎回费，并将上述赎回费全额计入基金财产</p>
</li>
<li><p>对于持续持有期少于3个月的投资人收取不低于0.5%的赎回费，并将不低于赎回费总额的75%计入基金财产</p>
</li>
<li><p>对于持续持有期长于3个月但少于6个月的投资人收取不低于0.5%的赎回费，并将不低于赎回费总额的50%计入基金财产</p>
</li>
</ul>
<p>*对持续持有期长于6个月的投资人，应当将不低于赎回费总额的25%计入基金财产。</p>
<h1 id="第26章_基金的国际化">第26章 基金的国际化</h1><h2 id="1，欧盟的基金法规">1，欧盟的基金法规</h2><p>可转让证券集合投资计划（Undertakings for Collective Investment in Transferable Securities， UCITS），是欧盟跨境投资基金的主要模式。</p>
<p>另类投资基金管理人指令（Alternative Investment Fund Managers Directive， AIFMD）</p>
<h2 id="2，QFII">2，QFII</h2><p>合格境外机构投资者（qualified foreign institutional investors， QFII），是我国在资本项目未完全开放的背景下选择的一种过渡性资本市场开放制度。</p>
<hr>
<h1 id="考试重点：">考试重点：</h1><h1 id="保证金交易">保证金交易</h1><p>在我国，保证金交易被称为“融资融券”。<br>融资即投资者借入资金购买证券，也叫买空交易。融券即投资者借入证券卖出，也称卖空交易。<br><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">维持保证金比例 </span>=<span class="string"> （现金+信用证券账户内证券市值总和）/ （融资买入金额 + 融券卖出证券数量 * 当前市价 + 利息及费用总和）</span></span><br></pre></td></tr></table></figure></p>
<h1 id="贝塔系数">贝塔系数</h1><p>$$ \beta<em>{p} =p</em>{p,m} <em> o<em>{p}/o</em>{m} $$<br>证券投资组合p的收益率的标准差为0.49，市场收益率的标准差为0.32，投资组合p与市场收益的相关系数为0.6，则该投资组合的贝塔系数为：<br>beta = 0.6 </em> 0.49/0.32 = 0.92</p>
<h1 id="时间加权收益率">时间加权收益率</h1><p>前半年的收益率为15%，后半年的收益率为9.77%，则其一年的时间加权收益率为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>+<span class="number">15</span>%)*(<span class="number">1</span>+<span class="number">9.77</span>%) -<span class="number">1</span> =  <span class="number">26.23</span>%</span><br></pre></td></tr></table></figure></p>
<h1 id="费雪方程式-1">费雪方程式</h1><p>物价上涨时，名义利率一般比实际利率高<br><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">实际利率 </span>=<span class="string"> 名义利率 -  通货膨胀率</span></span><br></pre></td></tr></table></figure></p>
<h1 id="不变增长模型股利贴现公式">不变增长模型股利贴现公式</h1><p>上年末某公司支付每股股息为2元，预计在未来其股息按每年4%的速度增长，必要收益率为12%，则该公司股票的价值为多少？<br>V = 2 * (1 + 4%）/ ( 12% - 4%) = 26 元</p>
<h1 id="资本资产定价模型">资本资产定价模型</h1><p> 假设资本资产定价模型成立，某股票的预期收益率为16%，贝塔系数为2，如果市场预期收益率为12%，市场的无风险利率为：<br>$$ E(r<em>{i}) = r</em>{F} + (E(r<em>{M} -  r</em>{F}) * \beta $$</p>
<p>16%  = r + (12% - r) * 2 ，解得 r = 8</p>
<h1 id="詹森指数">詹森指数</h1><p>假定在样本期内无风险利率为6%，市场资产组合的平均收益率为18%，基金A的平均收益率为17.6%，贝塔值为1.2；则詹森指数为：<br>17.6% - [6% + (18%-6%) * 1.2] = -2.8%</p>
<h1 id="除权（息）参考价_=_(_前收盘价_-_现金红利_+_配股价格_*_股份变动比例)_/_(_1_+_股份变动比例)">除权（息）参考价 = ( 前收盘价 - 现金红利 + 配股价格 * 股份变动比例) / ( 1 + 股份变动比例)</h1><h1 id="股利贴现模型">股利贴现模型</h1><h1 id="久期_与_债券内在价值">久期 与 债券内在价值</h1><p>某3年期债券的面值为1000元，票面利率为8%，每年付息一次，现在市场收益率为10%，其市场价格为950.25元，则其久期为：<br>内在价值：V = (1000<em>8%)/(1+8%) + (1000</em>8%)/(1+8%)^2 + (1000*8%)/(1+8%)^3 + 1000/(1+8%)^3<br>久期：  D = V / 950.25  = 2.78</p>
<h1 id="当期收益率-1">当期收益率</h1><p>假定某投资者按940原的价格购买了面额为1000元、票面利率为10%、剩余期限为6年的债券，那么该投资者的当期收益率为：<br>$$ I = \dfrac{C}{P} $$</p>
<p>式中：I表示当期收益率，C表示年息票利息，P表示债券市场价格。</p>
<p>I =  1000 * 10% / 940 = 10.64%</p>
<h1 id="到期收益率-1">到期收益率</h1><p>一般用y表示，债券市场价格和到期收益率的关系式为：</p>
<p>$$ P = \sum_{t=1}^{n}\dfrac{C}{(1+y)^t} + M(\dfrac{1}{1+y})^n $$</p>
<p>式中：P表示债券市场价格；C表示每期支付的利息，n表示时期数；M表示债券面值。</p>
<p>例：</p>
<p>票面金额为100元的2年期债券，第一年支付利息6元，第二年支付利息6元，当前市场价格为95元，则该债券的到期收益率和当前价格之间的关系可表达为：</p>
<pre><code><span class="number">95</span> = <span class="number">6</span>/(<span class="number">1</span>+y) + <span class="number">106</span>/(<span class="number">1</span>+y)^<span class="number">2</span>
</code></pre><p>求解得y=8.836%</p>
<h1 id="国内第一家投资基金">国内第一家投资基金</h1><p>1992年11月，淄博乡镇企业投资基金（简称“淄博基金”）正式设立，1993年8月在上交所挂牌上市。该基金委公司型封闭式基金。</p>
<h1 id="中国证券投资基金试点的序幕">中国证券投资基金试点的序幕</h1><p>1998年3月27日，南方基金和国泰基金公司分别发起的两只封闭式基金——基金开元和基金金泰。</p>
<p>#国内第一只开放式基金</p>
<p>2001年9月，华安创新</p>
<h1 id="国内第一只货币市场基金">国内第一只货币市场基金</h1><p>2003年12月推出的华安现金富利投资基金</p>
<h1 id="对冲基金">对冲基金</h1><p>起源于20世纪50年代初的美国。</p>
<h1 id="世界上第一只开放式投资基金">世界上第一只开放式投资基金</h1><p>1924年由200多名哈佛大学教授出资5万美元在波士顿成立的“马萨诸塞投资信托基金”被公认为美国开放式公司型共同基金的鼻祖。</p>
<h1 id="世界上最早的证券投资基金">世界上最早的证券投资基金</h1><p>英国“海外及殖民地政府信托基金”成立于1868年</p>
<h1 id="世界上第一只ETF基金">世界上第一只ETF基金</h1><p>1990年，加拿大多伦多证券交易所推出了世界上第一只ETF指数参与份额。</p>
<h1 id="证券投资基金法实施日期">证券投资基金法实施日期</h1><p>2004年6月1日，修订后的证券投资基金法于2013年6月1日正式实施。</p>
<h1 id="中国证券投资基金业协会成立日期">中国证券投资基金业协会成立日期</h1><p>2012年6月6日</p>
<h1 id="ETF折算比例">ETF折算比例</h1><p>假设某投资者在基金募集期内认购了100万份ETF，基金份额折算日的基金资产净值为320亿元，折算日的基金份额总额为310万亿，当日标的指数收盘值为966.45元，则该投资者折算后的份额为多少万份？</p>
<p>解：</p>
<p>折算比例 = (折算日的基金资产净值 / 折算日的基金份额总额) / （当日标的指数收盘值 / 1000)</p>
<p> = (320/310) / (966.45/1000) = 1.068 ；</p>
<p>折算后的基金份额 =  原持有份额 <em> 折算比例 = 100 </em> 1.068 = 106.8 万份。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="第一章_金融、资产管理与投资基金">第一章 金融、资产管理与投资基金</h1><h2 id="1，金融资产">1，金融资产</h2><p>一般分为债券类金融资产和股权类金融资产。</p>
<p>债券类金融资产以票据、债券等契约型投资工具为主，股权类金融资产以各类股票为主。</p>
<h2 id="2，投资基金的主要类别">2，投资基金的主要类别</h2><p>主要按照所投资的对象的不同进行区分：</p>
<ol>
<li><p>证券投资基金<br>基金所投资的有价证券主要是在证券交易所或银行间市场上公开交易的证券，包括股票、债券、货币、金融衍生工具等。<br>可分为公募证券投资基金和私募证券投资基金等种类。</p>
</li>
<li><p>私募股权基金<br>私募股权基金（private equity，PE）指通过私募形式对私有企业，即非上市企业进行的权益性投资。</p>
</li>
<li><p>风险投资基金<br>风险投资基金（venture capital，VC），又叫创业基金，它以一定的方式吸收机构和个人的资金，投向与那些不具备上市资格的初创期的或者是小型的新型企业，尤其是高新技术企业，帮助所投资的企业尽快成熟，取得上市资格，从而使资本增值。</p>
</li>
<li><p>对冲基金（hedge fund），意为“风险对冲过的基金”，它是基于投资理论和极其复杂的金融市场操作技巧，充分利用各种金融衍生产品的杠杆作用，承担高风险、追求高收益的投资模式。</p>
</li>
<li><p>另类投资基金<br>是指投资于传统的股票、债券之外的金融和实物资产的基金，如房地产、证券化资产、对冲基金、大宗商品、黄金、艺术品等。</p>
</li>
</ol>]]>
    
    </summary>
    
      <category term="基金" scheme="http://www.kekefund.com/tags/%E5%9F%BA%E9%87%91/"/>
    
      <category term="考试" scheme="http://www.kekefund.com/tags/%E8%80%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scrapy框架初探]]></title>
    <link href="http://www.kekefund.com/2016/03/31/scrapy-learn/"/>
    <id>http://www.kekefund.com/2016/03/31/scrapy-learn/</id>
    <published>2016-03-31T09:00:03.000Z</published>
    <updated>2016-03-31T09:17:38.000Z</updated>
    <content type="html"><![CDATA[<p>scrapy爬虫框架在业内大大有名，自己写过静态网页和动态网页的爬虫，一直没拿scrapy来写，近来看了scrapy的官方文档，了解了大致的流程，故拿来练手实践了一个项目。</p>
<p>本文主要抓取股吧的文章，内容包括:</p>
<ul>
<li><p>定义抓取Spider</p>
</li>
<li><p>数据字段的定义</p>
</li>
<li><p>内容解析</p>
</li>
<li><p>数据存储到mysql</p>
</li>
<li><p>PyCharm调试scrapy</p>
</li>
</ul>
<h1 id="一、定义抓取Spider">一、定义抓取Spider</h1><p>创建一个新的Spider</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider gub<span class="built_in">a_spider</span> eastmoney.com</span><br></pre></td></tr></table></figure>
<p>默认创建的Spider是继承与BaseSpider，一般我们继承功能更多的CrawlSpider。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> CrawlSpider, Rule</span><br><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GubaSpider</span><span class="params">(CrawlSpider)</span>:</span></span><br><span class="line">    name = <span class="string">'guba'</span></span><br><span class="line">    allowed_domains = [<span class="string">'eastmoney.com'</span>]</span><br></pre></td></tr></table></figure>
<p>定义好GubaSpider类后，然后要指定开始网页start_urls和rules抓取网页规则。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">start_urls = [</span><br><span class="line">    <span class="string">'http://guba.eastmoney.com/default_%d.html'</span> % index <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">rules = (</span><br><span class="line">    <span class="comment"># 提取匹配 文章 的链接并使用spider的parse_article方法进行分析</span></span><br><span class="line">    Rule(LinkExtractor(allow=(<span class="string">r'^http://guba.eastmoney.com/news.'</span>, )), callback=<span class="string">'parse_article'</span>),</span><br><span class="line"></span><br><span class="line">    Rule(LinkExtractor(allow=(<span class="string">r'^http://iguba.eastmoney.com/\d+.'</span>,)), callback=<span class="string">'parse_auther'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>我们主要爬取的是下面这块区域：</p>
<p><img src="http://7xo67b.com1.z0.glb.clouddn.com/2016-03-31/guba.png" alt=""></p>
<p>rules规则定义了两类链接，一个是文章链接，一个是作者链接。</p>
<p>链接的规则可以通过Chrome的开发者工具得到，如下：<br><img src="http://7xo67b.com1.z0.glb.clouddn.com/2016-03-31/guba2.png" alt=""></p>
<p>Rule中的LinkExtractor是从网页(scrapy.http.Response)中抽取满足allow条件的链接，callback回调至指定函数。</p>
<p>启动Spider，执行的流程是：</p>
<ol>
<li><p>从start_urls中开始爬取网页，</p>
</li>
<li><p>找到满足文章链接的规则，跳转到self.parse_article()函数进一步处理。</p>
</li>
</ol>
<h1 id="二、定义数据字段">二、定义数据字段</h1><p>在scrapy目录下的items.py中定义结构化数据字段。</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> scrapy</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArticleItem</span>(<span class="title">scrapy</span>.<span class="title">Item</span>):</span></span><br><span class="line">    uuid = scrapy.<span class="keyword">Field</span>()<span class="preprocessor"> # 唯一标识符</span></span><br><span class="line">    user_id = scrapy.<span class="keyword">Field</span>()</span><br><span class="line">    user_name = scrapy.<span class="keyword">Field</span>()</span><br><span class="line">    title = scrapy.<span class="keyword">Field</span>()</span><br><span class="line">    classify = scrapy.<span class="keyword">Field</span>()</span><br><span class="line">    content = scrapy.<span class="keyword">Field</span>()</span><br><span class="line">    readed_count = scrapy.<span class="keyword">Field</span>()</span><br><span class="line">    comment_count = scrapy.<span class="keyword">Field</span>()</span><br><span class="line">    href = scrapy.<span class="keyword">Field</span>()</span><br><span class="line">    source = scrapy.<span class="keyword">Field</span>()</span><br><span class="line">    published_date = scrapy.<span class="keyword">Field</span>()</span><br><span class="line">    scrapy_date = scrapy.<span class="keyword">Field</span>()<span class="preprocessor">    # 抓取日期</span></span><br></pre></td></tr></table></figure>
<h1 id="三、内容解析">三、内容解析</h1><p>scrapy默认的是用xpath解析网页，由于对Beautifulsoup更熟悉，我在本文中用的Beautifulsoup来解析网页内容，道理都是一样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="keyword">as</span> bs</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> gubademo.items <span class="keyword">import</span> ArticleItem</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_article</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"content news:%s"</span> % response.url</span><br><span class="line"></span><br><span class="line">    soup = bs(response.body, <span class="string">'lxml'</span>)</span><br><span class="line"></span><br><span class="line">    item = ArticleItem()</span><br><span class="line"></span><br><span class="line">    item[<span class="string">'title'</span>] = response.url</span><br><span class="line">    item[<span class="string">'href'</span>] = response.url</span><br><span class="line"></span><br><span class="line">    div_name = soup.find(<span class="string">'div'</span>,&#123;<span class="string">'id'</span>:<span class="string">'zwconttbn'</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> div_name:</span><br><span class="line">        item[<span class="string">'user_name'</span>] = div_name.find(<span class="string">'a'</span>).text</span><br><span class="line">        <span class="keyword">if</span> div_name.find(<span class="string">'a'</span>).has_attr(<span class="string">'data-popper'</span>):</span><br><span class="line">            item[<span class="string">'user_id'</span>] = div_name.find(<span class="string">'a'</span>)[<span class="string">'data-popper'</span>]</span><br><span class="line"></span><br><span class="line">    span_stockname = soup.find(<span class="string">'span'</span>, &#123;<span class="string">'id'</span>:<span class="string">'stockname'</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> span_stockname:</span><br><span class="line">        item[<span class="string">'classify'</span>] = span_stockname.find(<span class="string">'a'</span>).text</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 内容</span></span><br><span class="line">    c_div = soup.find(<span class="string">'div'</span>, &#123;<span class="string">'class'</span>:<span class="string">'stockcodec'</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> c_div:</span><br><span class="line">        item[<span class="string">'content'</span>] = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> c_div.strings:</span><br><span class="line">            item[<span class="string">'content'</span>] += s</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 时间</span></span><br><span class="line">    t_div = soup.find(<span class="string">'div'</span>, &#123;<span class="string">'class'</span>:<span class="string">'zwfbtime'</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> t_div:</span><br><span class="line">        s1 = re.search(<span class="string">'\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125; \d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;'</span>,t_div.text)</span><br><span class="line">        <span class="keyword">if</span> s1:</span><br><span class="line">            item[<span class="string">'published_date'</span>] = s1.group()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 阅读数和评论数</span></span><br><span class="line">    m = re.search(<span class="string">'num=(\d+).*?var count=\d+'</span>, response.body)</span><br><span class="line">    <span class="keyword">if</span> m:</span><br><span class="line">        item[<span class="string">'readed_count'</span>] = m.group(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        item[<span class="string">'readed_count'</span>] = <span class="string">u'0'</span></span><br><span class="line"></span><br><span class="line">    m = re.search(<span class="string">'var pinglun_num=(\d+)'</span>, response.body)</span><br><span class="line">    <span class="keyword">if</span> m:</span><br><span class="line">        item[<span class="string">'comment_count'</span>] = m.group(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        item[<span class="string">'comment_count'</span>] = <span class="string">u'0'</span></span><br><span class="line">    item[<span class="string">'source'</span>] = <span class="string">'guba_eastmoney'</span></span><br><span class="line">    item[<span class="string">'scrapy_date'</span>] =  GetNowTime()</span><br><span class="line">    item[<span class="string">'uuid'</span>] = md5(item[<span class="string">'href'</span>]).hexdigest()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> item</span><br><span class="line">    <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>
<h1 id="四、写入数据库">四、写入数据库</h1><p>解析完数据，接下来是要保存数据以便以后分析使用。</p>
<p>自定义Pipeline，spider将item传递到pipeline，默认调用的是process_item()函数，我们可以在processs_item中根据item的类型进行差异化处理。</p>
<p>需要先在setting.py中设置如下内容，scrapy才能走着这一步。</p>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># Configure item pipelines</span></span><br><span class="line"><span class="preprocessor"># See http://scrapy.readthedocs.org/en/latest/topics/item-pipeline.html</span></span><br><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">   #<span class="string">'wealth_tech.pipelines.DuplicatePipeline'</span>:<span class="number">200</span>,</span><br><span class="line">   <span class="string">'wealth_tech.pipelines.MySQLStorePipeline'</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MySQLStorePipeline定义了一个article_items集合用于存储spider爬到的item，当items数量达到1000时，批量写入数据库。如果接受到item就单条写入数据库，会比批量写入慢很对，爬虫的效率会慢一个数量级。<br>存入mysql之前，先查询数据库，若不存在则insert，存在则update。<br>数据库的host,port等信息一般存在setting.py中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"><span class="keyword">import</span> MySQLdb.cursors</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> wealth_tech.settings <span class="keyword">as</span> settings</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line">engine = create_engine(<span class="string">'mysql+mysqldb://%s:%s@%s:%d/%s'</span> % (settings.MYSQL_USER, settings.MYSQL_PASSWD, settings.MYSQL_HOST, <span class="number">3306</span>, settings.MYSQL_DBNAME), connect_args=&#123;<span class="string">'charset'</span>:<span class="string">'utf8'</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQLStorePipeline</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    写入mysql数据库</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.article_items = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pipeline默认调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> spider.name</span><br><span class="line">        <span class="keyword">if</span> type(item) <span class="keyword">is</span> ArticleItem:</span><br><span class="line">            self.process_article_item(item, spider) <span class="comment"># 文章</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_article_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        保存文章</span><br><span class="line">        """</span></span><br><span class="line">        table = <span class="string">'article_guba_easymoney'</span></span><br><span class="line"></span><br><span class="line">        self.article_items.setdefault(spider.name, [])</span><br><span class="line">        self.article_items[spider.name].append(item)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(self.article_items[spider.name]) &gt;= <span class="number">1000</span>: <span class="comment"># 积累到1000条就写入数据库</span></span><br><span class="line"></span><br><span class="line">            conn=MySQLdb.connect(host=settings.MYSQL_HOST,user=settings.MYSQL_USER,passwd= settings.MYSQL_PASSWD,db=settings.MYSQL_DBNAME,charset=<span class="string">"utf8"</span>)</span><br><span class="line">            cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line">            df = pd.read_sql(<span class="string">'select uuid from &#123;&#125;'</span>.format(table), engine)</span><br><span class="line">            uuids = df[<span class="string">'uuid'</span>].get_values()</span><br><span class="line">            uuids = set(uuids)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> self.article_items[spider.name]:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">if</span> item[<span class="string">'uuid'</span>] <span class="keyword">not</span> <span class="keyword">in</span> uuids:</span><br><span class="line">                        <span class="comment"># 插入</span></span><br><span class="line">                        sql = <span class="string">'insert into &#123;&#125; values(%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)'</span>.format(table)</span><br><span class="line">                        param = (item[<span class="string">'uuid'</span>],item[<span class="string">'user_id'</span>],item[<span class="string">'user_name'</span>],item[<span class="string">'title'</span>],item[<span class="string">'classify'</span>],item[<span class="string">'content'</span>],</span><br><span class="line">                                 item[<span class="string">'readed_count'</span>],item[<span class="string">'comment_count'</span>],item[<span class="string">'href'</span>],item[<span class="string">'source'</span>],item[<span class="string">'published_date'</span>],item[<span class="string">'scrapy_date'</span>])</span><br><span class="line">                        n = cursor.execute(sql,param)</span><br><span class="line">                        <span class="keyword">print</span> <span class="string">'insert '</span>,n, item[<span class="string">'uuid'</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment">#更新</span></span><br><span class="line">                        sql = <span class="string">"update &#123;&#125; set fans_count=%s, article_count=%s,visit_count=%s,comment_count=%s,scrapy_date=%s where user_id='&#123;&#125;'"</span>.format(table, item[<span class="string">'user_id'</span>])</span><br><span class="line">                        <span class="comment">#print sql</span></span><br><span class="line">                        param = (item[<span class="string">'fans_count'</span>],item[<span class="string">'article_count'</span>],item[<span class="string">'visit_count'</span>],item[<span class="string">'comment_count'</span>],item[<span class="string">'scrapy_date'</span>])</span><br><span class="line">                        n = cursor.execute(sql,param)</span><br><span class="line">                        <span class="keyword">print</span> <span class="string">'update'</span>, n,item[<span class="string">'uuid'</span>]</span><br><span class="line">                <span class="keyword">except</span> Exception,e:</span><br><span class="line">                    <span class="keyword">print</span> e</span><br><span class="line"></span><br><span class="line">             <span class="comment">#提交</span></span><br><span class="line">            conn.commit()</span><br><span class="line">            <span class="comment">#关闭</span></span><br><span class="line">            conn.close()</span><br><span class="line">            self.article_items[spider.name] = []</span><br></pre></td></tr></table></figure>
<p>数据库呈现的结果：</p>
<p><img src="http://7xo67b.com1.z0.glb.clouddn.com/2016-03-31/guba3.png" alt=""></p>
<h1 id="五、PyCharm_Debug调试scrapy">五、PyCharm Debug调试scrapy</h1><p>scrapy通常在命令行里运行，但仅通过log显示的信息来调试时非常费劲的，程序猿需要的是单步调试，step by step。</p>
<p>在PyCharm中调试也是很容易的。</p>
<p>在scrapy项目的根目录下（与scrapy.cfg同级）新建一个文件run.py，内容如下：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line">from scrapy.cmdline import<span class="instruction"> execute</span><br><span class="line"></span>execute(<span class="function">)</span></span><br></pre></td></tr></table></figure>
<p>新建一个Run/Debug Configurations，Script选择run.py，Script parameters输入crawl guba。其中guba是在GubaSpider中定义的name。这样启动Debug就能单步调试了。<br><img src="http://7xo67b.com1.z0.glb.clouddn.com/2016-03-31/guba4.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>scrapy爬虫框架在业内大大有名，自己写过静态网页和动态网页的爬虫，一直没拿scrapy来写，近来看了scrapy的官方文档，了解了大致的流程，故拿来练手实践了一个项目。</p>
<p>本文主要抓取股吧的文章，内容包括:</p>
<ul>
<li><p>定义抓取Spider</p>
</li>
<li><p>数据字段的定义</p>
</li>
<li><p>内容解析</p>
</li>
<li><p>数据存储到mysql</p>
</li>
<li><p>PyCharm调试scrapy</p>
</li>
</ul>
<h1 id="一、定义抓取Spider">一、定义抓取Spider</h1><p>创建一个新的Spider</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy genspider gub<span class="built_in">a_spider</span> eastmoney.com</span><br></pre></td></tr></table></figure>
<p>默认创建的Spider是继承与BaseSpider，一般我们继承功能更多的CrawlSpider。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.spiders <span class="keyword">import</span> CrawlSpider, Rule</span><br><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GubaSpider</span><span class="params">(CrawlSpider)</span>:</span></span><br><span class="line">    name = <span class="string">'guba'</span></span><br><span class="line">    allowed_domains = [<span class="string">'eastmoney.com'</span>]</span><br></pre></td></tr></table></figure>
<p>定义好GubaSpider类后，然后要指定开始网页start_urls和rules抓取网页规则。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">start_urls = [</span><br><span class="line">    <span class="string">'http://guba.eastmoney.com/default_%d.html'</span> % index <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">rules = (</span><br><span class="line">    <span class="comment"># 提取匹配 文章 的链接并使用spider的parse_article方法进行分析</span></span><br><span class="line">    Rule(LinkExtractor(allow=(<span class="string">r'^http://guba.eastmoney.com/news.'</span>, )), callback=<span class="string">'parse_article'</span>),</span><br><span class="line"></span><br><span class="line">    Rule(LinkExtractor(allow=(<span class="string">r'^http://iguba.eastmoney.com/\d+.'</span>,)), callback=<span class="string">'parse_auther'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="python" scheme="http://www.kekefund.com/tags/python/"/>
    
      <category term="scrapy" scheme="http://www.kekefund.com/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pandas数据分析基础]]></title>
    <link href="http://www.kekefund.com/2016/02/23/pandas-anlysis-basic/"/>
    <id>http://www.kekefund.com/2016/02/23/pandas-anlysis-basic/</id>
    <published>2016-02-23T02:27:49.000Z</published>
    <updated>2016-03-07T02:17:39.000Z</updated>
    <content type="html"><![CDATA[<p>使用pandas，首先导入包：</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h1 id="一、创建Series，DataFrame">一、创建Series，DataFrame</h1><h2 id="1，创建Series">1，创建Series</h2><h3 id="a，通过列表创建">a，通过列表创建</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>]) </span><br><span class="line">obj2 = Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>], index=[<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'c'</span>]) <span class="preprocessor">#指定索引</span></span><br></pre></td></tr></table></figure>
<h3 id="b，通过字典创建Series">b，通过字典创建Series</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">sdata = <span class="value">&#123;<span class="string">'Ohio'</span>:<span class="number">35000</span>, <span class="string">'Texas'</span>:<span class="number">7100</span>, <span class="string">'Oregon'</span>:<span class="number">1600</span>,<span class="string">'Utah'</span>:<span class="number">500</span>&#125;</span></span></span><br><span class="line"><span class="setting">obj3 = <span class="value">Series(sdata)</span></span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="c，通过字典_+_索引">c，通过字典 + 索引</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">states = [<span class="string">'California'</span>, <span class="string">'Ohio'</span>, <span class="string">'Oregon'</span>, <span class="string">'Texas'</span>]</span><br><span class="line">obj4 = <span class="function"><span class="title">Series</span><span class="params">(sdata, index=states)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>指定索引时，跟states索引匹配的那3个值会被找出并放到相应的位置，‘California’对应的sdata值找不到，其结果为NaN。</p>
</blockquote>
<h2 id="2，创建DataFrame">2，创建DataFrame</h2><h3 id="a，词典生成">a，词典生成</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> = &#123;<span class="string">'state'</span>:[<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>,<span class="string">'Nevada'</span>],</span><br><span class="line">        <span class="string">'year'</span>:[<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2011</span>, <span class="number">2002</span>],</span><br><span class="line">        <span class="string">'pop'</span>:[<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>]&#125;</span><br><span class="line">frame = DataFrame(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">frame2 = DataFrame(<span class="keyword">data</span>, columns=[<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>]) <span class="comment">#指定列</span></span><br><span class="line">frame3 = DataFrame(<span class="keyword">data</span>, columns=[<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>]，</span><br><span class="line">         index=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>]) <span class="comment">#指定列和索引</span></span><br></pre></td></tr></table></figure>
<h3 id="b，列表生成">b，列表生成</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; errors = [('c',<span class="number">1</span>,'right'), ('b', <span class="number">2</span>,'wrong')]</span><br><span class="line">&gt;&gt;&gt; df = pd.<span class="type">DataFrame</span>(errors)</span><br><span class="line">&gt;&gt;&gt; df</span><br><span class="line">   <span class="number">0</span>  <span class="number">1</span>      <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  c  <span class="number">1</span>  right</span><br><span class="line"><span class="number">1</span>  b  <span class="number">2</span>  wrong</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; df = pd.<span class="type">DataFrame</span>(errors, columns=['name', 'count', '<span class="literal">result</span>'])  <span class="comment">#指定列名</span></span><br><span class="line">&gt;&gt;&gt; df</span><br><span class="line">  name  count <span class="literal">result</span></span><br><span class="line"><span class="number">0</span>    c      <span class="number">1</span>  right</span><br><span class="line"><span class="number">1</span>    b      <span class="number">2</span>  wrong</span><br></pre></td></tr></table></figure>
<h3 id="c,_嵌套词典（也就是词典的词典）">c, 嵌套词典（也就是词典的词典）</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pop = &#123;'Nevada':&#123;<span class="number">2001:2.4</span>, <span class="number">2002:2.9</span>&#125;,</span><br><span class="line">       'Ohio':&#123;<span class="number">2000:1.5</span>, <span class="number">2001:1.7</span>, <span class="number">2002:3.6</span>&#125;&#125;</span><br><span class="line">frame4 = DataFrame(pop)</span><br><span class="line">Out[138]:</span><br><span class="line">      Nevada  Ohio</span><br><span class="line">2000     NaN   1.5</span><br><span class="line">2001     2.4   1.7</span><br><span class="line">2002     2.9   3.6</span><br></pre></td></tr></table></figure>
<h3 id="d，Series组合">d，Series组合</h3><h4 id="按行生成DataFrame">按行生成DataFrame</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: a = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) </span><br><span class="line">In [<span class="number">5</span>]: b = pd.Series([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">In [<span class="number">6</span>]: c = pd.DataFrame([a,b]) </span><br><span class="line">In [<span class="number">7</span>]: c</span><br><span class="line">Out[<span class="number">7</span>]:</span><br><span class="line">   <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h4 id="按列生成DataFrame">按列生成DataFrame</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: c = pd.DataFrame(&#123;<span class="string">'a'</span>:a,<span class="string">'b'</span>:b&#125;)</span><br><span class="line">In [<span class="number">9</span>]: c</span><br><span class="line">Out[<span class="number">9</span>]:</span><br><span class="line">   a  b</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h1 id="二，选取">二，选取</h1><p>对于一组数据DataFrame：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="function"><span class="title">DataFrame</span><span class="params">(np.arange(<span class="number">16</span>)</span></span>.<span class="function"><span class="title">reshape</span><span class="params">((<span class="number">4</span>,<span class="number">4</span>)</span></span>),index=[<span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>,<span class="string">'Utah'</span>,<span class="string">'New York'</span>],<span class="attribute">columns</span>=[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>,<span class="string">'four'</span>])</span><br><span class="line">&gt;&gt;&gt; data</span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure>
<h2 id="1，选取列，返回一个Series">1，选取列，返回一个Series</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; data[<span class="string">'two'</span>]</span><br><span class="line"><span class="constant">Ohio</span>         <span class="number">1</span></span><br><span class="line"><span class="constant">Colorado</span>     <span class="number">5</span></span><br><span class="line"><span class="constant">Utah</span>         <span class="number">9</span></span><br><span class="line"><span class="constant">New</span> <span class="constant">York</span>    <span class="number">13</span></span><br><span class="line"><span class="constant">Name</span><span class="symbol">:</span> two, <span class="symbol">dtype:</span> int64</span><br></pre></td></tr></table></figure>
<h2 id="2，选取行，返回一个Series">2，选取行，返回一个Series</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; data.ix[<span class="string">'Ohio'</span>]</span><br><span class="line"><span class="constant">one</span>      <span class="number">0</span></span><br><span class="line"><span class="constant">two</span>      <span class="number">1</span></span><br><span class="line"><span class="constant">three</span>    <span class="number">2</span></span><br><span class="line"><span class="constant">four</span>     <span class="number">3</span></span><br><span class="line">Name: Ohio, dtype: int64</span><br></pre></td></tr></table></figure>
<h2 id="3，_选取行和列,_可以是行名，列名，或列的序号">3， 选取行和列, 可以是行名，列名，或列的序号</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; data.ix[<span class="string">'Ohio'</span>, [<span class="string">'two'</span>,<span class="string">'three'</span>]]</span><br><span class="line">two      <span class="number">1</span></span><br><span class="line">three    <span class="number">2</span></span><br><span class="line"><span class="constant">Name</span><span class="symbol">:</span> <span class="constant">Ohio</span>, <span class="symbol">dtype:</span> int64</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; data.ix[data.three &gt; <span class="number">3</span>, :<span class="number">3</span>]</span><br><span class="line">          one  two  three</span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span></span><br></pre></td></tr></table></figure>
<h1 id="三、遍历与汇总">三、遍历与汇总</h1><h2 id="1，按行遍历">1，按行遍历</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ix, row <span class="keyword">in</span> df.<span class="function"><span class="title">iterrows</span><span class="params">()</span></span>:</span><br></pre></td></tr></table></figure>
<h2 id="2，按列遍历">2，按列遍历</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ix, col <span class="keyword">in</span> df.<span class="function"><span class="title">iteritems</span><span class="params">()</span></span>:</span><br></pre></td></tr></table></figure>
<h2 id="3，汇总">3，汇总</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">95</span>]: frame = DataFrame(&#123;<span class="string">'b'</span>:[<span class="number">4</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>], <span class="string">'a'</span>:[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</span><br><span class="line">In[<span class="number">99</span>]: frame.sum()</span><br><span class="line">Out[<span class="number">99</span>]: </span><br><span class="line">a     <span class="number">2</span></span><br><span class="line">b    <span class="number">10</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h1 id="四、排序">四、排序</h1><h2 id="1，对索引排序">1，对索引排序</h2><p>对轴索引排序</p>
<p>Series用sort_index()按索引排序，sort()按值排序；</p>
<p>DataFrame用sort_index()和sort()是一样的。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">73</span>]: obj = <span class="function"><span class="title">Series</span><span class="params">(range(<span class="number">4</span>)</span></span>, index=[<span class="string">'d'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br><span class="line">In[<span class="number">74</span>]: obj.<span class="function"><span class="title">sort_index</span><span class="params">()</span></span>  </span><br><span class="line">Out[<span class="number">74</span>]: </span><br><span class="line"><span class="tag">a</span>    <span class="number">1</span></span><br><span class="line"><span class="tag">b</span>    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">d    <span class="number">0</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line">In[<span class="number">78</span>]: frame = <span class="function"><span class="title">DataFrame</span><span class="params">(np.arange(<span class="number">8</span>)</span></span>.<span class="function"><span class="title">reshape</span><span class="params">((<span class="number">2</span>,<span class="number">4</span>)</span></span>),index=[<span class="string">'three'</span>, <span class="string">'one'</span>],<span class="attribute">columns</span>=[<span class="string">'d'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br><span class="line">In[<span class="number">79</span>]: frame</span><br><span class="line">Out[<span class="number">79</span>]: </span><br><span class="line">       d  <span class="tag">a</span>  <span class="tag">b</span>  c</span><br><span class="line">three  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line">one    <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line"></span><br><span class="line">In[<span class="number">86</span>]: frame.<span class="function"><span class="title">sort_index</span><span class="params">()</span></span></span><br><span class="line">Out[<span class="number">86</span>]: </span><br><span class="line">       d  <span class="tag">a</span>  <span class="tag">b</span>  c</span><br><span class="line">one    <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line">three  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In[<span class="number">87</span>]: frame.<span class="function"><span class="title">sort</span><span class="params">()</span></span></span><br><span class="line">Out[<span class="number">87</span>]: </span><br><span class="line">       d  <span class="tag">a</span>  <span class="tag">b</span>  c</span><br><span class="line">one    <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line">three  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="2，按行排序">2，按行排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">89</span>]: frame.sort_index(axis=<span class="number">1</span>, ascending=False)</span><br><span class="line">Out[<span class="number">89</span>]: </span><br><span class="line">       d  c  b  a</span><br><span class="line">three  <span class="number">0</span>  <span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line">one    <span class="number">4</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="3，按列排序（只针对Series）">3，按列排序（只针对Series）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">90</span>]: obj.sort()</span><br><span class="line">In[<span class="number">91</span>]: obj</span><br><span class="line">Out[<span class="number">91</span>]: </span><br><span class="line">d    <span class="number">0</span></span><br><span class="line">a    <span class="number">1</span></span><br><span class="line">b    <span class="number">2</span></span><br><span class="line">c    <span class="number">3</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h2 id="4，按值排序">4，按值排序</h2><p>Series:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">92</span>]: obj = Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">In[<span class="number">94</span>]: obj.order()</span><br><span class="line">Out[<span class="number">94</span>]: </span><br><span class="line"><span class="number">2</span>   -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>    <span class="number">2</span></span><br><span class="line"><span class="number">0</span>    <span class="number">4</span></span><br><span class="line"><span class="number">1</span>    <span class="number">7</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>DataFrame:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">95</span>]: frame = DataFrame(&#123;<span class="string">'b'</span>:[<span class="number">4</span>, <span class="number">7</span>, -<span class="number">3</span>, <span class="number">2</span>], <span class="string">'a'</span>:[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</span><br><span class="line">In[<span class="number">97</span>]: frame.sort_index(by=<span class="string">'b'</span>)</span><br><span class="line">Out[<span class="number">97</span>]: </span><br><span class="line">   a  b</span><br><span class="line"><span class="number">2</span>  <span class="number">0</span> -<span class="number">3</span></span><br><span class="line"><span class="number">3</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>  <span class="number">1</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure>
<h1 id="五、删除">五、删除</h1><h2 id="1，删除指定轴上的项">1，删除指定轴上的项</h2><p>即删除 Series 的元素或 DataFrame 的某一行（列）的意思，通过对象的 .drop(labels, axis=0) 方法：</p>
<p>删除Series的一个元素:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">11</span>]: ser = Series([<span class="number">4.5</span>,<span class="number">7.2</span>,-<span class="number">5.3</span>,<span class="number">3.6</span>], index=[<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'c'</span>])</span><br><span class="line">In[<span class="number">13</span>]: ser.drop(<span class="string">'c'</span>)</span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line">d    <span class="number">4.5</span></span><br><span class="line">b    <span class="number">7.2</span></span><br><span class="line">a   -<span class="number">5.3</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>删除DataFrame的行或列：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">17</span>]: df = <span class="function"><span class="title">DataFrame</span><span class="params">(np.arange(<span class="number">9</span>)</span></span>.<span class="function"><span class="title">reshape</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>, index=[<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>], <span class="attribute">columns</span>=[<span class="string">'oh'</span>,<span class="string">'te'</span>,<span class="string">'ca'</span>])</span><br><span class="line">In[<span class="number">18</span>]: df</span><br><span class="line">Out[<span class="number">18</span>]: </span><br><span class="line">   oh  te  ca</span><br><span class="line"><span class="tag">a</span>   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">c   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">d   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span></span><br><span class="line"></span><br><span class="line">In[<span class="number">19</span>]: df.<span class="function"><span class="title">drop</span><span class="params">(<span class="string">'a'</span>)</span></span></span><br><span class="line">Out[<span class="number">19</span>]: </span><br><span class="line">   oh  te  ca</span><br><span class="line">c   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">d   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span></span><br><span class="line"></span><br><span class="line">In[<span class="number">20</span>]: df.<span class="function"><span class="title">drop</span><span class="params">([<span class="string">'oh'</span>,<span class="string">'te'</span>],axis=<span class="number">1</span>)</span></span></span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">   ca</span><br><span class="line"><span class="tag">a</span>   <span class="number">2</span></span><br><span class="line">c   <span class="number">5</span></span><br><span class="line">d   <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>.drop() 返回的是一个新对象，元对象不会被改变。</p>
<h1 id="六、DataFrame连接">六、DataFrame连接</h1><h2 id="1，算术运算（+，-，*，/）">1，算术运算（+，-，*，/）</h2><p>是df中对应位置的元素的算术运算</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">5</span>]: df1 = <span class="function"><span class="title">DataFrame</span><span class="params">(np.arange(<span class="number">12</span>.)</span></span>.<span class="function"><span class="title">reshape</span><span class="params">((<span class="number">3</span>,<span class="number">4</span>)</span></span>),<span class="attribute">columns</span>=<span class="function"><span class="title">list</span><span class="params">(<span class="string">'abcd'</span>)</span></span>)</span><br><span class="line"></span><br><span class="line">In[<span class="number">6</span>]: df2 = <span class="function"><span class="title">DataFrame</span><span class="params">(np.arange(<span class="number">20</span>.)</span></span>.<span class="function"><span class="title">reshape</span><span class="params">((<span class="number">4</span>,<span class="number">5</span>)</span></span>),<span class="attribute">columns</span>=<span class="function"><span class="title">list</span><span class="params">(<span class="string">'abcde'</span>)</span></span>)</span><br><span class="line"></span><br><span class="line">In[<span class="number">9</span>]: df1+df2</span><br><span class="line">Out[<span class="number">9</span>]: </span><br><span class="line">    <span class="tag">a</span>   <span class="tag">b</span>   c   d   e</span><br><span class="line"><span class="number">0</span>   <span class="number">0</span>   <span class="number">2</span>   <span class="number">4</span>   <span class="number">6</span> NaN</span><br><span class="line"><span class="number">1</span>   <span class="number">9</span>  <span class="number">11</span>  <span class="number">13</span>  <span class="number">15</span> NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">18</span>  <span class="number">20</span>  <span class="number">22</span>  <span class="number">24</span> NaN</span><br><span class="line"><span class="number">3</span> NaN NaN NaN NaN NaN</span><br></pre></td></tr></table></figure>
<p>传入填充值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">11</span>]: df1.add(df2, fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">    a   b   c   d   e</span><br><span class="line"><span class="number">0</span>   <span class="number">0</span>   <span class="number">2</span>   <span class="number">4</span>   <span class="number">6</span>   <span class="number">4</span></span><br><span class="line"><span class="number">1</span>   <span class="number">9</span>  <span class="number">11</span>  <span class="number">13</span>  <span class="number">15</span>   <span class="number">9</span></span><br><span class="line"><span class="number">2</span>  <span class="number">18</span>  <span class="number">20</span>  <span class="number">22</span>  <span class="number">24</span>  <span class="number">14</span></span><br><span class="line"><span class="number">3</span>  <span class="number">15</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span></span><br></pre></td></tr></table></figure>
<h2 id="2，pandas-merge">2，pandas.merge</h2><p>pandas.merge可根据一个或多个键将不同DataFrame中的行连接起来。</p>
<p>默认情况下，merge做的是“inner”连接，结果中的键是交集，其它方式还有“left”，“right”，“outer”。“outer”外连接求取的是键的并集，组合了左连接和右连接。</p>
<h3 id="内连接">内连接</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">In[14]</span>: <span class="string">df1 = DataFrame(&#123;'key':['b','b','a','c','a','a','b'],'data1':range(7)&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">In[15]</span>: <span class="string">df2 = DataFrame(&#123;'key':['a','b','d'],'data2':range(3)&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="stylus">In[<span class="number">18</span>]: pd.<span class="function"><span class="title">merge</span><span class="params">(df1, df2)</span></span>  #或显式: pd.<span class="function"><span class="title">merge</span><span class="params">(df1, df2, on=<span class="string">'key'</span>)</span></span></span><br><span class="line">Out[<span class="number">18</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   <span class="tag">b</span>      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   <span class="tag">b</span>      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>   <span class="tag">b</span>      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>   <span class="tag">a</span>      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   <span class="tag">a</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   <span class="tag">a</span>      <span class="number">0</span></span></span></span><br></pre></td></tr></table></figure>
<h3 id="外连接">外连接</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">19</span>]: pd.<span class="function"><span class="title">merge</span><span class="params">(df1, df2, how=<span class="string">'outer'</span>)</span></span></span><br><span class="line">Out[<span class="number">19</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   <span class="tag">b</span>      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   <span class="tag">b</span>      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>   <span class="tag">b</span>      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>   <span class="tag">a</span>      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   <span class="tag">a</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   <span class="tag">a</span>      <span class="number">0</span></span><br><span class="line"><span class="number">6</span>      <span class="number">3</span>   c    NaN</span><br><span class="line"><span class="number">7</span>    NaN   d      <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="轴向连接">轴向连接</h3><p>这种数据合并运算被称为连接（concatenation）、绑定（binding）或堆叠（stacking）。</p>
<p>对于Series</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">23</span>]: s1 = Series([<span class="number">0</span>, <span class="number">1</span>], index=[<span class="string">'a'</span>,<span class="string">'b'</span>])</span><br><span class="line">In[<span class="number">24</span>]: s2 = Series([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>])</span><br><span class="line">In[<span class="number">25</span>]: s3 = Series([<span class="number">5</span>, <span class="number">6</span>], index=[<span class="string">'f'</span>,<span class="string">'g'</span>])</span><br><span class="line"></span><br><span class="line">In[<span class="number">26</span>]: pd.concat([s1,s2,s3])</span><br><span class="line">Out[<span class="number">26</span>]: </span><br><span class="line">a    <span class="number">0</span></span><br><span class="line">b    <span class="number">1</span></span><br><span class="line">c    <span class="number">2</span></span><br><span class="line">d    <span class="number">3</span></span><br><span class="line">e    <span class="number">4</span></span><br><span class="line">f    <span class="number">5</span></span><br><span class="line">g    <span class="number">6</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p>默认情况下，concat是在axis=0（行）上工作的，最终产生一个新的Series。如果传入axis=1（列），则变成一个DataFrame。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span>[<span class="number">27</span>]: pd.concat([s1,s2,s3], axis=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">Out</span>[<span class="number">27</span>]: </span><br><span class="line">    <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">a   <span class="number">0</span> <span class="built_in">NaN</span> <span class="built_in">NaN</span></span><br><span class="line">b   <span class="number">1</span> <span class="built_in">NaN</span> <span class="built_in">NaN</span></span><br><span class="line">c <span class="built_in">NaN</span>   <span class="number">2</span> <span class="built_in">NaN</span></span><br><span class="line">d <span class="built_in">NaN</span>   <span class="number">3</span> <span class="built_in">NaN</span></span><br><span class="line">e <span class="built_in">NaN</span>   <span class="number">4</span> <span class="built_in">NaN</span></span><br><span class="line">f <span class="built_in">NaN</span> <span class="built_in">NaN</span>   <span class="number">5</span></span><br><span class="line">g <span class="built_in">NaN</span> <span class="built_in">NaN</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>DataFrame连接</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dfs = []</span><br><span class="line"><span class="keyword">for</span> classify <span class="keyword">in</span> classify_finance + classify_other:</span><br><span class="line">    sql = <span class="string">"select classify, tags from &#123;&#125; where classify='&#123;&#125;' length(tags)&gt;0 limit 1000"</span>.<span class="function"><span class="title">format</span><span class="params">(mysql_table_sina_news_all, classify)</span></span></span><br><span class="line">    df = pd.<span class="function"><span class="title">read_sql</span><span class="params">(sql,engine)</span></span></span><br><span class="line">    dfs.<span class="function"><span class="title">append</span><span class="params">(df)</span></span></span><br><span class="line">df_all = pd.<span class="function"><span class="title">concat</span><span class="params">(dfs, ignore_index=True)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="七、数据转换">七、数据转换</h1><p>数据过滤、清理以及其他的转换工作。</p>
<h2 id="1，移除重复数据（去重）">1，移除重复数据（去重）</h2><h3 id="duplicated()">duplicated()</h3><p>DataFrame的duplicated方法返回一个布尔型Series，表示各行是否是重复行：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">In[12]</span>: <span class="string">df = DataFrame(&#123;'k1':['one']*3 + ['two']*4, 'k2':[1,1,2,3,3,4,4]&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="cpp">In[<span class="number">13</span>]: df</span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line">    k1  k2</span><br><span class="line"><span class="number">0</span>  one   <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  one   <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  one   <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  two   <span class="number">3</span></span><br><span class="line"><span class="number">4</span>  two   <span class="number">3</span></span><br><span class="line"><span class="number">5</span>  two   <span class="number">4</span></span><br><span class="line"><span class="number">6</span>  two   <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In[<span class="number">14</span>]: df.duplicated()</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line"><span class="number">0</span>    False</span><br><span class="line"><span class="number">1</span>     True</span><br><span class="line"><span class="number">2</span>    False</span><br><span class="line"><span class="number">3</span>    False</span><br><span class="line"><span class="number">4</span>     True</span><br><span class="line"><span class="number">5</span>    False</span><br><span class="line"><span class="number">6</span>     True</span><br><span class="line">dtype: <span class="keyword">bool</span></span></span><br></pre></td></tr></table></figure>
<h3 id="drop_duplicates()">drop_duplicates()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">15</span>]: df.drop_duplicates()</span><br><span class="line">Out[<span class="number">15</span>]: </span><br><span class="line">    k1  k2</span><br><span class="line"><span class="number">0</span>  one   <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  one   <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  two   <span class="number">3</span></span><br><span class="line"><span class="number">5</span>  two   <span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="2，利用函数或映射进行数据转换">2，利用函数或映射进行数据转换</h2><p>对于数据:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">In[16]</span>: <span class="string">df = DataFrame(&#123;'food':['bacon','pulled pork','bacon','Pastraml','corned beef', 'Bacon', 'pastraml','honey ham','nova lox'],'ounces':[4,3,12,6,7.5,8,3,5,6]&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="cpp">In[<span class="number">17</span>]: df</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line">          food  ounces</span><br><span class="line"><span class="number">0</span>        bacon     <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>  pulled pork     <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>        bacon    <span class="number">12.0</span></span><br><span class="line"><span class="number">3</span>     Pastraml     <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>  corned beef     <span class="number">7.5</span></span><br><span class="line"><span class="number">5</span>        Bacon     <span class="number">8.0</span></span><br><span class="line"><span class="number">6</span>     pastraml     <span class="number">3.0</span></span><br><span class="line"><span class="number">7</span>    honey ham     <span class="number">5.0</span></span><br><span class="line"><span class="number">8</span>     nova lox     <span class="number">6.0</span></span></span><br></pre></td></tr></table></figure>
<p>增加一列表示该肉类食物来源的动物类型，先编写一个肉类到动物的映射：</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">In</span>[<span class="number">18</span>]: meat_to_animal = &#123;<span class="symbol">'bacon'</span>:<span class="symbol">'pig'</span>,</span><br><span class="line">    <span class="symbol">'pulled</span> pork':<span class="symbol">'pig'</span>,</span><br><span class="line">    <span class="symbol">'pastraml'</span>:<span class="symbol">'cow'</span>,</span><br><span class="line">    <span class="symbol">'corned</span> beef':<span class="symbol">'cow'</span>,</span><br><span class="line">    <span class="symbol">'honey</span> ham':<span class="symbol">'pig'</span>,</span><br><span class="line">    <span class="symbol">'nova</span> lox':<span class="symbol">'salmon'</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map">map</h3><p>Series的map方法可以接受一个函数或含有映射关系的字典型对象。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">20</span>]: df[<span class="string">'animal'</span>] = df[<span class="string">'food'</span>].<span class="function"><span class="title">map</span><span class="params">(str.lower)</span></span>.<span class="function"><span class="title">map</span><span class="params">(meat_to_animal)</span></span></span><br><span class="line">In[<span class="number">21</span>]: df</span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">          food  ounces  animal</span><br><span class="line"><span class="number">0</span>        bacon     <span class="number">4.0</span>     pig</span><br><span class="line"><span class="number">1</span>  pulled pork     <span class="number">3.0</span>     pig</span><br><span class="line"><span class="number">2</span>        bacon    <span class="number">12.0</span>     pig</span><br><span class="line"><span class="number">3</span>     Pastraml     <span class="number">6.0</span>     cow</span><br><span class="line"><span class="number">4</span>  corned beef     <span class="number">7.5</span>     cow</span><br><span class="line"><span class="number">5</span>        Bacon     <span class="number">8.0</span>     pig</span><br><span class="line"><span class="number">6</span>     pastraml     <span class="number">3.0</span>     cow</span><br><span class="line"><span class="number">7</span>    honey ham     <span class="number">5.0</span>     pig</span><br><span class="line"><span class="number">8</span>     nova lox     <span class="number">6.0</span>  salmon</span><br></pre></td></tr></table></figure>
<p>也可传入一个函数，一次性处理：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">In</span><span class="attr_selector">[22]</span>: <span class="tag">df</span><span class="attr_selector">['food']</span><span class="class">.map</span>(<span class="tag">lambda</span> <span class="tag">x</span> : <span class="tag">meat_to_animal</span><span class="attr_selector">[x.lower()]</span>)</span><br><span class="line"><span class="tag">Out</span><span class="attr_selector">[22]</span>: </span><br><span class="line">0       <span class="tag">pig</span></span><br><span class="line">1       <span class="tag">pig</span></span><br><span class="line">2       <span class="tag">pig</span></span><br><span class="line">3       <span class="tag">cow</span></span><br><span class="line">4       <span class="tag">cow</span></span><br><span class="line">5       <span class="tag">pig</span></span><br><span class="line">6       <span class="tag">cow</span></span><br><span class="line">7       <span class="tag">pig</span></span><br><span class="line">8    <span class="tag">salmon</span></span><br><span class="line"><span class="tag">Name</span>: <span class="tag">food</span>, <span class="tag">dtype</span>: <span class="tag">object</span></span><br></pre></td></tr></table></figure>
<h3 id="apply_和_applymap">apply 和 applymap</h3><p>对于DataFrame：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">In[21]</span>: <span class="string">df = DataFrame(np.random.randn(4,3), columns=list('bde'),index=['Utah','Ohio','Texas','Oregon'])</span></span><br><span class="line"></span><br><span class="line"><span class="cpp">In[<span class="number">22</span>]: df</span><br><span class="line">Out[<span class="number">22</span>]: </span><br><span class="line">               b         d         e</span><br><span class="line">Utah    <span class="number">1.654850</span>  <span class="number">0.594738</span> -<span class="number">1.969539</span></span><br><span class="line">Ohio    <span class="number">2.178748</span>  <span class="number">1.127218</span>  <span class="number">0.451690</span></span><br><span class="line">Texas   <span class="number">1.209098</span> -<span class="number">0.604432</span> -<span class="number">1.178433</span></span><br><span class="line">Oregon  <span class="number">0.286382</span>  <span class="number">0.042102</span> -<span class="number">0.345722</span></span></span><br></pre></td></tr></table></figure>
<p>apply将函数应用到由各列或行所形成的一维数组上。</p>
<p><strong>作用到列：</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">24</span>]: f = lambda x : x.<span class="function"><span class="title">max</span><span class="params">()</span></span> - x.<span class="function"><span class="title">min</span><span class="params">()</span></span></span><br><span class="line">In[<span class="number">25</span>]: df.<span class="function"><span class="title">apply</span><span class="params">(f)</span></span></span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line"><span class="tag">b</span>    <span class="number">1.892366</span></span><br><span class="line">d    <span class="number">1.731650</span></span><br><span class="line">e    <span class="number">2.421229</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p><strong>作用到行/轴：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">26</span>]: df.apply(f, axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">26</span>]: </span><br><span class="line">Utah      <span class="number">3.624390</span></span><br><span class="line">Ohio      <span class="number">1.727058</span></span><br><span class="line">Texas     <span class="number">2.387531</span></span><br><span class="line">Oregon    <span class="number">0.632104</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p><strong>作用到每个元素：</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">70</span>]: frame = <span class="function"><span class="title">DataFrame</span><span class="params">(np.random.randn(<span class="number">4</span>,<span class="number">3</span>)</span></span>, <span class="attribute">columns</span>=<span class="function"><span class="title">list</span><span class="params">(<span class="string">'bde'</span>)</span></span>,index=[<span class="string">'Utah'</span>,<span class="string">'Ohio'</span>,<span class="string">'Texas'</span>,<span class="string">'Oregon'</span>])</span><br><span class="line"></span><br><span class="line">In[<span class="number">72</span>]: frame.<span class="function"><span class="title">applymap</span><span class="params">(lambda x : <span class="string">'%.2f'</span> % x)</span></span></span><br><span class="line">Out[<span class="number">72</span>]: </span><br><span class="line">            <span class="tag">b</span>      d      e</span><br><span class="line">Utah     <span class="number">1.19</span>   <span class="number">1.56</span>  -<span class="number">1.13</span></span><br><span class="line">Ohio     <span class="number">0.10</span>  -<span class="number">1.03</span>  -<span class="number">0.04</span></span><br><span class="line">Texas   -<span class="number">0.22</span>   <span class="number">0.77</span>  -<span class="number">0.73</span></span><br><span class="line">Oregon   <span class="number">0.22</span>  -<span class="number">2.06</span>  -<span class="number">1.25</span></span><br></pre></td></tr></table></figure>
<h3 id="numpy的ufuncs">numpy的ufuncs</h3><p>Numpy的ufuncs（元素级数组方法）也可用于操作pandas对象。</p>
<p>取绝对值操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">23</span>]: np.<span class="built_in">abs</span>(df)</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line">               b         d         e</span><br><span class="line">Utah    <span class="number">1.654850</span>  <span class="number">0.594738</span>  <span class="number">1.969539</span></span><br><span class="line">Ohio    <span class="number">2.178748</span>  <span class="number">1.127218</span>  <span class="number">0.451690</span></span><br><span class="line">Texas   <span class="number">1.209098</span>  <span class="number">0.604432</span>  <span class="number">1.178433</span></span><br></pre></td></tr></table></figure>
<h2 id="3，替换值">3，替换值</h2><p>替换的几种形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">23</span>]: se = Series([<span class="number">1</span>, -<span class="number">999</span>, <span class="number">2</span>, -<span class="number">999</span>, -<span class="number">1000</span>, <span class="number">3</span>])</span><br><span class="line">In[<span class="number">24</span>]: se.replace(-<span class="number">999</span>, np.nan)</span><br><span class="line">Out[<span class="number">24</span>]: </span><br><span class="line"><span class="number">0</span>       <span class="number">1</span></span><br><span class="line"><span class="number">1</span>     NaN</span><br><span class="line"><span class="number">2</span>       <span class="number">2</span></span><br><span class="line"><span class="number">3</span>     NaN</span><br><span class="line"><span class="number">4</span>   -<span class="number">1000</span></span><br><span class="line"><span class="number">5</span>       <span class="number">3</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In[<span class="number">25</span>]: se.replace([-<span class="number">999</span>, -<span class="number">1000</span>], np.nan)</span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>   NaN</span><br><span class="line"><span class="number">2</span>     <span class="number">2</span></span><br><span class="line"><span class="number">3</span>   NaN</span><br><span class="line"><span class="number">4</span>   NaN</span><br><span class="line"><span class="number">5</span>     <span class="number">3</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In[<span class="number">26</span>]: se.replace([-<span class="number">999</span>, -<span class="number">1000</span>], [np.nan, <span class="number">0</span>])</span><br><span class="line">Out[<span class="number">26</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>   NaN</span><br><span class="line"><span class="number">2</span>     <span class="number">2</span></span><br><span class="line"><span class="number">3</span>   NaN</span><br><span class="line"><span class="number">4</span>     <span class="number">0</span></span><br><span class="line"><span class="number">5</span>     <span class="number">3</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># 字典</span></span><br><span class="line">In[<span class="number">27</span>]: se.replace(&#123;-<span class="number">999</span>:np.nan, -<span class="number">1000</span>:<span class="number">0</span>&#125;)</span><br><span class="line">Out[<span class="number">27</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>   NaN</span><br><span class="line"><span class="number">2</span>     <span class="number">2</span></span><br><span class="line"><span class="number">3</span>   NaN</span><br><span class="line"><span class="number">4</span>     <span class="number">0</span></span><br><span class="line"><span class="number">5</span>     <span class="number">3</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h2 id="4，重命名轴索引、列名">4，重命名轴索引、列名</h2><p>对于数据:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">In[28]</span>: <span class="string">df = DataFrame(np.arange(12).reshape((3,4)), index = ['Ohio', 'Colorado', 'New York'], columns=['one','two','three', 'four'])</span></span><br><span class="line"></span><br><span class="line"><span class="cpp">In[<span class="number">29</span>]: df</span><br><span class="line">Out[<span class="number">29</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">New York    <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span></span><br></pre></td></tr></table></figure>
<p>就地修改轴索引</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">30</span>]: df.index = df.index.<span class="built_in">map</span>(str.upper)</span><br><span class="line">In[<span class="number">31</span>]: df</span><br><span class="line">Out[<span class="number">31</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">OHIO        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">COLORADO    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">NEW YORK    <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>如果要创建数据集的转换版（而不是修改原始数据），比较实用的方法是rename：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">32</span>]: df.rename(index=str.title, columns=str.upper)</span><br><span class="line">Out[<span class="number">32</span>]: </span><br><span class="line">          ONE  TWO  THREE  FOUR</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">New York    <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>特别说明一下，rename可以结合字典型对象实现对部分轴标签的更新：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">33</span>]: df.<span class="built_in">rename</span>(index=&#123;<span class="string">'OHIO'</span>:<span class="string">'INDIANA'</span>&#125;, columns=&#123;<span class="string">'three'</span>:<span class="string">'peekaboo'</span>&#125;)</span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">          <span class="constant">one</span>  <span class="constant">two</span>  peekaboo  <span class="constant">four</span></span><br><span class="line">INDIANA     <span class="number">0</span>    <span class="number">1</span>         <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">COLORADO    <span class="number">4</span>    <span class="number">5</span>         <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">NEW YORK    <span class="number">8</span>    <span class="number">9</span>        <span class="number">10</span>    <span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>如果希望就地修改某个数据集，传入inplace=True即可：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">34</span>]: _ = df.<span class="built_in">rename</span>(index=&#123;<span class="string">'OHIO'</span>:<span class="string">'INDIANA'</span>&#125;, inplace=True)</span><br><span class="line">In[<span class="number">35</span>]: df</span><br><span class="line">Out[<span class="number">35</span>]: </span><br><span class="line">          <span class="constant">one</span>  <span class="constant">two</span>  <span class="constant">three</span>  <span class="constant">four</span></span><br><span class="line">INDIANA     <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">COLORADO    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">NEW YORK    <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br></pre></td></tr></table></figure>
<h2 id="5，离散化和面元划分">5，离散化和面元划分</h2><h3 id="pd-cut">pd.cut</h3><p>为了便于分析，连续数据常常离散化或拆分为“面元”（bin）。比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">106</span>]: ages = [<span class="number">20</span>, <span class="number">22</span>,<span class="number">25</span>,<span class="number">27</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">37</span>,<span class="number">31</span>,<span class="number">61</span>,<span class="number">45</span>,<span class="number">41</span>,<span class="number">32</span>]</span><br></pre></td></tr></table></figure>
<p>需要将其划分为“18到25”,  “26到35”，“36到60”以及“60以上”几个面元。要实现该功能，需要使用pandas的cut函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n[<span class="number">37</span>]: bins = [<span class="number">18</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">60</span>, <span class="number">100</span>]</span><br><span class="line">In[<span class="number">38</span>]: cats = pd.cut(ages, bins)</span><br><span class="line">In[<span class="number">39</span>]: cats</span><br><span class="line">Out[<span class="number">39</span>]: </span><br><span class="line">[(<span class="number">18</span>, <span class="number">25</span>], (<span class="number">18</span>, <span class="number">25</span>], (<span class="number">18</span>, <span class="number">25</span>], (<span class="number">25</span>, <span class="number">35</span>], (<span class="number">18</span>, <span class="number">25</span>], ..., (<span class="number">25</span>, <span class="number">35</span>], (<span class="number">60</span>, <span class="number">100</span>], (<span class="number">35</span>, <span class="number">60</span>], (<span class="number">35</span>, <span class="number">60</span>], (<span class="number">25</span>, <span class="number">35</span>]]</span><br><span class="line">Length: <span class="number">12</span></span><br><span class="line">Categories (<span class="number">4</span>, object): [(<span class="number">18</span>, <span class="number">25</span>] &lt; (<span class="number">25</span>, <span class="number">35</span>] &lt; (<span class="number">35</span>, <span class="number">60</span>] &lt; (<span class="number">60</span>, <span class="number">100</span>]]</span><br></pre></td></tr></table></figure>
<p>可以通过right=False指定哪端是开区间或闭区间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">41</span>]: cats = pd.cut(ages, bins, right=False)</span><br><span class="line">In[<span class="number">42</span>]: cats</span><br><span class="line">Out[<span class="number">42</span>]: </span><br><span class="line">[[<span class="number">18</span>, <span class="number">25</span>), [<span class="number">18</span>, <span class="number">25</span>), [<span class="number">25</span>, <span class="number">35</span>), [<span class="number">25</span>, <span class="number">35</span>), [<span class="number">18</span>, <span class="number">25</span>), ..., [<span class="number">25</span>, <span class="number">35</span>), [<span class="number">60</span>, <span class="number">100</span>), [<span class="number">35</span>, <span class="number">60</span>), [<span class="number">35</span>, <span class="number">60</span>), [<span class="number">25</span>, <span class="number">35</span>)]</span><br><span class="line"></span><br><span class="line">Length: <span class="number">12</span></span><br><span class="line"></span><br><span class="line">Categories (<span class="number">4</span>, object): [[<span class="number">18</span>, <span class="number">25</span>) &lt; [<span class="number">25</span>, <span class="number">35</span>) &lt; [<span class="number">35</span>, <span class="number">60</span>) &lt; [<span class="number">60</span>, <span class="number">100</span>)]</span><br></pre></td></tr></table></figure>
<p>也可以指定面元的名称：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">In[43]</span>: <span class="string">group_name = ['Youth', 'YoungAdult', 'MiddleAged', 'Senior']</span></span><br><span class="line"></span><br><span class="line"><span class="cpp">In[<span class="number">45</span>]: cats = pd.cut(ages, bins, labels=group_name)</span><br><span class="line">In[<span class="number">47</span>]: cats</span><br><span class="line">Out[<span class="number">47</span>]: </span><br><span class="line">[Youth, Youth, Youth, YoungAdult, Youth, ..., YoungAdult, Senior, MiddleAged, MiddleAged, YoungAdult]</span><br><span class="line"></span><br><span class="line">Length: <span class="number">12</span></span><br><span class="line"></span><br><span class="line">Categories (<span class="number">4</span>, object): [Youth &lt; YoungAdult &lt; MiddleAged &lt; Senior]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In[<span class="number">46</span>]: pd.value_counts(cats)</span><br><span class="line">Out[<span class="number">46</span>]: </span><br><span class="line">Youth         <span class="number">5</span></span><br><span class="line">MiddleAged    <span class="number">3</span></span><br><span class="line">YoungAdult    <span class="number">3</span></span><br><span class="line">Senior        <span class="number">1</span></span><br><span class="line">dtype: int64</span></span><br></pre></td></tr></table></figure>
<h3 id="pd-qcut">pd.qcut</h3><p>qcut是一个非常类似cut的函数，它可以根据样本分位数对数据进行面元划分，根据数据的分布情况，cut可能无法使各个面元中含有相同数量的数据点，而qcut由于使用的是样本分位数，可以得到大小基本相等的面元。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">48</span>]: data = np.random.randn(<span class="number">1000</span>)</span><br><span class="line">In[<span class="number">49</span>]: cats = pd.qcut(data, <span class="number">4</span>)</span><br><span class="line">In[<span class="number">50</span>]: cats</span><br><span class="line">Out[<span class="number">50</span>]: </span><br><span class="line">[(<span class="number">0.577</span>, <span class="number">3.564</span>], (-<span class="number">0.729</span>, -<span class="number">0.0341</span>], (-<span class="number">0.729</span>, -<span class="number">0.0341</span>], (<span class="number">0.577</span>, <span class="number">3.564</span>], (<span class="number">0.577</span>, <span class="number">3.564</span>], ..., [-<span class="number">3.0316</span>, -<span class="number">0.729</span>], [-<span class="number">3.0316</span>, -<span class="number">0.729</span>], (-<span class="number">0.0341</span>, <span class="number">0.577</span>], [-<span class="number">3.0316</span>, -<span class="number">0.729</span>], (-<span class="number">0.0341</span>, <span class="number">0.577</span>]]</span><br><span class="line"></span><br><span class="line">Length: <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">Categories (<span class="number">4</span>, object): [[-<span class="number">3.0316</span>, -<span class="number">0.729</span>] &lt; (-<span class="number">0.729</span>, -<span class="number">0.0341</span>] &lt; (-<span class="number">0.0341</span>, <span class="number">0.577</span>] &lt; (<span class="number">0.577</span>, <span class="number">3.564</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In[<span class="number">51</span>]: pd.value_counts(cats)</span><br><span class="line">Out[<span class="number">51</span>]: </span><br><span class="line">(<span class="number">0.577</span>, <span class="number">3.564</span>]       <span class="number">250</span></span><br><span class="line">(-<span class="number">0.0341</span>, <span class="number">0.577</span>]     <span class="number">250</span></span><br><span class="line">(-<span class="number">0.729</span>, -<span class="number">0.0341</span>]    <span class="number">250</span></span><br><span class="line">[-<span class="number">3.0316</span>, -<span class="number">0.729</span>]    <span class="number">250</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<h2 id="6，检测和过滤异常值">6，检测和过滤异常值</h2><p>异常值（oulier）的过滤或变换运算在很大程度上其实就是数组运算。</p>
<p>对于数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">52</span>]: np.random.seed(<span class="number">12345</span>)</span><br><span class="line">In[<span class="number">53</span>]: data = DataFrame(np.random.randn(<span class="number">1000</span>,<span class="number">4</span>))</span><br><span class="line">In[<span class="number">54</span>]: data.describe()</span><br><span class="line">Out[<span class="number">54</span>]: </span><br><span class="line">                 <span class="number">0</span>            <span class="number">1</span>            <span class="number">2</span>            <span class="number">3</span></span><br><span class="line">count  <span class="number">1000.000000</span>  <span class="number">1000.000000</span>  <span class="number">1000.000000</span>  <span class="number">1000.000000</span></span><br><span class="line">mean     -<span class="number">0.067684</span>     <span class="number">0.067924</span>     <span class="number">0.025598</span>    -<span class="number">0.002298</span></span><br><span class="line"><span class="built_in">std</span>       <span class="number">0.998035</span>     <span class="number">0.992106</span>     <span class="number">1.006835</span>     <span class="number">0.996794</span></span><br><span class="line">min      -<span class="number">3.428254</span>    -<span class="number">3.548824</span>    -<span class="number">3.184377</span>    -<span class="number">3.745356</span></span><br><span class="line"><span class="number">25</span>%      -<span class="number">0.774890</span>    -<span class="number">0.591841</span>    -<span class="number">0.641675</span>    -<span class="number">0.644144</span></span><br><span class="line"><span class="number">50</span>%      -<span class="number">0.116401</span>     <span class="number">0.101143</span>     <span class="number">0.002073</span>    -<span class="number">0.013611</span></span><br><span class="line"><span class="number">75</span>%       <span class="number">0.616366</span>     <span class="number">0.780282</span>     <span class="number">0.680391</span>     <span class="number">0.654328</span></span><br><span class="line">max       <span class="number">3.366626</span>     <span class="number">2.653656</span>     <span class="number">3.260383</span>     <span class="number">3.927528</span></span><br></pre></td></tr></table></figure>
<p>找出某列绝对值大于3的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">55</span>]: col = data[<span class="number">3</span>]</span><br><span class="line">In[<span class="number">56</span>]: col[np.<span class="built_in">abs</span>(col) &gt; <span class="number">3</span>]</span><br><span class="line">Out[<span class="number">56</span>]: </span><br><span class="line"><span class="number">97</span>     <span class="number">3.927528</span></span><br><span class="line"><span class="number">305</span>   -<span class="number">3.399312</span></span><br><span class="line"><span class="number">400</span>   -<span class="number">3.745356</span></span><br><span class="line">Name: <span class="number">3</span>, dtype: float64</span><br></pre></td></tr></table></figure>
<p>要选出全部含有“超过3或-3的值”的行，可以利用布尔型DataFrame以及any方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">60</span>]: data[(np.<span class="built_in">abs</span>(data)&gt;<span class="number">3</span>).any(<span class="number">1</span>)]</span><br><span class="line">Out[<span class="number">60</span>]: </span><br><span class="line">            <span class="number">0</span>         <span class="number">1</span>         <span class="number">2</span>         <span class="number">3</span></span><br><span class="line"><span class="number">5</span>   -<span class="number">0.539741</span>  <span class="number">0.476985</span>  <span class="number">3.248944</span> -<span class="number">1.021228</span></span><br><span class="line"><span class="number">97</span>  -<span class="number">0.774363</span>  <span class="number">0.552936</span>  <span class="number">0.106061</span>  <span class="number">3.927528</span></span><br><span class="line"><span class="number">102</span> -<span class="number">0.655054</span> -<span class="number">0.565230</span>  <span class="number">3.176873</span>  <span class="number">0.959533</span></span><br><span class="line"><span class="number">305</span> -<span class="number">2.315555</span>  <span class="number">0.457246</span> -<span class="number">0.025907</span> -<span class="number">3.399312</span></span><br><span class="line"><span class="number">324</span>  <span class="number">0.050188</span>  <span class="number">1.951312</span>  <span class="number">3.260383</span>  <span class="number">0.963301</span></span><br><span class="line"><span class="number">400</span>  <span class="number">0.146326</span>  <span class="number">0.508391</span> -<span class="number">0.196713</span> -<span class="number">3.745356</span></span><br><span class="line"><span class="number">499</span> -<span class="number">0.293333</span> -<span class="number">0.242459</span> -<span class="number">3.056990</span>  <span class="number">1.918403</span></span><br><span class="line"><span class="number">523</span> -<span class="number">3.428254</span> -<span class="number">0.296336</span> -<span class="number">0.439938</span> -<span class="number">0.867165</span></span><br><span class="line"><span class="number">586</span>  <span class="number">0.275144</span>  <span class="number">1.179227</span> -<span class="number">3.184377</span>  <span class="number">1.369891</span></span><br><span class="line"><span class="number">808</span> -<span class="number">0.362528</span> -<span class="number">3.548824</span>  <span class="number">1.553205</span> -<span class="number">2.186301</span></span><br><span class="line"><span class="number">900</span>  <span class="number">3.366626</span> -<span class="number">2.372214</span>  <span class="number">0.851010</span>  <span class="number">1.332846</span></span><br></pre></td></tr></table></figure>
<p>根据这些条件，可以轻松对值进行设置，下面代码将值限制在区间-3到3以内：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">62</span>]: data[np.<span class="built_in">abs</span>(data)&gt;<span class="number">3</span>] = np.sign(data)*<span class="number">3</span></span><br><span class="line">In[<span class="number">63</span>]: data.describe()</span><br><span class="line">Out[<span class="number">63</span>]: </span><br><span class="line">                 <span class="number">0</span>            <span class="number">1</span>            <span class="number">2</span>            <span class="number">3</span></span><br><span class="line">count  <span class="number">1000.000000</span>  <span class="number">1000.000000</span>  <span class="number">1000.000000</span>  <span class="number">1000.000000</span></span><br><span class="line">mean     -<span class="number">0.067623</span>     <span class="number">0.068473</span>     <span class="number">0.025153</span>    -<span class="number">0.002081</span></span><br><span class="line"><span class="built_in">std</span>       <span class="number">0.995485</span>     <span class="number">0.990253</span>     <span class="number">1.003977</span>     <span class="number">0.989736</span></span><br><span class="line">min      -<span class="number">3.000000</span>    -<span class="number">3.000000</span>    -<span class="number">3.000000</span>    -<span class="number">3.000000</span></span><br><span class="line"><span class="number">25</span>%      -<span class="number">0.774890</span>    -<span class="number">0.591841</span>    -<span class="number">0.641675</span>    -<span class="number">0.644144</span></span><br><span class="line"><span class="number">50</span>%      -<span class="number">0.116401</span>     <span class="number">0.101143</span>     <span class="number">0.002073</span>    -<span class="number">0.013611</span></span><br><span class="line"><span class="number">75</span>%       <span class="number">0.616366</span>     <span class="number">0.780282</span>     <span class="number">0.680391</span>     <span class="number">0.654328</span></span><br><span class="line">max       <span class="number">3.000000</span>     <span class="number">2.653656</span>     <span class="number">3.000000</span>     <span class="number">3.000000</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用pandas，首先导入包：</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h1 id="一、创建Series，DataFrame">一、创建Series，DataFrame</h1><h2 id="1，创建Series">1，创建Series</h2><h3 id="a，通过列表创建">a，通过列表创建</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>]) </span><br><span class="line">obj2 = Series([<span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>], index=[<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'a'</span>,<span class="string">'c'</span>]) <span class="preprocessor">#指定索引</span></span><br></pre></td></tr></table></figure>
<h3 id="b，通过字典创建Series">b，通过字典创建Series</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">sdata = <span class="value">&#123;<span class="string">'Ohio'</span>:<span class="number">35000</span>, <span class="string">'Texas'</span>:<span class="number">7100</span>, <span class="string">'Oregon'</span>:<span class="number">1600</span>,<span class="string">'Utah'</span>:<span class="number">500</span>&#125;</span></span></span><br><span class="line"><span class="setting">obj3 = <span class="value">Series(sdata)</span></span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="DataFrame" scheme="http://www.kekefund.com/tags/DataFrame/"/>
    
      <category term="pandas" scheme="http://www.kekefund.com/tags/pandas/"/>
    
      <category term="python" scheme="http://www.kekefund.com/tags/python/"/>
    
      <category term="数据分析" scheme="http://www.kekefund.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python 制作标签云]]></title>
    <link href="http://www.kekefund.com/2016/02/15/py-tag-cloud/"/>
    <id>http://www.kekefund.com/2016/02/15/py-tag-cloud/</id>
    <published>2016-02-15T01:19:38.000Z</published>
    <updated>2016-02-15T01:24:58.000Z</updated>
    <content type="html"><![CDATA[<p>标签云是比较直观的频率分布表现方式，很多网站和APP在年度盘点和总结时会使用。Python生成标签云有一个比较易用的库 pytagcloud。</p>
<p><img src="http://7xo67b.com1.z0.glb.clouddn.com/2016-02-10-finance.png-540x360" alt=""></p>
<h1 id="1，导入头文件">1，导入头文件</h1><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pytagcloud <span class="keyword">import</span> create_tag_image, make_tags</span><br><span class="line"><span class="keyword">from</span> pytagcloud.lang.counter <span class="keyword">import</span> get_tag_counts</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="2，生成标签云">2，生成标签云</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">finance_cloud</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">      tag = <span class="string">'cc xx xx china cc keke keke keke'</span></span><br><span class="line">      tags = make_tags(get_tag_counts(tag),maxsize=<span class="number">100</span>)</span><br><span class="line">      <span class="comment"># Set your output filename</span></span><br><span class="line">      create_tag_image(tags,<span class="string">"cloud.png"</span>, size=(<span class="number">1280</span>,<span class="number">800</span>),background=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), fontname=<span class="string">"SimHei"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">finance_cloud()</span><br></pre></td></tr></table></figure>
<p>生成的图片cloud.png可以指定尺寸size，设置背景background，指定字体fontname。</p>
<p>pytagcloud库默认的字体不支持中文，生成的图片中，中文是乱码。</p>
<p>解决办法是在py文件开始处指定图片输出的字体：</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">from</span> <span class="atom">pylab</span> <span class="atom">import</span> <span class="atom">mpl</span></span><br><span class="line"><span class="atom">mpl</span>.<span class="atom">rcParams</span>[<span class="string">'font.sans-serif'</span>] = [<span class="string">'SimHei'</span>]#[<span class="string">'FangSong'</span>] # 指定默认字体</span><br><span class="line"><span class="atom">mpl</span>.<span class="atom">rcParams</span>[<span class="string">'axes.unicode_minus'</span>] = <span class="name">False</span> # 解决保存图像是负号<span class="string">'-'</span>显示为方块的问题</span><br></pre></td></tr></table></figure>
<h1 id="3，字体名称">3，字体名称</h1><h2 id="Windows的字体对应名称">Windows的字体对应名称</h2><p>黑体     SimHei<br>微软雅黑     Microsoft YaHei<br>微软正黑体     Microsoft JhengHei<br>新宋体     NSimSun<br>新细明体     PMingLiU<br>细明体     MingLiU<br>标楷体     DFKai-SB<br>仿宋     FangSong<br>楷体     KaiTi<br>仿宋_GB2312     FangSong_GB2312<br>楷体_GB2312     KaiTi_GB2312 </p>
<p>宋体：SimSuncss中中文字体（font-family）的英文名称<br>新細明體：PMingLiU<br>細明體：MingLiU<br>標楷體：DFKai-SB<br>黑体：SimHei<br>新宋体：NSimSun<br>仿宋：FangSong<br>楷体：KaiTi<br>仿宋_GB2312：FangSong_GB2312<br>楷体_GB2312：KaiTi_GB2312<br>微軟正黑體：Microsoft JhengHei<br>微软雅黑体：Microsoft YaHei<br>装Office会生出来的一些：<br>隶书：LiSu<br>幼圆：YouYuan<br>华文细黑：STXihei<br>华文楷体：STKaiti<br>华文宋体：STSong<br>华文中宋：STZhongsong<br>华文仿宋：STFangsong<br>方正舒体：FZShuTi<br>方正姚体：FZYaoti<br>华文彩云：STCaiyun<br>华文琥珀：STHupo<br>华文隶书：STLiti<br>华文行楷：STXingkai<br>华文新魏：STXinwei</p>
<h2 id="Mac_OS的字体名称：">Mac OS的字体名称：</h2><p>华文细黑：STHeiti Light [STXihei]<br>华文黑体：STHeiti<br>华文楷体：STKaiti<br>华文宋体：STSong<br>华文仿宋：STFangsong<br>儷黑 Pro：LiHei Pro Medium<br>儷宋 Pro：LiSong Pro Light<br>標楷體：BiauKai<br>蘋果儷中黑：Apple LiGothic Medium<br>蘋果儷細宋：Apple LiSung Light </p>
<blockquote>
<p>参考：<a href="http://www.it610.com/article/2569995.htm" target="_blank" rel="external">http://www.it610.com/article/2569995.htm</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>标签云是比较直观的频率分布表现方式，很多网站和APP在年度盘点和总结时会使用。Python生成标签云有一个比较易用的库 pytagcloud。</p>
<p><img src="http://7xo67b.com1.z0.glb.clouddn.com/2016-02-10-finance.png-540x360" alt=""></p>
<h1 id="1，导入头文件">1，导入头文件</h1><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pytagcloud <span class="keyword">import</span> create_tag_image, make_tags</span><br><span class="line"><span class="keyword">from</span> pytagcloud.lang.counter <span class="keyword">import</span> get_tag_counts</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="pytagcloud" scheme="http://www.kekefund.com/tags/pytagcloud/"/>
    
      <category term="python" scheme="http://www.kekefund.com/tags/python/"/>
    
      <category term="标签云" scheme="http://www.kekefund.com/tags/%E6%A0%87%E7%AD%BE%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python朴素贝叶斯分类器 - 自然语言处理]]></title>
    <link href="http://www.kekefund.com/2016/01/27/naive-bayes-classifier/"/>
    <id>http://www.kekefund.com/2016/01/27/naive-bayes-classifier/</id>
    <published>2016-01-27T07:45:55.000Z</published>
    <updated>2016-02-03T07:10:47.000Z</updated>
    <content type="html"><![CDATA[<h1 id="概念">概念</h1><p>朴素贝叶斯算法是一个直观的方法，使用每个属性属于某个类的概率来做预测。你可以使用这种监督性学习方法，对一个预测性建模问题进行概率建模。</p>
<p>给定一个类，朴素贝叶斯假设每个属性归属于此类的概率独立于其余所有属性，从而简化了概率的计算。这种强假定产生了一个快速、有效的方法。</p>
<p>给定一个属性值，其属于某个类的概率叫做条件概率。对于一个给定的类值，将每个属性的条件概率相乘，便得到一个数据样本属于某个类的概率。</p>
<h2 id="1、贝叶斯定理">1、贝叶斯定理</h2><p>假设对于某个数据集，随机变量C表示样本为C类的概率，F1表示测试样本某特征出现的概率，套用基本贝叶斯公式，则如下所示：</p>
<center><br><img src="http://www.forkosh.com/mathtex.cgi?P(C%20|%20F_{1})%20=%20\dfrac{P(CF_{1})}%20{P(F_{1})}%20=%20\dfrac{P(C)*P(F_{1}|C)}{P(F_{1})}"><br></center>

<p>上式表示对于某个样本，特征F1出现时，该样本被分为C类的条件概率。<br><a id="more"></a></p>
<p>对该公式，有几个概念需要熟知：</p>
<ul>
<li><p><strong>先验概率（Prior） </strong>。P(C)是C的先验概率，可以从已有的训练集中计算分为C类的样本占所有样本的比重得出。</p>
</li>
<li><p><strong>证据（Evidence）</strong>。即上式P(F1)，表示对于某测试样本，特征F1出现的概率。同样可以从训练集中F1特征对应样本所占总样本的比例得出。</p>
</li>
<li><p><strong>似然（likelihood）</strong>。即上式P(F1 | C)，表示如果知道一个样本分为C类，那么他的特征为F1的概率是多少。</p>
</li>
</ul>
<p>对于多个特征而言，贝叶斯公式可以扩展如下：</p>
<center><br><img src="http://7xo67b.com1.z0.glb.clouddn.com/20160127gs2.jpg"><br></center>


<p>分子中存在一大串似然值。当特征很多的时候，这些似然值的计算是极其痛苦的。</p>
<h2 id="2、朴素的概念">2、朴素的概念</h2><p>为了简化计算，朴素贝叶斯算法假设：“朴素的认为各个特征相互独立”。这样一来，上式的分子就简化成了：</p>
<center><br><img src="http://www.forkosh.com/mathtex.cgi?P(C)*P(F_{1}|C)*P(F_{2}|C)...P(F_{n}|C) "><br></center>


<p>这个假设是认为各个特征之间是独立的，看上去确实是个很不科学的假设。因为很多情况下，各个特征之间是紧密联系的。然而在朴素贝叶斯的大量应用实践表明其工作的相当好。</p>
<p>其次，由于朴素贝叶斯的工作原理是计算<img src="http://www.forkosh.com/mathtex.cgi? P(C=0|F_{1}...F_{n})" <="" img="">和<img src="http://www.forkosh.com/mathtex.cgi? P(C=1|F_{1}...F_{n})" <="" img="">，并取最大值的那个作为其分类。而二者的分母是一模一样的。因此，我们又可以省略分母计算，从而进一步简化计算过程。</p>
<p>另外，贝叶斯公式推导能够成立有个重要前期，就是各个证据（evidence）不能为0。也即对于任意特征Fx，P(Fx)不能为0。而显示某些特征未出现在测试集中的情况是可以发生的。因此实现上通常要做一些小的处理，例如把所有计数进行+1（加法平滑（additive smoothing，又叫拉普拉斯平滑（Laplace smothing））。而通过增大一个大于0的可调参数alpha进行平滑，就叫Lidstone平滑。</p>
<h1 id="朴素贝叶斯分类器的Python实现">朴素贝叶斯分类器的Python实现</h1><h2 id="1，定义特征提取器">1，定义特征提取器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In[<span class="number">21</span>]: <span class="function"><span class="keyword">def</span> <span class="title">gender_features</span><span class="params">(word)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">... </span>        <span class="keyword">return</span> &#123;<span class="string">'last_letter'</span>:word[-<span class="number">1</span>]&#125;</span><br><span class="line"></span><br><span class="line">In[<span class="number">22</span>]: gender_features(<span class="string">'Shrek'</span>)</span><br><span class="line"></span><br><span class="line">Out[<span class="number">22</span>]: &#123;<span class="string">'last_letter'</span>: <span class="string">'k'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>函数返回的字典被成为特征集，能把特征名称映射到它们的值。</p>
<p><em>特征名称提供一个简短的、可读的特征描述；特征值是简单类型的值，如布尔、数字和字符串。</em></p>
<h2 id="2，准备数据">2，准备数据</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">In[24]</span>: <span class="string">from nltk.corpus import names</span></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">In[25]</span>: <span class="string">import random</span></span><br><span class="line"></span><br><span class="line"><span class="stylus">In[<span class="number">26</span>]: names = ([(name, <span class="string">'male'</span>) <span class="keyword">for</span> name <span class="keyword">in</span> names.<span class="function"><span class="title">words</span><span class="params">(<span class="string">'male.txt'</span>)</span></span>] + [(name, <span class="string">'female'</span>) <span class="keyword">for</span> name <span class="keyword">in</span> names.<span class="function"><span class="title">words</span><span class="params">(<span class="string">'female.txt'</span>)</span></span>])</span><br><span class="line"></span><br><span class="line">In[<span class="number">44</span>]: random.<span class="function"><span class="title">shuffle</span><span class="params">(names)</span></span>  #元素顺序打乱</span></span></span><br></pre></td></tr></table></figure>
<h2 id="3，朴素贝叶斯分类器">3，朴素贝叶斯分类器</h2><p>将特征集的结果链表划分为训练集和测试集。训练集用于训练新的“朴素贝叶斯”分类器。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">In[32]</span>: <span class="string">featuresets = [(gender_features(n), g) for (n, g) in names]</span></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">In[33]</span>: <span class="string">train_set, test_set = featuresets[500:], featuresets[:500]</span></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">In[34]</span>: <span class="string">classifier = nltk.NaiveBayesClassifier.train(train_set)</span></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">In[35]</span>: <span class="string">classifier.classify(gender_features('Neo'))</span></span><br><span class="line"></span><br><span class="line"><span class="delphi"><span class="keyword">Out</span>[<span class="number">35</span>]: <span class="string">'male'</span></span></span></span></span></span><br></pre></td></tr></table></figure>
<h2 id="4，评估分类器">4，评估分类器</h2><p>准确度：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">In</span><span class="attr_selector">[39]</span>: <span class="tag">print</span> <span class="tag">nltk</span><span class="class">.classify</span><span class="class">.accuracy</span>(<span class="tag">classifier</span>, <span class="tag">test_set</span>)</span><br><span class="line"></span><br><span class="line">0<span class="class">.602</span></span><br></pre></td></tr></table></figure>
<p>检查分类器，确定哪些特征对于区分名字的性别是最有效的:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">In[43]</span>: <span class="string">classifier.show_most_informative_features(5)</span></span><br><span class="line"></span><br><span class="line"><span class="python">Most Informative Features</span><br><span class="line"></span><br><span class="line">             last_letter = <span class="string">u'a'</span>           female : male   =     <span class="number">36.8</span> : <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">             last_letter = <span class="string">u'k'</span>             male : female =     <span class="number">35.3</span> : <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">             last_letter = <span class="string">u'f'</span>             male : female =     <span class="number">17.0</span> : <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">             last_letter = <span class="string">u'p'</span>             male : female =     <span class="number">14.0</span> : <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">             last_letter = <span class="string">u'v'</span>             male : female =     <span class="number">12.5</span> : <span class="number">1.0</span></span></span><br></pre></td></tr></table></figure>
<p>以a结尾的女性是男性的36倍，这些比率成为<strong>似然比</strong>。</p>
<h2 id="5，优化">5，优化</h2><p>在处理大型语料库时，构建包含所有实例特征的单独链表会占用大量内存。可以使用函数 nltk.classify.apply_features， 类似生成器原理。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">In[46]</span>: <span class="string">from nltk.classify import apply_features</span></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">In[47]</span>: <span class="string">train_set = apply_features(gender_features, names[500:])</span></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">In[48]</span>: <span class="string">test_set = apply_features(gender_features, names[:500])</span></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">In[49]</span>: <span class="string">type(train_set)</span></span><br><span class="line"></span><br><span class="line"><span class="css"><span class="tag">Out</span><span class="attr_selector">[49]</span>: <span class="tag">nltk</span><span class="class">.util</span><span class="class">.LazyMap</span></span></span></span></span></span><br></pre></td></tr></table></figure>
<h2 id="6，结果评估与改进">6，结果评估与改进</h2><p>将数据分为<strong>训练集、开发测试集和测试集</strong>。</p>
<p>训练集用于训练模型，开发测试集用于执行错误分析，测试集用于系统的最终评估。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">train_names = names[<span class="number">1500</span>:]</span><br><span class="line">devtest_names = names[<span class="number">500</span>:<span class="number">1500</span>]</span><br><span class="line">test_names = names[:<span class="number">500</span>]</span><br><span class="line"></span><br><span class="line">train_set = [(<span class="function"><span class="title">gender_features</span><span class="params">(n)</span></span>, g) <span class="keyword">for</span> (n, g) <span class="keyword">in</span> train_names]</span><br><span class="line">devtest_set = [(<span class="function"><span class="title">gender_features</span><span class="params">(n)</span></span>, g) <span class="keyword">for</span> (n, g) <span class="keyword">in</span> devtest_names]</span><br><span class="line">test_set = [(<span class="function"><span class="title">gender_features</span><span class="params">(n)</span></span>, g) <span class="keyword">for</span> (n, g) <span class="keyword">in</span> test_names]</span><br><span class="line">classifier = nltk<span class="class">.NaiveBayesClassifier</span><span class="class">.train</span>(train_set)</span><br><span class="line">print nltk<span class="class">.classify</span><span class="class">.accuracy</span>(classifier, devtest_set)</span><br><span class="line">Out: <span class="number">0.794</span></span><br></pre></td></tr></table></figure>
<p>使用开发测试集生成分类器在预测名字性别时出现的错误列表：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">errors = []</span><br><span class="line"><span class="keyword">for</span> (<span class="property">name</span>, tag) <span class="keyword">in</span> devtest_names:</span><br><span class="line">    guess = classifier.classify(gender_features(<span class="property">name</span>))</span><br><span class="line">    <span class="keyword">if</span> guess != tag:</span><br><span class="line">        errors.append((tag, guess, <span class="property">name</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (tag, guess, <span class="property">name</span>) <span class="keyword">in</span> sorted(errors):</span><br><span class="line">    print 'correct=%-<span class="number">8</span>s guess=%-<span class="number">8</span>s <span class="property">name</span>=%-<span class="number">30</span>s' % (tag, guess, <span class="property">name</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">---------------------------------------</span></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">correct=female   guess=male     <span class="property">name</span>=Adelind                       </span><br><span class="line"></span><br><span class="line">correct=female   guess=male     <span class="property">name</span>=Alex                          </span><br><span class="line"></span><br><span class="line">correct=female   guess=male     <span class="property">name</span>=Alyss                         </span><br><span class="line"></span><br><span class="line">correct=female   guess=male     <span class="property">name</span>=Amber                         </span><br><span class="line"></span><br><span class="line">correct=female   guess=male     <span class="property">name</span>=Austin                        </span><br><span class="line"></span><br><span class="line">correct=female   guess=male     <span class="property">name</span>=Averil                        </span><br><span class="line"></span><br><span class="line">correct=female   guess=male     <span class="property">name</span>=Beatrix  </span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>根据上面的错误列表改进特征提取器，比如发现yn结尾的名字大多以女性为主，但以n结尾的名字往往是男性，因此调整特征提取器使其包含两个字母后缀的特征：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gender_features</span><span class="params">(word)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'suffix1'</span>:word[-<span class="number">1</span>:],</span><br><span class="line">            <span class="string">'suffix2'</span>:word[-<span class="number">2</span>:]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> nltk.classify.accuracy(classifier, devtest_set)</span><br><span class="line">Out[]: <span class="number">0.784</span></span><br></pre></td></tr></table></figure>
<h1 id="参考"><em>参考</em></h1><blockquote>
<p><a href="http://blog.csdn.net/lsldd/article/details/41542107" target="_blank" rel="external">http://blog.csdn.net/lsldd/article/details/41542107</a></p>
<p>[书]Python自然语言处理  Steven Bird, Ewan Klein &amp; Edward Loper</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概念">概念</h1><p>朴素贝叶斯算法是一个直观的方法，使用每个属性属于某个类的概率来做预测。你可以使用这种监督性学习方法，对一个预测性建模问题进行概率建模。</p>
<p>给定一个类，朴素贝叶斯假设每个属性归属于此类的概率独立于其余所有属性，从而简化了概率的计算。这种强假定产生了一个快速、有效的方法。</p>
<p>给定一个属性值，其属于某个类的概率叫做条件概率。对于一个给定的类值，将每个属性的条件概率相乘，便得到一个数据样本属于某个类的概率。</p>
<h2 id="1、贝叶斯定理">1、贝叶斯定理</h2><p>假设对于某个数据集，随机变量C表示样本为C类的概率，F1表示测试样本某特征出现的概率，套用基本贝叶斯公式，则如下所示：</p>
<center><br><img src="http://www.forkosh.com/mathtex.cgi?P(C%20|%20F_{1})%20=%20\dfrac{P(CF_{1})}%20{P(F_{1})}%20=%20\dfrac{P(C)*P(F_{1}|C)}{P(F_{1})}" /><br></center>

<p>上式表示对于某个样本，特征F1出现时，该样本被分为C类的条件概率。<br>]]>
    
    </summary>
    
      <category term="nltk" scheme="http://www.kekefund.com/tags/nltk/"/>
    
      <category term="python" scheme="http://www.kekefund.com/tags/python/"/>
    
      <category term="贝叶斯分类器" scheme="http://www.kekefund.com/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    
      <category term="贝叶斯原理" scheme="http://www.kekefund.com/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%8E%9F%E7%90%86/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[人工智能和系统化交易招聘]]></title>
    <link href="http://www.kekefund.com/2016/01/26/js-recruit/"/>
    <id>http://www.kekefund.com/2016/01/26/js-recruit/</id>
    <published>2016-01-26T07:48:31.000Z</published>
    <updated>2016-01-26T08:05:32.000Z</updated>
    <content type="html"><![CDATA[<p>某大型资产管理公司人工智能和系统化交易招聘<br>简历发送到： [js_recruit@163.com]</p>
<h1 id="1．_人工智能/机器学习算法研究员">1．  人工智能/机器学习算法研究员</h1><p>学历要求：博士<br>职位数量：2人</p>
<h2 id="岗位职责：">岗位职责：</h2><ul>
<li>使用统计学习方法，挖掘投资者行为特征的数据。</li>
<li>对金融海量数据，针对不同的学习问题，建立起一般性的数据源选择框架。</li>
<li>对金融相关分类和预测性问题建模，并负责系统回测。</li>
<li>与技术人员合作，参与大数据计算框架的设计和运行<a id="more"></a>
</li>
</ul>
<h2 id="职位要求：">职位要求：</h2><ul>
<li>具有人工智能，机器学习方面较为深厚的理论研究背景。深入理解机器学习的各种算法。能独立从事大数据和人工智能方面的研究工作。</li>
<li>对数据的预处理，分类，预测等方面有实践经验。熟练使用R，Python，C/C++, Java, Scala 等编程语言中至少一种。</li>
<li>工作勤奋，有团队精神，能承担一定的工作压力。</li>
</ul>
<h1 id="2-_数据管理员">2.  数据管理员</h1><p>学历要求：本科以上<br>职位数量：1人</p>
<h2 id="岗位职责：-1">岗位职责：</h2><ul>
<li>负责团队数据库的运行和维护，管理，扩展工作</li>
<li>根据业务需求，参与数据库的架构设计和数据结构的优化</li>
<li>负责数据库的日常监控，维护，备份和恢复</li>
<li>研究系统可能存在的性能瓶颈并进行优化</li>
</ul>
<h2 id="背景要求：">背景要求：</h2><ul>
<li>具有数据库运维的3年经验。熟悉Oracle，MySQL, SQLServer等各种数据库的存储，查询，和优化。</li>
<li>有一定的脚本语言开发能力，能用C/C++，Java，Python 其中至少一种开发数据库接口。有一定的大数据运行经验，能配合开发人员优化数据库访问语句。</li>
<li>了解非关系型数据库NoSQL的工作原理。</li>
<li>工作细致耐心，踏实敬业，有团队合作精神。</li>
</ul>
<h1 id="3．_大数据架构技术经理">3．  大数据架构技术经理</h1><p>学历要求：本科以上<br>职位数量：1人</p>
<h2 id="岗位职责：-2">岗位职责：</h2><ul>
<li>根据项目需求，分析，设计，并实现系统的架构方案。使系统架构具有合理性和可扩展性</li>
<li>控制大数据项目的架构质量，协助解决项目开发过程中的技术困难。</li>
<li>追踪大数据和云计算技术的最新科技成果，并协调团队应用于金融实践</li>
<li>参与代码的实现，并编写技术文档，对通用技术实现复用。</li>
</ul>
<h2 id="背景要求：-1">背景要求：</h2><ul>
<li>有独立开发和部署分布式存储和计算架构，比如Hadoop，Hive，Pig，Spark的经验。熟悉海量数据的查询和计算。</li>
<li>精通C/C++, Scala, Python, Java至少两种编程语言，有较强的分布式计算基础和软件工程能力</li>
<li>精通Linux操作系统， 对开源软件，云计算，数据仓库类产品有比较深入的认识。</li>
<li>良好的沟通协调能力。</li>
</ul>
<h1 id="4．_大数据工程师">4．  大数据工程师</h1><p>学历要求：本科以上<br>职位数量：1~2人</p>
<h2 id="岗位职责：-3">岗位职责：</h2><ul>
<li>参与开发和建设实时、离线的数据存储和计算平台，并在该平台上实现数据的预测，分类和展现。</li>
<li>参与构建金融类相关数据业务模型，并使用并行式计算架构实现和优化。</li>
<li>参与开发数据可视化过程。</li>
</ul>
<h2 id="背景要求：-2">背景要求：</h2><ul>
<li>精通C/C++, Scala, Python, Java中至少两种编程语言，有较强的软件工程能力，理解面向对象编程思想（类，对象，重载，继承，多态）。</li>
<li>了解分布式存储和计算架构，比如Hadoop，Hive，Pig，Spark。</li>
<li>精通Linux操作系统和Shell的使用， 会编写script.</li>
<li>熟练使用关系型数据库， 熟悉Oracle，MySQL，SQLServer等各种数据库的存储和优化。</li>
</ul>
<h1 id="5．_金融工程研究员">5．  金融工程研究员</h1><p>学历要求：硕士或以上<br>职位数量：1人</p>
<h2 id="岗位职责：-4">岗位职责：</h2><ul>
<li>设计和优化二级市场被动性和主动性投资策略，并负责系统回测</li>
<li>与团队成员合作，设计金融数据挖掘逻辑</li>
<li>参与金融产品的开发和风险控制</li>
</ul>
<h2 id="职位要求：-1">职位要求：</h2><ul>
<li>深入理解二级市场投资的各种产品，包括股票，债券，期货，指数基金等</li>
<li>理解实证资产定价过程，对于量化投资有一定了解。</li>
<li>理解公司财务理论，并能对上市公司进行财务分析。</li>
<li>能够使用Matlab，R，等任意一种脚本语言，编写程序</li>
</ul>
<h2 id="简历发送到：_js_recruit@163-com">简历发送到： <a href="js_recruit@163.com">js_recruit@163.com</a></h2>]]></content>
    <summary type="html">
    <![CDATA[<p>某大型资产管理公司人工智能和系统化交易招聘<br>简历发送到： [js_recruit@163.com]</p>
<h1 id="1．_人工智能/机器学习算法研究员">1．  人工智能/机器学习算法研究员</h1><p>学历要求：博士<br>职位数量：2人</p>
<h2 id="岗位职责：">岗位职责：</h2><ul>
<li>使用统计学习方法，挖掘投资者行为特征的数据。</li>
<li>对金融海量数据，针对不同的学习问题，建立起一般性的数据源选择框架。</li>
<li>对金融相关分类和预测性问题建模，并负责系统回测。</li>
<li>与技术人员合作，参与大数据计算框架的设计和运行]]>
    
    </summary>
    
      <category term="人工智能" scheme="http://www.kekefund.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="招聘" scheme="http://www.kekefund.com/tags/%E6%8B%9B%E8%81%98/"/>
    
      <category term="机器学习" scheme="http://www.kekefund.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="系统化交易" scheme="http://www.kekefund.com/tags/%E7%B3%BB%E7%BB%9F%E5%8C%96%E4%BA%A4%E6%98%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python多线程与多进程 超简单使用]]></title>
    <link href="http://www.kekefund.com/2016/01/22/python-multiprocess/"/>
    <id>http://www.kekefund.com/2016/01/22/python-multiprocess/</id>
    <published>2016-01-22T07:47:07.000Z</published>
    <updated>2016-01-26T07:52:39.000Z</updated>
    <content type="html"><![CDATA[<p>Python 的GIL限制了多核CPU的性能，对于IO密集型的程序，采用多线程能显著提高运行速度；但对于计算密集型的程序，多线程就没多少用了，采用多进程编程，就能充分利用多核CPU的性能，CPU占用率能达到100%。</p>
<ul>
<li>下面是在阿里云服务器上测试的数据：</li>
</ul>
<blockquote>
<p>配置：CPU：Xeon, E5-2680, 2.5GHz, 4核;  内存：16G, DDR4; 硬盘：100G, SSD<br><a id="more"></a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    pool = multiprocessing.Pool(processes = <span class="number">8</span>)</span><br><span class="line">    result = []</span><br><span class="line">    contents = []</span><br><span class="line">    <span class="keyword">for</span> ix, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">        content = row[<span class="string">'title'</span>] + <span class="string">" "</span> + row[<span class="string">'content'</span>]</span><br><span class="line">        contents.append(content)</span><br><span class="line">    result = pool.map(get_one_article_keys, contents)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'time pass:&#123;:.3f&#125;'</span>.format(t1-t0)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_one_article_keys</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        tags2 = jieba.analyse.textrank(content, topK=<span class="number">20</span>)</span><br><span class="line">        <span class="keyword">print</span> multiprocessing.current_process()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">','</span>.join(tags2)</span><br><span class="line">    <span class="keyword">except</span> Exception,e:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"get_one_article_keys():%s"</span> % str(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>执行计算密集型任务的结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">multi_way</th>
<th style="text-align:center">Processes</th>
<th style="text-align:center">Time(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">多进程</td>
<td style="text-align:center">4</td>
<td style="text-align:center">378</td>
</tr>
<tr>
<td style="text-align:center">多进程</td>
<td style="text-align:center">8</td>
<td style="text-align:center">381</td>
</tr>
<tr>
<td style="text-align:center">多进程</td>
<td style="text-align:center">20</td>
<td style="text-align:center">464</td>
</tr>
<tr>
<td style="text-align:center"><font color="red">多线程</font></td>
<td style="text-align:center">8</td>
<td style="text-align:center">3174</td>
</tr>
</tbody>
</table>
<p>对于一台四核的机器，设置进程数为对应的内核数，效率是最高的；当设置比内核多的进程时，在创建python进程时开销占时比较多，造成设置为20个进程数时，时间比4个进程多了1分钟多。<br><strong>因此，设置进程数与实际内核数相同，运行最快。</strong></p>
<blockquote>
<p>获取内核数: multiprocessing.cpu_count() </p>
</blockquote>
<h1 id="一、多进程编程">一、多进程编程</h1><h2 id="1，map方式">1，map方式</h2><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">def do_something(i):</span><br><span class="line">    time.sleep(i)</span><br><span class="line">    print 'good:%d' % i</span><br><span class="line">    <span class="keyword">return</span> 'good:%d' % i</span><br><span class="line"></span><br><span class="line">print multiprocessing.cpu_count()</span><br><span class="line">pool = multiprocessing.<span class="type">Pool</span>(processes = <span class="number">4</span>)</span><br><span class="line"><span class="literal">result</span> = pool.map(do_something, <span class="type">range</span>(<span class="number">10</span>)）</span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> <span class="literal">result</span>:</span><br><span class="line">    print res</span><br></pre></td></tr></table></figure>
<p>result 可以得到多进程执行do_something返回的结果，为list</p>
<blockquote>
<p>1，map方式为阻塞模式，主进程必须等待所有子进程执行完毕了才能继续；<br>2，还有一种方式为非阻塞模式，<font color="red">map_async</font>，主进程不等待子进程是否完毕，接着向下执行。</p>
</blockquote>
<h2 id="2，apply_方式">2，apply 方式</h2><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="literal">result</span> = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="type">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="literal">result</span>.append(pool.apply(do_something, (i,)))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同map_async一样，还有非阻塞模式 <font color="red">apply_async</font>。</p>
</blockquote>
<h1 id="二、多线程编程">二、多线程编程</h1><p>多线程实现也非常简单，跟多进程基本一样，只是创建pool时略有不同。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> <span class="type">Pool</span> <span class="keyword">as</span> <span class="type">ThreadPool</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">def do_something(i):</span><br><span class="line">    time.sleep(i)</span><br><span class="line">    print 'good:%d' % i</span><br><span class="line">    <span class="keyword">return</span> 'good:%d' % i</span><br><span class="line"></span><br><span class="line">pool = <span class="type">ThreadPool</span>(processes = <span class="number">4</span>)</span><br><span class="line"><span class="literal">result</span> = pool.map(do_something, <span class="type">range</span>(<span class="number">10</span>)）</span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> <span class="literal">result</span>:</span><br><span class="line">    print res</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Python 的GIL限制了多核CPU的性能，对于IO密集型的程序，采用多线程能显著提高运行速度；但对于计算密集型的程序，多线程就没多少用了，采用多进程编程，就能充分利用多核CPU的性能，CPU占用率能达到100%。</p>
<ul>
<li>下面是在阿里云服务器上测试的数据：</li>
</ul>
<blockquote>
<p>配置：CPU：Xeon, E5-2680, 2.5GHz, 4核;  内存：16G, DDR4; 硬盘：100G, SSD<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://www.kekefund.com/tags/Python/"/>
    
      <category term="multiprocessing" scheme="http://www.kekefund.com/tags/multiprocessing/"/>
    
      <category term="多线程" scheme="http://www.kekefund.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="多进程" scheme="http://www.kekefund.com/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网页爬虫之cookie自动获取]]></title>
    <link href="http://www.kekefund.com/2016/01/21/spider-cookie/"/>
    <id>http://www.kekefund.com/2016/01/21/spider-cookie/</id>
    <published>2016-01-21T01:05:36.000Z</published>
    <updated>2016-01-21T01:23:17.000Z</updated>
    <content type="html"><![CDATA[<p>本文实现cookie的自动获取，及cookie过期自动更新。</p>
<p>社交网站中的很多信息需要登录才能获取到，以微博为例，不登录账号，只能看到大V的前十条微博。保持登录状态，必须要用到Cookie。以登录www.weibo.cn 为例：</p>
<p>在chrome中输入：<a href="http://login.weibo.cn/login/" target="_blank" rel="external">http://login.weibo.cn/login/</a>  </p>
<p><img src="http://7xo67b.com1.z0.glb.clouddn.com/2016-01-21-cookie.png" alt=""></p>
<p>分析控制台的Headers的请求返回，会看到weibo.cn有几组返回的cookie。</p>
<h1 id="实现步骤：">实现步骤：</h1><blockquote>
<p>1，采用selenium自动登录获取cookie，保存到文件;</p>
<p>2，读取cookie，比较cookie的有效期，若过期则再次执行步骤1；</p>
<p>3，在请求其他网页时，填入cookie，实现登录状态的保持。<br><a id="more"></a></p>
</blockquote>
<h1 id="1，在线获取cookie">1，在线获取cookie</h1><p>采用selenium + PhantomJS 模拟浏览器登录，获取cookie；</p>
<p>cookies一般会有多个，逐个将cookie存入以.weibo后缀的文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cookie_from_network</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">    url_login = <span class="string">'http://login.weibo.cn/login/'</span> </span><br><span class="line">    driver = webdriver.PhantomJS()</span><br><span class="line">    driver.get(url_login)</span><br><span class="line">    driver.find_element_by_xpath(<span class="string">'//input[@type="text"]'</span>).send_keys(<span class="string">'your_weibo_accout'</span>) <span class="comment"># 改成你的微博账号</span></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">'//input[@type="password"]'</span>).send_keys(<span class="string">'your_weibo_password'</span>) <span class="comment"># 改成你的微博密码</span></span><br><span class="line"></span><br><span class="line">    driver.find_element_by_xpath(<span class="string">'//input[@type="submit"]'</span>).click() <span class="comment"># 点击登录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得 cookie信息</span></span><br><span class="line">    cookie_list = driver.get_cookies()</span><br><span class="line">    <span class="keyword">print</span> cookie_list</span><br><span class="line"></span><br><span class="line">    cookie_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> cookie <span class="keyword">in</span> cookie_list:</span><br><span class="line">        <span class="comment">#写入文件</span></span><br><span class="line">        f = open(cookie[<span class="string">'name'</span>]+<span class="string">'.weibo'</span>,<span class="string">'w'</span>)</span><br><span class="line">        pickle.dump(cookie, f)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cookie.has_key(<span class="string">'name'</span>) <span class="keyword">and</span> cookie.has_key(<span class="string">'value'</span>):</span><br><span class="line">            cookie_dict[cookie[<span class="string">'name'</span>]] = cookie[<span class="string">'value'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cookie_dict</span><br></pre></td></tr></table></figure>
<h1 id="2，从文件中获取cookie">2，从文件中获取cookie</h1><p>从当前目录中遍历以.weibo结尾的文件，即cookie文件。采用pickle解包成dict，比较expiry值与当前时间，若过期则返回为空；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cookie_from_cache</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    cookie_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> parent, dirnames, filenames <span class="keyword">in</span> os.walk(<span class="string">'./'</span>):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            <span class="keyword">if</span> filename.endswith(<span class="string">'.weibo'</span>):</span><br><span class="line">                <span class="keyword">print</span> filename</span><br><span class="line">                <span class="keyword">with</span> open(self.dir_temp + filename, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    d = pickle.load(f)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> d.has_key(<span class="string">'name'</span>) <span class="keyword">and</span> d.has_key(<span class="string">'value'</span>) <span class="keyword">and</span> d.has_key(<span class="string">'expiry'</span>):</span><br><span class="line">                        expiry_date = int(d[<span class="string">'expiry'</span>])</span><br><span class="line">                        <span class="keyword">if</span> expiry_date &gt; (int)(time.time()):</span><br><span class="line">                            cookie_dict[d[<span class="string">'name'</span>]] = d[<span class="string">'value'</span>]</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">return</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cookie_dict</span><br></pre></td></tr></table></figure>
<h1 id="3，若缓存cookie过期，则再次从网络获取cookie">3，若缓存cookie过期，则再次从网络获取cookie</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">get_cookie</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    cookie_dict = get_cookie_from_cache()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cookie_dict:</span><br><span class="line">        cookie_dict = get_cookie_from_network()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cookie_dict</span><br></pre></td></tr></table></figure>
<h1 id="4，带cookie请求微博其他主页">4，带cookie请求微博其他主页</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_weibo_list</span><span class="params">(self, user_id)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> requests</span><br><span class="line">    <span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="keyword">as</span> bs</span><br><span class="line">    </span><br><span class="line">    cookdic = get_cookie()</span><br><span class="line"></span><br><span class="line">    url = <span class="string">'http://weibo.cn/stocknews88'</span> </span><br><span class="line">    headers = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.57 Safari/537.36'</span>&#125;</span><br><span class="line">    timeout = <span class="number">5</span></span><br><span class="line">    r = requests.get(url, headers=headers, cookies=cookdic,timeout=timeout)</span><br><span class="line">    soup = bs(r.text, <span class="string">'lxml'</span>)</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># 用BeautifulSoup 解析网页</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>本文实现cookie的自动获取，及cookie过期自动更新。</p>
<p>社交网站中的很多信息需要登录才能获取到，以微博为例，不登录账号，只能看到大V的前十条微博。保持登录状态，必须要用到Cookie。以登录www.weibo.cn 为例：</p>
<p>在chrome中输入：<a href="http://login.weibo.cn/login/">http://login.weibo.cn/login/</a>  </p>
<p><img src="http://7xo67b.com1.z0.glb.clouddn.com/2016-01-21-cookie.png" alt=""></p>
<p>分析控制台的Headers的请求返回，会看到weibo.cn有几组返回的cookie。</p>
<h1 id="实现步骤：">实现步骤：</h1><blockquote>
<p>1，采用selenium自动登录获取cookie，保存到文件;</p>
<p>2，读取cookie，比较cookie的有效期，若过期则再次执行步骤1；</p>
<p>3，在请求其他网页时，填入cookie，实现登录状态的保持。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://www.kekefund.com/tags/Python/"/>
    
      <category term="cookie" scheme="http://www.kekefund.com/tags/cookie/"/>
    
      <category term="crawler" scheme="http://www.kekefund.com/tags/crawler/"/>
    
      <category term="requests" scheme="http://www.kekefund.com/tags/requests/"/>
    
      <category term="selenium" scheme="http://www.kekefund.com/tags/selenium/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[requests初步使用]]></title>
    <link href="http://www.kekefund.com/2016/01/07/use-reqeusts/"/>
    <id>http://www.kekefund.com/2016/01/07/use-reqeusts/</id>
    <published>2016-01-07T08:52:33.000Z</published>
    <updated>2016-01-21T01:15:13.000Z</updated>
    <content type="html"><![CDATA[<h1 id="基本用法">基本用法</h1><h2 id="一、发送无参数的get请求">一、发送无参数的get请求</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: r =requests.<span class="built_in">get</span>(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: <span class="built_in">print</span> r.<span class="built_in">text</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"args"</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">"headers"</span>: &#123;</span><br><span class="line">    <span class="string">"Accept"</span>: <span class="string">"*/*"</span>, </span><br><span class="line">    <span class="string">"Accept-Encoding"</span>: <span class="string">"gzip, deflate"</span>, </span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"httpbin.org"</span>, </span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"python-requests/2.7.0 CPython/2.7.10 Darwin/14.5.0"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">"origin"</span>: <span class="string">"220.231.47.169"</span>, </span><br><span class="line">  <span class="string">"url"</span>: <span class="string">"http://httpbin.org/get"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回一个名为 r 的Response对象。可以从这个对象中获取所有我们想要的信息。<br><a id="more"></a></p>
<h2 id="二、发送带参数的get请求">二、发送带参数的get请求</h2><p>将key与value放入一个字典中，通过params来传递，其作用相当于urllib.urlencode</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="label">In [69]: pyqload = &#123;'q':</span>'cbb'&#125;</span><br><span class="line"><span class="label">In [70]: r = requests.get('http:</span>//www.so.com/s', params=pqyload, , timeout=<span class="number">10</span>) # <span class="number">10</span>s</span><br><span class="line"><span class="label">In [71]:</span> r.url</span><br><span class="line"><span class="label">Out[71]: u'http:</span>//www.haosou.com/s?q=<span class="var_expand">%E7%</span>AB<span class="var_expand">%A0%</span>E6<span class="var_expand">%A5%</span>A0<span class="var_expand">%E6%</span>A5<span class="var_expand">%A0'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意字典里值为 None 的键都不会被添加到 URL 的查询字符串里。</p>
</blockquote>
<h2 id="三、发送post请求，通过data参数来传递">三、发送post请求，通过data参数来传递</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: payload = &#123;<span class="string">'a'</span>:<span class="string">'嘎子'</span>, <span class="string">'b'</span>:<span class="string">'hello'</span>&#125;</span><br><span class="line">In [<span class="number">73</span>]: r = requests.post(<span class="string">'http://httpbin.org/post'</span>, data=payload)</span><br><span class="line">In [<span class="number">74</span>]: print r.text</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"args"</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">"data"</span>: <span class="string">""</span>, </span><br><span class="line">  <span class="string">"files"</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">"form"</span>: &#123;</span><br><span class="line">    <span class="string">"a"</span>: <span class="string">"\u560e\u5b50"</span>, </span><br><span class="line">    <span class="string">"b"</span>: <span class="string">"hello"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">"headers"</span>: &#123;</span><br><span class="line">    <span class="string">"Accept"</span>: <span class="string">"*/*"</span>, </span><br><span class="line">    <span class="string">"Accept-Encoding"</span>: <span class="string">"gzip, deflate"</span>, </span><br><span class="line">    <span class="string">"Content-Length"</span>: <span class="string">"28"</span>, </span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded"</span>, </span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"httpbin.org"</span>, </span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"python-requests/2.7.0 CPython/2.7.10 Darwin/14.5.0"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">"json"</span>: null, </span><br><span class="line">  <span class="string">"origin"</span>: <span class="string">"220.231.47.169"</span>, </span><br><span class="line">  <span class="string">"url"</span>: <span class="string">"http://httpbin.org/post"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>data不仅可以接受字典类型的数据，还可以接受json等格式：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: <span class="keyword">import</span> json</span><br><span class="line">In [<span class="number">76</span>]: r = requests.post(<span class="string">'http://httpbin.org/post'</span>, data=json.dumps(payload))</span><br><span class="line">In [<span class="number">77</span>]: print r.text</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"args"</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">"data"</span>: <span class="string">"&#123;\"</span>a\<span class="string">": \"</span>\\u560e\\u5b5<span class="number">0</span>\<span class="string">", \"</span>b\<span class="string">": \"</span>hello\<span class="string">"&#125;"</span>, </span><br><span class="line">  <span class="string">"files"</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">"form"</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">"headers"</span>: &#123;</span><br><span class="line">    <span class="string">"Accept"</span>: <span class="string">"*/*"</span>, </span><br><span class="line">    <span class="string">"Accept-Encoding"</span>: <span class="string">"gzip, deflate"</span>, </span><br><span class="line">    <span class="string">"Content-Length"</span>: <span class="string">"35"</span>, </span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"httpbin.org"</span>, </span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"python-requests/2.7.0 CPython/2.7.10 Darwin/14.5.0"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">"json"</span>: &#123;</span><br><span class="line">    <span class="string">"a"</span>: <span class="string">"\u560e\u5b50"</span>, </span><br><span class="line">    <span class="string">"b"</span>: <span class="string">"hello"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">"origin"</span>: <span class="string">"220.231.47.169"</span>, </span><br><span class="line">  <span class="string">"url"</span>: <span class="string">"http://httpbin.org/post"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，json参数时直接存为字符串保存为data字段，而字典类型参数放在form表单中。</p>
<h2 id="四、发送文件的post类型，_向网站上传一张图片，文档等">四、发送文件的post类型， 向网站上传一张图片，文档等</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">78</span>]: url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line">In [<span class="number">79</span>]: <span class="built_in">files</span> = &#123;<span class="string">'file'</span>:<span class="built_in">open</span>(<span class="string">'touxiang.png'</span>,<span class="string">'rb'</span>)&#125;</span><br><span class="line">In [<span class="number">80</span>]: r = requests.<span class="built_in">post</span>(url, <span class="built_in">files</span>=<span class="built_in">files</span>)</span><br></pre></td></tr></table></figure>
<h2 id="五、编码">五、编码</h2><p>Requests会自动解码来自服务器的内容。大多数unicode字符集都能被无缝地解码</p>
<p>请求发出后，Requests会基于HTTP头部对响应的编码作出有根据的推测。当你访问 r.text 之时，Requests会使用其推测的文本编码。你可以找出Requests使用了什么编码，并且能够使用r.encoding 属性来改变它:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: r = requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'http://www.baidu.com'</span>)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: r<span class="class">.encoding</span></span><br><span class="line"></span><br><span class="line">Out[<span class="number">12</span>]: <span class="string">'utf-8'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: r<span class="class">.encoding</span> = <span class="string">'GBK'</span></span><br></pre></td></tr></table></figure>
<h2 id="六、保存图片：二进制响应内容">六、保存图片：二进制响应内容</h2><p>对于非文本请求，以字节的方式访问请求响应体。Requests会自动为你解码gzip和deflate传输编码的响应数据。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">In[25]</span>: <span class="string">from PIL import Image</span></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">In[26]</span>: <span class="string">from StringIO import StringIO</span></span><br><span class="line"></span><br><span class="line"><span class="stylus">In[<span class="number">27</span>]: r = requests.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'http://7xo67b.com1.z0.glb.clouddn.com/1449027323885.jpg'</span>)</span></span></span><br><span class="line"></span><br><span class="line">In[<span class="number">28</span>]: <span class="tag">i</span> = Image.<span class="function"><span class="title">open</span><span class="params">(StringIO(r.content)</span></span>)</span><br><span class="line"></span><br><span class="line">In[<span class="number">30</span>]: <span class="tag">i</span>.<span class="function"><span class="title">show</span><span class="params">()</span></span></span></span></span><br></pre></td></tr></table></figure>
<p>显示图片:</p>
<p><img src="http://7xo67b.com1.z0.glb.clouddn.com/1449027323885.jpg" alt="刘楚恬"></p>
<h2 id="七、JSON响应内容">七、JSON响应内容</h2><p>Requests中也有一个内置的JSON解码器，助你处理JSON数据:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">In[31]</span>: <span class="string">r = requests.get('https://github.com/timeline.json')</span></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">In[32]</span>: <span class="string">r.json()</span></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">Out[32]</span>: <span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="python">&#123;<span class="string">u'documentation_url'</span>: <span class="string">u'https://developer.github.com/v3/activity/events/#list-public-events'</span>,</span><br><span class="line"></span><br><span class="line"> <span class="string">u'message'</span>: <span class="string">u'Hello there, wayfaring stranger. If you\u2019re reading this then you probably didn\u2019t see our blog post a couple of years back announcing that this API would go away: http://git.io/17AROg Fear not, you should be able to get what you need from the shiny new Events API instead.'</span>&#125;</span></span></span></span></span><br></pre></td></tr></table></figure>
<p>如果JSON解码失败， r.json 就会抛出一个异常。例如，相应内容是 401 (Unauthorized) ，尝试访问 r.json 将会抛出 ValueError: No JSON object could be decoded 异常。</p>
<h2 id="八、响应状态码">八、响应状态码</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">In[40]</span>: <span class="string">r = requests.get('http://httpbin.org/get')</span></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">In[41]</span>: <span class="string">r.status_code</span></span><br><span class="line"></span><br><span class="line"><span class="cpp">Out[<span class="number">41</span>]: <span class="number">200</span></span></span></span><br></pre></td></tr></table></figure>
<h2 id="九、Cookies">九、Cookies</h2><p>获取cookies</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">In[49]</span>: <span class="string">r.cookies</span></span><br><span class="line"></span><br><span class="line"><span class="accesslog">Out<span class="string">[49]</span>: &lt;RequestsCookieJar<span class="string">[]</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>发送cookies到服务器</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">url = 'http:<span class="comment">//httpbin.org/cookies'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span>[45]: cookies = dict(cookies_are='working')</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span>[47]:  r = requests.<span class="literal">get</span>(url, cookies=cookies)</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span>[48]: r.text</span><br><span class="line"></span><br><span class="line"><span class="keyword">Out</span>[48]: <span class="keyword">u</span>'&#123;\<span class="keyword">n</span>  <span class="string">"cookies"</span>: &#123;\<span class="keyword">n</span>    <span class="string">"cookies_are"</span>: <span class="string">"working"</span>\<span class="keyword">n</span>  &#125;\<span class="keyword">n</span>&#125;\<span class="keyword">n</span>'</span><br></pre></td></tr></table></figure>
<h2 id="十、错误与异常">十、错误与异常</h2><p>遇到网络问题（如：DNS查询失败、拒绝连接等）时，Requests会抛出一个 ConnectionError 异常。</p>
<p>遇到罕见的无效HTTP响应时，Requests则会抛出一个 HTTPError 异常。</p>
<p>若请求超时，则抛出一个 Timeout 异常。</p>
<p>若请求超过了设定的最大重定向次数，则会抛出一个 TooManyRedirects 异常。</p>
<p>所有Requests显式抛出的异常都继承自 requests.exceptions.RequestException 。</p>
<h1 id="高级用法">高级用法</h1><h2 id="一、会话对象">一、会话对象</h2><p>会话对象让你能够跨请求保持某些参数。它也会在同一个Session实例发出的所有请求之间保持cookies。</p>
<h3 id="跨请求保留一些cookies">跨请求保留一些cookies</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">In[50]</span>: <span class="string">s = requests.Session()</span></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">In[51]</span>: <span class="string">s.get('http://httpbin.org/cookies/set/sessioncookie/123456789')</span></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">Out[51]</span>: <span class="string">&lt;Response [200]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">In[52]</span>: <span class="string">r = s.get('http://httpbin.org/cookies')</span></span><br><span class="line"></span><br><span class="line"><span class="http"><span class="attribute">In[53]</span>: <span class="string">r.text</span></span><br><span class="line"></span><br><span class="line"><span class="python">Out[<span class="number">53</span>]: <span class="string">u'&#123;\n  "cookies": &#123;\n    "sessioncookie": "123456789"\n  &#125;\n&#125;\n'</span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure>
<h3 id="会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的。">会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的。</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="autoit">s = requests.Session()</span><br><span class="line">s.auth = (<span class="string">'user'</span>, <span class="string">'pass'</span>)</span><br><span class="line">s.headers.update(&#123;<span class="string">'x-test'</span>: <span class="string">'true'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="preprocessor"># both <span class="string">'x-test'</span> and <span class="string">'x-test2'</span> are sent</span></span><br><span class="line">s.get(<span class="string">'http://httpbin.org/headers'</span>, headers=&#123;<span class="string">'x-test2'</span>: <span class="string">'true'</span>&#125;)</span></span><br></pre></td></tr></table></figure>
<h2 id="二、代理">二、代理</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">  <span class="string">"http"</span>: <span class="string">"http://10.10.1.10:3128"</span>,</span><br><span class="line">  <span class="string">"https"</span>: <span class="string">"http://10.10.1.10:1080"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requests.<span class="keyword">get</span>(<span class="string">"http://example.org"</span>, proxies=proxies)</span><br></pre></td></tr></table></figure>
<p>你也可以通过环境变量 HTTP_PROXY 和 HTTPS_PROXY 来配置代理。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$ </span>export <span class="constant">HTTP_PROXY</span>=<span class="string">"http://10.10.1.10:3128"</span></span><br><span class="line"><span class="variable">$ </span>export <span class="constant">HTTPS_PROXY</span>=<span class="string">"http://10.10.1.10:1080"</span></span><br><span class="line"><span class="variable">$ </span>python</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; import requests</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; requests.get(<span class="string">"http://example.org"</span>)</span><br></pre></td></tr></table></figure>
<p>若你的代理需要使用HTTP Basic Auth，可以使用 <a href="http://user:password@host/" target="_blank" rel="external">http://user:password@host/</a> 语法:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">"http"</span>: <span class="string">"http://user:pass<span class="variable">@10</span>.10.1.10:3128/"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1><blockquote>
<p><a href="http://www.yangyanxing.com/?p=1079" target="_blank" rel="external">http://www.yangyanxing.com/?p=1079</a></p>
<p><a href="http://docs.python-requests.org/zh_CN/latest/user/advanced.html#advanced" target="_blank" rel="external">http://docs.python-requests.org/zh_CN/latest/user/advanced.html#advanced</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="基本用法">基本用法</h1><h2 id="一、发送无参数的get请求">一、发送无参数的get请求</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: r =requests.<span class="built_in">get</span>(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: <span class="built_in">print</span> r.<span class="built_in">text</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"args"</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">"headers"</span>: &#123;</span><br><span class="line">    <span class="string">"Accept"</span>: <span class="string">"*/*"</span>, </span><br><span class="line">    <span class="string">"Accept-Encoding"</span>: <span class="string">"gzip, deflate"</span>, </span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"httpbin.org"</span>, </span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"python-requests/2.7.0 CPython/2.7.10 Darwin/14.5.0"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">"origin"</span>: <span class="string">"220.231.47.169"</span>, </span><br><span class="line">  <span class="string">"url"</span>: <span class="string">"http://httpbin.org/get"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回一个名为 r 的Response对象。可以从这个对象中获取所有我们想要的信息。<br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://www.kekefund.com/tags/Python/"/>
    
      <category term="requests" scheme="http://www.kekefund.com/tags/requests/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IP代理池的实现框架(安装包)]]></title>
    <link href="http://www.kekefund.com/2016/01/04/python-ip-proxy-frame/"/>
    <id>http://www.kekefund.com/2016/01/04/python-ip-proxy-frame/</id>
    <published>2016-01-04T07:58:00.000Z</published>
    <updated>2016-01-04T08:00:02.000Z</updated>
    <content type="html"><![CDATA[<p>上一篇 <a href="http://kekefund.com/2015/11/17/pytho-ip-proxy/" target="_blank" rel="external">IP代理池的实现</a> 讲解了IP代理池的实现细节。</p>
<p>由于爬虫多个项目都需要用到IP代理，打造一个公用的IP代理库就很有必要。本文主要讲解公用的IP代理库的实现框架。</p>
<blockquote>
<p>实现思路如下：</p>
<p>1，数据抓取：从各个IP代理网站抓取大量IP数据；</p>
<p>2，数据筛选：Ping每个IP，连接速度&lt;1.5s的IP地址入库；</p>
<p>3，定时更新：设置定时任务，每日重新Ping数据库内的IP，更新连接速度；</p>
<p>4，定时新增：设置定时任务，每日定时从IP代理网站取新数据</p>
<p>5，提供获取接口</p>
</blockquote>
<a id="more"></a>
<h1 id="1，数据抓取">1，数据抓取</h1><h2 id="定义IPItem">定义IPItem</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span>:</span></span><br><span class="line">        <span class="keyword">self</span>.ip = <span class="string">''</span>    <span class="comment"># IP</span></span><br><span class="line">        <span class="keyword">self</span>.port = <span class="string">''</span>  <span class="comment"># Port</span></span><br><span class="line">        <span class="keyword">self</span>.addr = <span class="string">''</span>  <span class="comment"># 位置</span></span><br><span class="line">        <span class="keyword">self</span>.type = <span class="string">''</span>  <span class="comment"># 类型:http, https</span></span><br><span class="line">        <span class="keyword">self</span>.anonymous = <span class="string">''</span> <span class="comment"># 匿名度</span></span><br><span class="line">        <span class="keyword">self</span>.speed = -<span class="number">1</span> <span class="comment">#速度</span></span><br><span class="line">        <span class="keyword">self</span>.source = <span class="string">''</span></span><br><span class="line">        <span class="keyword">self</span>.create_time = <span class="string">''</span></span><br><span class="line">        <span class="keyword">self</span>.update_time = <span class="string">''</span></span><br></pre></td></tr></table></figure>
<h2 id="解析多个代理网站的IP，返回IPItem列表">解析多个代理网站的IP，返回IPItem列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># parse ip web</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    ip_items_haodaili =self.parse_haodaili()</span><br><span class="line">    ip_items_kuaidaili = self.parse_kuaidaili()</span><br><span class="line">    ip_items_xici = self.parse_xici()</span><br><span class="line">    ip_items_66 = self.parse_66ip()</span><br><span class="line"></span><br><span class="line">    ip_items = []</span><br><span class="line">    ip_items.extend(ip_items_haodaili)</span><br><span class="line">    ip_items.extend(ip_items_kuaidaili)</span><br><span class="line">    ip_items.extend(ip_items_xici)</span><br><span class="line">    ip_items.extend(ip_items_66)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ip_items</span><br></pre></td></tr></table></figure>
<h1 id="2，数据筛选">2，数据筛选</h1><p>多线程批量刷新ip_items，只保留ping速度在1.5s以内的ip_item。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_ip_speed</span><span class="params">(self, ip_items)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#多线程</span></span><br><span class="line">    pool = ThreadPool(processes=<span class="number">20</span>)</span><br><span class="line">    pool.map(self.ping_one_ip, ip_items)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ip_items = [item <span class="keyword">for</span> item <span class="keyword">in</span> ip_items <span class="keyword">if</span> item.speed &gt;=<span class="number">0</span> <span class="keyword">and</span> item.speed &lt; <span class="number">1500.0</span>]    <span class="comment"># 超时1.5s以内</span></span><br></pre></td></tr></table></figure>
<p>其中，ping_one_ip()函数在上一篇文章<a href="http://kekefund.com/2015/11/17/pytho-ip-proxy/" target="_blank" rel="external">IP代理池的实现</a>中有介绍。</p>
<h1 id="3，定时更新">3，定时更新</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_useful_in_db</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新数据库中的IP Speed</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_ip_speed_to_db</span><span class="params">(ip_item)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> ip_item.get_info()</span><br><span class="line">        self.ping_one_ip(ip_item)</span><br><span class="line">        <span class="keyword">print</span> ip_item.get_info()</span><br><span class="line">        sql = <span class="string">"update &#123;table&#125; set Speed=&#123;speed&#125;, UpdateTime='&#123;update_time&#125;' "</span> \</span><br><span class="line">                <span class="string">"where IP='&#123;ip&#125;' and Port='&#123;port&#125;'"</span>.format(</span><br><span class="line">                    table=mysql_table_ip,</span><br><span class="line">                    speed=ip_item.speed,</span><br><span class="line">                    update_time=GetNowTime(),</span><br><span class="line">                    ip=ip_item.ip,</span><br><span class="line">                    port=ip_item.port)</span><br><span class="line">        <span class="keyword">print</span> engine.execute(sql)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ip_items = []</span><br><span class="line"></span><br><span class="line">    df = pd.read_sql_table(mysql_table_ip, engine)</span><br><span class="line">    <span class="keyword">for</span> ix, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">        <span class="keyword">print</span> type(ix), type(row)</span><br><span class="line">        <span class="keyword">print</span> ix, row</span><br><span class="line">        ip_item = IPItem()</span><br><span class="line">        ip_item.init_from_series(row)</span><br><span class="line">        ip_items.append(ip_item)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#多线程</span></span><br><span class="line">    pool = ThreadPool(processes=<span class="number">10</span>)</span><br><span class="line">    pool.map(update_ip_speed_to_db, ip_items)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'update speed success!'</span></span><br></pre></td></tr></table></figure>
<h1 id="4，定时新增">4，定时新增</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_add</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    ip_items = self.parse() <span class="comment"># 获取ip代理网站数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'test speed begin...'</span></span><br><span class="line">    test_ip_speed(ip_items)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'test speed end'</span></span><br><span class="line"></span><br><span class="line">    save_data(ip_items)</span><br></pre></td></tr></table></figure>
<h1 id="5，获取IP代理库的接口(对外)">5，获取IP代理库的接口(对外)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取IP代理地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ip_proxy</span><span class="params">(count=<span class="number">100</span>, result_in_DataFrame = False)</span>:</span></span><br><span class="line">    sql = <span class="string">'select IP, Port, Type from &#123;0&#125; where Speed &gt; 0 order by Speed limit &#123;1&#125;'</span>.format(mysql_table_ip, count)</span><br><span class="line">    df = pd.read_sql_query(sql, engine)</span><br><span class="line">    <span class="keyword">if</span> result_in_DataFrame:</span><br><span class="line">        <span class="keyword">return</span> df</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> df[[<span class="string">'IP'</span>, <span class="string">'Port'</span>, <span class="string">'Type'</span>]].get_values()</span><br></pre></td></tr></table></figure>
<p>下载：<a href="http://7xo67b.com1.z0.glb.clouddn.com/IpProxy-1.0.tar.gz" target="_blank" rel="external">安装包</a></p>
<h2 id="使用方法：">使用方法：</h2><h3 id="1，安装">1，安装</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ tar -zxvf IpProxy-<span class="number">1.0</span><span class="class">.tar</span><span class="class">.gz</span></span><br><span class="line"></span><br><span class="line">$ cd IpProxy-<span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">$ sudo python setup<span class="class">.py</span> install</span><br></pre></td></tr></table></figure>
<h3 id="2，使用">2，使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="keyword">from</span> ip_proxy <span class="keyword">import</span> get_ip_proxy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: get_ip_proxy(count=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">array([[<span class="string">u'123.56.177.156'</span>, <span class="string">u'8080'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'101.200.202.168'</span>, <span class="string">u'80'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'101.200.202.168'</span>, <span class="string">u'80'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'101.201.221.168'</span>, <span class="string">u'20151'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'101.201.221.168'</span>, <span class="string">u'20151'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'101.201.221.168'</span>, <span class="string">u'20151'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'114.112.103.21'</span>, <span class="string">u'3128'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'101.200.234.114'</span>, <span class="string">u'8080'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'114.112.103.21'</span>, <span class="string">u'3128'</span>, <span class="string">u'http'</span>],</span><br><span class="line"></span><br><span class="line">       [<span class="string">u'114.112.103.21'</span>, <span class="string">u'3128'</span>, <span class="string">u'http'</span>]], dtype=object)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n [<span class="number">8</span>]: get_ip_proxy(count=<span class="number">10</span>, result_in_DataFrame=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">                IP   Port  Type</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>   <span class="number">123.56</span><span class="number">.177</span><span class="number">.156</span>   <span class="number">8080</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>  <span class="number">101.200</span><span class="number">.202</span><span class="number">.168</span>     <span class="number">80</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>  <span class="number">101.200</span><span class="number">.202</span><span class="number">.168</span>     <span class="number">80</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>  <span class="number">101.201</span><span class="number">.221</span><span class="number">.168</span>  <span class="number">20151</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>  <span class="number">101.201</span><span class="number">.221</span><span class="number">.168</span>  <span class="number">20151</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>  <span class="number">101.201</span><span class="number">.221</span><span class="number">.168</span>  <span class="number">20151</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>   <span class="number">114.112</span><span class="number">.103</span><span class="number">.21</span>   <span class="number">3128</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>  <span class="number">101.200</span><span class="number">.234</span><span class="number">.114</span>   <span class="number">8080</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">8</span>   <span class="number">114.112</span><span class="number">.103</span><span class="number">.21</span>   <span class="number">3128</span>  http</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>   <span class="number">114.112</span><span class="number">.103</span><span class="number">.21</span>   <span class="number">3128</span>  http</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇 <a href="http://kekefund.com/2015/11/17/pytho-ip-proxy/">IP代理池的实现</a> 讲解了IP代理池的实现细节。</p>
<p>由于爬虫多个项目都需要用到IP代理，打造一个公用的IP代理库就很有必要。本文主要讲解公用的IP代理库的实现框架。</p>
<blockquote>
<p>实现思路如下：</p>
<p>1，数据抓取：从各个IP代理网站抓取大量IP数据；</p>
<p>2，数据筛选：Ping每个IP，连接速度&lt;1.5s的IP地址入库；</p>
<p>3，定时更新：设置定时任务，每日重新Ping数据库内的IP，更新连接速度；</p>
<p>4，定时新增：设置定时任务，每日定时从IP代理网站取新数据</p>
<p>5，提供获取接口</p>
</blockquote>]]>
    
    </summary>
    
      <category term="IP代理" scheme="http://www.kekefund.com/tags/IP%E4%BB%A3%E7%90%86/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://www.kekefund.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[日本蜡烛线理论]]></title>
    <link href="http://www.kekefund.com/2015/12/17/japan-candle-diagram-theory/"/>
    <id>http://www.kekefund.com/2015/12/17/japan-candle-diagram-theory/</id>
    <published>2015-12-17T08:11:06.000Z</published>
    <updated>2015-12-17T08:23:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一、基本理论及原则">一、基本理论及原则</h2><ul>
<li>信息量</li>
</ul>
<p>“信息量”的概念对应着包含在价格数据中的“含金量”：</p>
<blockquote>
<ol>
<li><p>任何市场资料所信息量均有限</p>
</li>
<li><p>任何技术分析手段所提取的信息量只可能少于信息量的极限，绝不可能多于信息量的极限；</p>
</li>
<li><p>对于相同的市场资料，虽然可能采取不同的技术分析手段，但是所得信息量均限于上述极限之内，因此它们的结果有可能是相互重叠的。</p>
</li>
</ol>
</blockquote>
<hr>
<ul>
<li>杰西·利弗莫尔：只有离开研究对象一定的距离，才能更好地观察它的全貌。技术分析就是让我们退后一步来观察市场，如此才使我们对市场获得了一份不同寻常的，或许也更加贴切的观感。<a id="more"></a>
</li>
</ul>
<hr>
<ul>
<li>如果我们要观察总体的供给–需求关系，那么，观察价格变化显然是最直观、最容易进行的一种方法，有些基本面的消息，普通的投资大众可能根本无缘得知，但是您可以正确地预期，它们一定已经包含在价格信息之内了。如果有人先于大家掌握了某种推动市场变化的情报，那么，他极可能抢先在市场上买进或者卖出，直到价格变化抵消了他的情报才会罢手。如此一来，在有些情况下，这类消息可能早在当初事件的时候就被市场消化吸收掉了。一言以蔽之，当前的市场价格应当充分反应了当前发送的一切市场信息，不论这些信息是普通大众已经知晓的，还是仅仅掌握在极少数人手重的。</li>
</ul>
<hr>
<ul>
<li>“市场永远不会错”，绝不可带着“市场错了”的成见进行交易。</li>
</ul>
<p>千万不要将自己的主观臆断强加于市场。举例来说，即使您坚定地判断原油市场即将上涨也必须等到市场趋势果真向上出头的时候才能买进。</p>
<p>绝不可将自己的意愿强加于市场，一定要做一个追随趋势者，不要做一个预测趋势者。如果您怀着看涨的预期，那么就在上升趋势中入市；如果您持有看跌的预期，那么就在下降趋势中入市。</p>
<hr>
<ul>
<li>采取保护性止损措施的重要性</li>
</ul>
<p>我们应当在最初建立交易头寸的时候，就设置好止损水平，只有在这个时候，我们才是最冷静、客观的。只有在市场的演变符合我们本来的预期的条件下才能继续持有当初的交易头寸。如果后来的价格变化与我们的预期相反，或者哪怕只是未能证实我们的预期，届时应当当机立断，平仓出市。</p>
<pre><code><span class="bullet">- </span>请不要忘记下列两项事实：

<span class="blockquote">&gt; 1. 所有的长期趋势都是由短期趋势开头的</span>

<span class="blockquote">&gt; 2. 市场上绝无一厢情愿的余地，市场自行其是，既不在意您的想法，也不关心您的头寸。</span>
</code></pre><hr>
<ul>
<li><p>市场并不在乎您是不是顺从了它的趋势。有一件事比犯错误还要命，那便是坚持错误。宁可放弃您的高见，不要丧失您的金钱。有能力及早纠正自己的错误，其实是一件值得自豪的事。被市场落实了止损指令，就意味着认错服输。人们对承认错误深恶痛绝，因为这里面往往牵扯上了个人的自尊心和名声等。优秀的交易商从不过于固执己见。据说，沃伦巴菲特信奉两项原则：</p>
<blockquote>
<ol>
<li><p>保全资本金。</p>
</li>
<li><p>绝不可忘记原则1.</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<p>拿日本人的话来说，“只要钓得上蛙鱼，丢个把鱼钩是值得的。”如果您被止损出市，那就当失去一把鱼钩，没准，下一钩就能钓上一条大家伙。</p>
<hr>
<ul>
<li>下面这句话常常挂在房地产经纪人的嘴边：“对房地产最有影响力的三项因素是：地点，地点，地点。”。如果我们把这句话借用到我们这个行业来，那就是，市场最重要的三个方面是：趋势、趋势、趋势。</li>
</ul>
<hr>
<h2 id="二、技术指标">二、技术指标</h2><h3 id="1，极限转换原则">1，极限转换原则</h3><p>日本人有句谚语：“大红的真漆盘子无需另加装饰”。这种“简单的就是美好的”的概念，道破了市场技术分析理论的真谛。</p>
<p>这一原则既简单明白，又犀利、得力——过去的支撑水平演化为新的阻挡水平；过去的阻挡水平演化为新的支撑水平。这就是所说的“极性转换原则”。</p>
<p>下图左卫支撑水平转化为阻挡水平的情形。下图右室过去的阻挡水平转化为新的支撑水平的情形。</p>
<h4 id="极性转换现象的技术潜力的大小与以下几个方面成正比：">极性转换现象的技术潜力的大小与以下几个方面成正比：</h4><blockquote>
<p>1、市场对过去的支撑/阻挡水平曾进行试探的次数；</p>
<p>2、每次试探时的交易量、持仓量的大小。</p>
</blockquote>
<h3 id="2，百分比回撤水平">2，百分比回撤水平</h3><p>通常，市场既不会直线上升，也不会径直跌落，而是进两步、退一步。在当前趋势继续发展之前，市场通常先要对已经形成的上涨进程或下跌进程作出一定程度的回撤。</p>
<p>在这类回撤水平中，较为常用的是50%回撤水平，以及38%和62%的斐波那契回撤水平。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210huiche.png" alt=""></p>
<h3 id="3，移动平均线">3，移动平均线</h3><p>在比较流行的移动平均线中，对短线的交易商来说，包括4天、9天、18天移动平均线；对操作长期头寸的市场参与者来说，包括13周、26周、40周移动平均线。</p>
<p>在日本，13周和40周移动平均线最为常用。</p>
<ul>
<li>移动平均线的用法</li>
</ul>
<blockquote>
<p>1、通过比较价格与移动平均线的相对位置，构成一个趋势目标。举例来说，如果我们判断市场正处于中期的上升趋势中，那么有一个很好的衡量标准，就看价格是不是居于65天移动平均线的上方。而对于更长期的上升趋势来说，价格必须高于40周移动平均线。</p>
</blockquote>
<p>2、利用移动平均线构成支撑水平或阻挡水平。当收市价向上超越某一条特定的移动平均线时，可能构成看涨的信号。而当收市价向下低于某个移动平均线时，构成看跌的信号。</p>
<p>3、跟踪移动平均线波幅带（也称为包络线）。这些波幅带是将移动平均线向上或向下平移一定的百分比后形成的，它们也起到支撑或阻挡作用。</p>
<p>4、观察移动平均线的斜率。举例来说，如果移动平均线在一段持续稳步的上升之后转向水平发展，乃至开始下降，那么可能构成了一个看跌信号。在移动平均线上作趋势线，是监测其斜率变化的一个简单易行的办法。</p>
<p>5、利用双移动平均线系统来交易。</p>
<h3 id="4，双移动平均线">4，双移动平均线</h3><p>两根移动平均线组合在一起，可构造成一个超买/超卖指标，也就是摆动指数。</p>
<p>把较短期的移动平均线减去较长期的移动平均线，就得到了这个摆动指数的值。该指数既可以是正值，也可以为负值。</p>
<blockquote>
<p>1、如果短期移动平均线相对来说较大幅度地高于（或低于）长期移动平均线，那么我们就认为市场处于超买状态（或超卖状态）。</p>
</blockquote>
<p>2、如果短期移动平均线向上穿越了长期移动平均线，这就是一个看涨信号。在日本，这样的移动平均线交叉信号称为黄金交叉。与上述相反的情形，当短期移动平均线向下穿越长期移动平均线时，构成了一个看跌的死亡交叉信号。</p>
<h3 id="5，相对力度指数">5，相对力度指数</h3><p>在期货交易商中，相对力度指数（RSI）是最流行的技术工具之一。在RSI研究中9天和14天是最常用的两种时间参数。</p>
<ul>
<li>如何计算RSI</li>
</ul>
<p>首先分布累加出一定时间之内上涨的价格幅度之和与下跌的价格幅度之和，然后再求得两者的比值。在计算过程中，一般仅采用收市价作为价格数据。它的计算公式是：</p>
<p>RSI = 100 - 100 /  ( 1 + RS ) </p>
<p>其中，RS = 该时期上涨价格幅度的平均值/该时期内下跌价格幅度的平均值。</p>
<ul>
<li>如何运用RSI</li>
</ul>
<p>RSI的两个主要用途是：构成超买/超卖指标，作为监测相互背离现象的工具。</p>
<p>当RSI向上趋近其取值范围的上边界时（即，当它高于70或80时），表明市场处于超买状态。在这样的情况下，市场也许变得比较脆弱，容易引发向下回落的过程，或者即将转入横向调整阶段；与此相反，当RSI处于其取值范围的下边界时（通常低于30或20），则认为RSI反映了超卖状态。在这样的环境下，市场有可能形成空头买入平仓行情。</p>
<p>利用RSI揭示相互背离现象的具体方法是：当价格向上创出当前趋势的新高时，RSI却没有形成新高，未能与之配合，这就构成了一个负面相互背离信号，可能是一个看跌信号；当价格向下跌出当前趋势的新低时，RSI却没有形成新低，则构成了正面的相互背离现象。 </p>
<h3 id="6，随机指数">6，随机指数</h3><p>随机（摆动）指数，既提供了超买和超卖状态的读数指示，也能够揭示相互背离现象，还提供了一套比较短期趋势与长期趋势的机制。</p>
<p>随机指数把最近的收市价格，同一定时间范围内市场的总的价格范围进行比较。随机指数的数值处在0到100之间。</p>
<p>当随机指数的读数较高时，就意味着当前的收市价在一定时期的整个价格范围中接近上端的水平。</p>
<p>当随机指数的读数较低时，就意味着当前的收市价在一定时期的整个价格范围中接近下端的水平。</p>
<p>随机指数的设计思想是：<strong>当市场向上运动时，收市价格倾向于接近上述价格区间的高点；当市场向下运动时，价格往往集中在上述价格区间的低点附近。</strong></p>
<ul>
<li>如何计算随机指数</li>
</ul>
<p>随机指数的图表由两根曲线组成，它们分别是%K线和%D线。其中，%K线称为原始随机线，或者称为快%K线。这条曲线最为灵敏，%K线值的计算公式是：</p>
<pre><code>%<span class="keyword">K</span> =（收市价 - <span class="keyword">N</span>天内的最低价） / （<span class="keyword">N</span>天内的最高价 - <span class="keyword">N</span>天内的最低价）* <span class="number">100</span>%
</code></pre><p>N值，取9、14、21个时间单位是几个较为常见的时间参数。</p>
<p>以快%K线为基础，每三个数值计算出一个移动平均值，得出一条较为平滑的三时间单位移动平均线。这条%K线的三时间单位移动平均线就称为慢%K线。</p>
<p>以慢%K线再进行一次三时间单位的移动平均，得到了慢%K线的三时间单位移动平均线，称为%D线。</p>
<ul>
<li><p>如何应用随机指数</p>
<ul>
<li><p>当慢%K线向下穿过%D线时，构成卖出信号；</p>
</li>
<li><p>当慢%K线向上穿过%D线时，构成买入信号。</p>
<p>具体来说，为了构成一个买入信号，需要满足以下三个条件：</p>
</li>
</ul>
<ul>
<li><p>首先，市场必须处在超卖状态（随机指数的%D值为25%或更低）；</p>
</li>
<li><p>其次，市场已经发生了正面相互背离现象；</p>
</li>
<li><p>最后，慢%K线向上穿越了%D线。</p>
</li>
</ul>
</li>
</ul>
<h3 id="7，动力指数">7，动力指数</h3><p>又称为价格速度指数。该指数度量的是，当前的收市价与一定天数之前的收市价之差。如果我们研究10日动力指数，那么我们比较的就是今天的收市价与10日之前的收市价。</p>
<p>在上升趋势的发展过程中，上述价格差应当以逐步加快的速度增长。这样的情况显示了该上升趋势具有逐步增长的驱动力。如果价格上涨，而动力指数转为持平，那么说明当前的价格趋势处于减速状态。这可能构成了一个早期的警告信号，说明当前的价格趋势可能会结束。如果动力指数向下越过零线，则形成了一个看跌信号；而当它向上穿越零线时，则是一个看涨信号。</p>
<p>动力指数也是一种现成的超买/超卖指标。举例来说，当动力指数为一个相对较大的正值时，市场可能处在超买状态，容易发生回落行情。<strong>动力指数通常在价格达到顶峰之前预先达到顶点。根据这一特点，当动力指数处于极为超买的读数状况时，可能预示着一个价格高峰的形成。</strong></p>
<p>动力指数的另一种用途是，它能够为市场的超买或超卖状体提供一个具体尺度。</p>
<h3 id="8，交易量">8，交易量</h3><p>交易量的技术意义是，一段行情的交易量越重，则这段行情背后的市场力量越强大。只要交易量保持增长的态势，那么，当前的价格趋势就将持续下去。但是如果在价格趋势发展时，交易量不增反降，那么，判断当前趋势仍将继续发展的理由就不充分了。另外，我们还可以通过交易量来验证市场的顶部或底部过程。当市场向下试探某一支撑水平时，如果交易量较轻，则意味着卖出压力减弱了，因此构成了一个看涨信号。反过来，当市场向上试探先前的高点时，如果交易量较轻，则证明买进力量减弱了，构成了一个看跌信号。</p>
<h3 id="9，权衡交易量（OBV）">9，权衡交易量（OBV）</h3><p>权衡交易量（OBV）是一种交易量的累计净值。从一个基准日开始，当某一天的收市价高于前一天的收市价时，则将该日的交易量数值加到前一天的权衡交易量数值上；如果某一天的收市价低于前一日的收市价，则该日的交易量就从前一天累计的权衡交易量数值中减去。<br>OBV验证趋势。OBV应当朝着当前主要趋势的方向运动。如果价格与OBV双双上涨，则说明由买方引起的交易量正在上升，即便在较高的价位上，也能达成较高的交易量。这可能构成一个看涨信号。</p>
<p>如果情况与上述方向相反，价格与OBV一齐下跌，就反映出在较低的价位上，由卖方引起的交易量也在增长，说明价格下降的过程仍将持续。</p>
<p>在横向交易区间中，也可以应用OBV。如果在价格保持稳定时（最好是在较低的价位上保持稳定），OBV开始升高，这可能揭示了一个筹码搜集的过程。这种局面预示着上涨行情的到来。</p>
<p>如果价格持平运动，而OBV正在下跌，则反映出一个筹码派发的过程。这种局面可能具有看跌的意义，特别是当它发生在高价格水平时。</p>
<h3 id="10，持仓量">10，持仓量</h3><p>持仓量的作用与交易量有些类似，也有助于衡量价格运动背后的市场力度。根据持仓量的增减，我们就可以判断资金是流入某一市场，还是流出某一市场。因此，它就具备了上述用途。持仓量的上升或下降，取决于两方面因素的消长对比：新入市的买入者或卖出者的数额，与新出市的原有交易者的数额。</p>
<p>如果在上升趋势中持仓量是上升的，则一般来说，牛方占据主动，上涨行情仍将持续；如果在下降趋势中持仓量是上升的，则说明熊方占据主动，下跌行情仍将持续。</p>
<p>如果在市场上扬时，持仓量下降，那么这段上涨行情是由于空头买入平仓行为所引起的（以及原来的多头者趁机对冲头寸）。等到原有的这群空头者逃离了该市场，那么上述上涨行情（即空头买进平仓行情）背后的驱动力也随之瓦解，这就意味着当前的市场较为脆弱，容易诱发进一步的疲弱行情。</p>
<p>我们不妨打个比方，假定有一根水管接在自来水干线上。在自来水干线与这条水管之间安装了一个水龙头。上升的持仓量相当于打开了水龙头，从自来水干线向水管里输入自来水，那么，只要水龙头是开着的，就会不断地从水管里面流出水来（这就相当于上升的持仓量将价格进一步推高或推低）。下降的持仓量好像是关上了水龙头，开始，还有水从水管子里面流出来（因为水管于里面还有一些剩水），但是一旦剩水全部滴出来了，就不再有新的来源维持水流了。结果，水流（相当于价格趋势）就会枯竭。</p>
<p>当市场处于新高水平时，如果持仓量恰巧也达到了异乎寻常的高水平，可能预示着市场即将陷入困境，这是因为，上升的持仓量意味着新的空头者和新的多头者正在进入市场。如果市场处于稳步上涨的上升趋势中，那么，这些新的多头者将会随着价格水平的逐步上升，逐步提高卖出止损指令的水平。万一价格突然下滑，将引发执行止损指令的连锁反应，有可能导致价格的狂泻。</p>
<h3 id="11，_期权">11， 期权</h3><p>为了确定一份期货期权合约的理论价格，我们需要五个方面的参数。它们分别是：</p>
<pre><code>-<span class="ruby"> 执行价格
</span>
-<span class="ruby"> 有效期限
</span>
-<span class="ruby"> 基本市场的预测价格
</span>
-<span class="ruby"> 基本市场的波动性
</span>
-<span class="ruby"> 短期利率的水平</span>
</code></pre><p>在这些自变量中，有三项是已知的（有效期限、执行价格、短期利率）。</p>
<p>在决定期权价格的所有因素中，绝不可以低估波动性的重要性。事实上，在某些情况下，波动性的变化对期权价格的影响，甚至超过了相应的期货合约的价格变化所带来的影响。</p>
<p>所谓波动性，指的是人们预期今后一年之内对应基本市场的价格变化范围（波动性水平式按年计算的）。</p>
<p>在期权交易中，必须对未来的市场波动性作出预测。预测市场波动性的一种方法是，由市场价格提供这样的预测值。事实上，这就是所谓蕴含波动性的来历。蕴含波动性，就是市场对期权有效期内相应的基本期货合约的波动性的估计，是蕴含在当前期权价格之中的波动性水平。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="一、基本理论及原则">一、基本理论及原则</h2><ul>
<li>信息量</li>
</ul>
<p>“信息量”的概念对应着包含在价格数据中的“含金量”：</p>
<blockquote>
<ol>
<li><p>任何市场资料所信息量均有限</p>
</li>
<li><p>任何技术分析手段所提取的信息量只可能少于信息量的极限，绝不可能多于信息量的极限；</p>
</li>
<li><p>对于相同的市场资料，虽然可能采取不同的技术分析手段，但是所得信息量均限于上述极限之内，因此它们的结果有可能是相互重叠的。</p>
</li>
</ol>
</blockquote>
<hr>
<ul>
<li>杰西·利弗莫尔：只有离开研究对象一定的距离，才能更好地观察它的全貌。技术分析就是让我们退后一步来观察市场，如此才使我们对市场获得了一份不同寻常的，或许也更加贴切的观感。]]>
    
    </summary>
    
      <category term="K线" scheme="http://www.kekefund.com/tags/K%E7%BA%BF/"/>
    
      <category term="期货" scheme="http://www.kekefund.com/tags/%E6%9C%9F%E8%B4%A7/"/>
    
      <category term="股票" scheme="http://www.kekefund.com/tags/%E8%82%A1%E7%A5%A8/"/>
    
      <category term="蜡烛图" scheme="http://www.kekefund.com/tags/%E8%9C%A1%E7%83%9B%E5%9B%BE/"/>
    
      <category term="Stock" scheme="http://www.kekefund.com/categories/Stock/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[日本蜡烛线形态]]></title>
    <link href="http://www.kekefund.com/2015/12/10/japan-candle-diagram-technique/"/>
    <id>http://www.kekefund.com/2015/12/10/japan-candle-diagram-technique/</id>
    <published>2015-12-10T03:09:01.000Z</published>
    <updated>2016-01-21T01:16:06.000Z</updated>
    <content type="html"><![CDATA[<p>日本蜡烛线形态</p>
<h3 id="1，纺锤线">1，纺锤线</h3><p>实体较短，说明熊方与牛方正处于胶着状态，一时难分高下。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210fangchuixian2.jpg" alt=""></p>
<h3 id="2，锤子线与上吊线">2，锤子线与上吊线</h3><p>下图中的蜡烛图线具有明显的特点：它们的下影线较长，而实体较小并且在其全天价格区间里，实体处在接近顶端的位置上。<br><a id="more"></a></p>
<p><strong>锤子线</strong>：出现在下降趋势中时，成为锤子线，意思是说“市场正用锤子穷砸底部”。在日语中，这类蜡烛线原来的名称是“深水竿”，大体的意思是“试一下水的深浅”。 </p>
<p><strong>上吊线</strong>：出现在上冲行情之后，就表明之前的市场运动也许结束，称为上吊线。这类蜡烛线看上去像吊在绞刑架上双腿晃荡的一个死人。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210cuizhixian.png" alt=""></p>
<blockquote>
<p>注：锤子线或上吊线的实体颜色不重要，可以是白色或黑色。</p>
</blockquote>
<h4 id="锤子线和上吊线的识别标准">锤子线和上吊线的识别标准</h4><blockquote>
<p>1、实体处于整个价格区间的上端。而实体本身的颜色是无所谓的。</p>
<p>2、下影线的长度至少达到实体高度的2倍。</p>
<p>3、在这类蜡烛线中，应当没有上影线，即使有上影线，其长度也是极短的。</p>
<p>4、锤子线之前，必定先有一段下降趋势（哪怕是较小规模的下降趋势），这样锤子线才能逆转这个趋势。</p>
<p>5、上吊线必须出现在一段上升趋势之后。</p>
<p>6、在上吊线出现后，还需要其它看跌信号的验证。这一原则的重要性，在下图中也得到了体现。在上吊线的看跌验证信号中，有一种情况是，次日的开市价低于上吊线的实体，这是为上吊线求得证实的第一个方法。</p>
</blockquote>
<p><em>上吊线的实体与上吊线次日的开市价之间向下的缺口越大，那么上吊线就越有可能构成市场的顶部。在上吊线之后，如果市场形成了一条黑色的实体，并且它的收市价低于上吊线的收市价，那么，这也可以看作上吊线成立的一种佐证。</em></p>
<blockquote>
<p>PS：上吊线的下影线长度并不是非得达到实体高度的2倍不可，才足以构成反转信号。一般来说，在这类形态中，下影线越长，形态就越完美。</p>
</blockquote>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210shangdiaoxian.png" alt=""></p>
<h3 id="3，吞没形态">3，吞没形态</h3><ul>
<li>看涨吞没形态</li>
</ul>
<p>下图左中，市场本来处于下降趋势之中，但是后来出现了一根坚挺的白色实体，这个白色实体将它前面的那根黑色实体“抱进怀里了”，或者说把它吞没了。这种情形说明市场上买进的压力已经压倒了卖出压力。</p>
<ul>
<li>看跌吞没形态</li>
</ul>
<p>下图右中，市场原本正向着更高的价位趋升，但是当前一个白色实体被后一个黑色实体吞没后，就构成了顶部反转信号。这种情形说明，熊方已经从牛方手中夺走了统治权。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210tunmo.png" alt=""></p>
<h4 id="吞没形态的判别标准:"><strong>吞没形态的判别标准:</strong></h4><blockquote>
<ol>
<li><p>在吞没形态之前，市场必须处在清晰可辨的上升趋势或下降趋势中，哪怕这个趋势只是短期的。</p>
</li>
<li><p>吞没形态必须由2条蜡烛线组成。其中第二根蜡烛线的实体必须覆盖第一根蜡烛线的实体（但是不一定需要吞没前者的上下影线）。</p>
</li>
<li><p>吞没形态的第二个实体必须与第一个实体的颜色相反。这一条标准有例外的情况，条件是，第一条蜡烛线的实体必须非常小，小得几乎构成了一根十字线（或者它就是一根十字线）。如此一来，如果在长期的下降趋势之后，一个小小的白色实体为一个巨大的白色实体所吞没，那么也可能构成了底部反转形态。反之，在上升趋势中，如果一个小小的黑色实体为一个巨大的黑色实体所吞没，那么也可能构成顶部反转形态。</p>
</li>
</ol>
</blockquote>
<h4 id="如果吞没形态具有下面的特征，那么它们构成重要反转信号的可能性将大大地增强:"><strong>如果吞没形态具有下面的特征，那么它们构成重要反转信号的可能性将大大地增强: </strong></h4><blockquote>
<ol>
<li><p>在吞没形态中，第一天的实体非常小，而第二天的实体非常大。这种情况可能说明原有趋势的驱动力正在消退，而新趋势的潜在力量正在壮大。</p>
</li>
<li><p>吞没形态出现在超长期的或非常急剧的市场运动之后。如果存在超长期的上升趋势，则增加了以下这种可能性，潜在的买家已经入市买进，持有多头。在这种情况下，市场可能缺少足够的新的多头头寸的供应，无力继续推动市场上升。如果存在非常急剧的市场运动，则市场可能已经朝一个方向走得太远，容易遭受获利平仓头寸的打击。</p>
</li>
<li><p>在吞没形态中，第二个实体伴有超额的交易量这种情形可能属于胀爆现象。</p>
</li>
<li><p>在吞没形态中，第二天的实体向前吞没的实体不止一个。</p>
</li>
</ol>
</blockquote>
<h3 id="4，乌云盖顶形态（乌云线形态）">4，乌云盖顶形态（乌云线形态）</h3><p>这种形态是由两根蜡烛线组成的，属于顶部反转形态。它们一般出现在上升趋势之后，在有些情况下也可能出现在水平调整区间的顶部。在这一形态中，第一天是一根坚挺的白色实体；第二天的开市价超过了第一天的最高价（这就是超过了第一天的上影线的顶端），但是，市场却收市在接近当日的最低价的水平，并且收市价明显地向下扎入到第一天白色实体的内部。</p>
<p>有些日本技术分析师要求，第二天黑色实体的收市价必须向下穿过前一天白色实体的50%。如果黑色实体的收市价没有向下穿过白色蜡烛线的中点，那么，我们最好等一等，看看是否还有进一步的看跌验证信号。</p>
<h4 id="如果乌云盖顶形态具有这样的特征，则有助于增强其技术分量："><strong>如果乌云盖顶形态具有这样的特征，则有助于增强其技术分量：</strong></h4><blockquote>
<p>1、在乌云盖顶形态中，黑色实体的收市价向下穿入前一个白色实体的程度越深则该形态构成市场顶部的机会越大。如果黑色实体覆盖了前一天的整个白色实体，那就是看跌吞没形态。</p>
<p>2、乌云盖顶形态发生在一个超长期的上升趋势中，它的第一天是一根坚挺的白色实体，其开市价就是最低价（就是说，是秃脚的），而且其收市价就是最高价（就是说，是秃头的）；它的第二天是一根长长的黑色实体，其开市价位于最高价，而但收市价位于最低价（这是一个秃头秃脚黑色蜡烛线）。</p>
<p>3、在乌云盖顶形态中，如果第二个实体（即黑色的实体）的开市价高于某个重要的阻挡水平，但是市场未能成功地坚守住，那么可能证明牛方已经无力控制市场了。</p>
<p>4、如果在第二天开市的时候，市场的交易量非常大，那么这里就可能发生胀爆现象。具体说来，当日开市价创出了新高。而且开市时的成交量极重，可能意味着很多新买家终于下决心入市，踏上了牛市的“船”。随后，市场却发生了抛售行情。对期货交易商来说，极高的持仓量也是一种警告信号。</p>
</blockquote>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210wuyun.png" alt=""></p>
<h3 id="5，刺透形态（斩回线形态）">5，刺透形态（斩回线形态）</h3><p>刺透形态是乌云盖顶形态的反面形态，是底部反转信号。</p>
<p>斩回线形态出现在下跌的市场上，也是由两根蜡烛线组成的。其中第一根蜡烛线具有黑色实体，而第二根蜡烛线则具有长长的白色实体。在白色蜡烛线这一天，市场的开市价曾急剧地下跌至前一个黑色蜡烛线的最低价之下，但是不久市场又将价格推升回来，形成了一根相对较长的白色实体，并且其收市价已经向上超越了前一天的黑色实体的中点。</p>
<p>在斩回线形态中，白色蜡烛线的实体必须向上推进到黑色蜡烛线实体的中点之上。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210citou.png" alt=""></p>
<h3 id="6，星线">6，星线</h3><p>星线的实体较小，并且在它的实体与它前面的较大的蜡烛线的实体之间形成了价格跳空。只要星线的实体与前一个实体没有任何重叠，那么这个星线就是成立的。</p>
<p>星线本身的颜色并不重要。星线既可能出现在市场的顶部，也可能出现在市场的底部。如果星线的实体已经缩小为十字线，称为十字星线。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210xingxian.png" alt=""></p>
<p>当星线，尤其是十字星线出现时，就是一个警告信号，表明当前的趋势获取好景不长了。星线的较小的实体显示，熊方和牛方的较量已经转入僵持状态。</p>
<h4 id="a、启明星形态">a、启明星形态</h4><p>启明星形态属于底部反转形态。它的名称的由来是，这个形态预示着价格的上涨就像启明星（水星）预示着太阳的升起一样。在本形态中，先是一根长长的黑色实体，随后是一根小小的实体，并且在这两个实体之间形成了一个向下跳空（这两条蜡烛线组成了基本的星线形态）。第三天是一根白色实体，它明显地向上推进到了第一天的黑色实体之内。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210qimingxing.png" alt=""></p>
<p>在理想的启明星形态中，中间蜡烛线（即星线）的实体，与它前、后两个实体之间均有价格跳空。后面的那个价格跳空较为少见，不过，即使没有后面这个价格跳空，似乎也不会削减启明星形态的技术效力。</p>
<h4 id="b、黄昏星形态">b、黄昏星形态</h4><p>黄昏星是启明星的顶部对等形态，是看跌的、它的名称的由来也是显而易见的。因为黄昏星（金星）恰好出现在夜幕即将降临之际，既然黄昏星是顶部反转形态，那么，它只有出现在上升趋势之后，才能发挥其技术效力。</p>
<p>黄昏星形态是由三根蜡烛线组成的。在前面两根蜡烛线中，第一根是一根长长的白色实体，后一根是一根星线。星线的出现，是顶部形态的第一个征兆。第三根蜡烛线证实了顶部过程的发生，完成了这个三线形态的黄昏星形态。第三根蜡烛线具有黑色实体，它剧烈地向下扎入第一天的白色实体的内部。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210huanghunxing.png" alt=""></p>
<h5 id="黄昏星形态或启明星形态兼具这样的特征。则有助于增加它们构成反转信号的机会。"><strong>黄昏星形态或启明星形态兼具这样的特征。则有助于增加它们构成反转信号的机会。</strong></h5><blockquote>
<p>1、如果在第一根蜡烛线的实体与星蜡烛线的实体之间存在价格跳空，并且在星线的实体与第三根蜡烛线的实体之间也存在价格跳空。</p>
<p>2、如果第三根蜡烛线的收市价深深地向下扎入第一根蜡烛线的实体之内。</p>
<p>3、如果第一根蜡烛线的交易量较轻，而第三根蜡烛线的交易量较重。这一点表明了原先趋势力量的衰减，以及新趋势力量的增长。</p>
</blockquote>
<h4 id="c、十字线形态">c、十字线形态</h4><p>如果在上升趋势中出现了一根十字线，并且这个十字线与前一个实体之间形成了向上的价格跳空；或者在下降趋势中出现了一根十字线，并且与前一个实体之间形成了向下的价格跳空，那么这根十字线就称为十字星线。</p>
<p>十字星线的出现，构成了潜在的警告信号，表明市场的当前趋势已经易于发生变化了。</p>
<p>在上升趋势中，如果在十字星线后跟随着一根长长的黑色实体，并且它的收市价深深地向下扎入十字星线之前的白色实体的内部，那么，这根黑色实体就构成了市场顶部反转过程的验证信号。这样的形态就称为<strong>十字黄昏星形态</strong>。</p>
<p>在下降趋势中，如果在一根黑色实体之后，跟随着一根十字星线，第三根蜡烛线是一根坚挺的白色蜡烛线，并且它的收市价显著地向上穿入第一根黑色实体之内，那么，该底部反转信号就得到了第三根蜡烛线的验证，这个三蜡烛线形态称为十字启明星形态。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210shizixing.png" alt=""></p>
<p>如果市场上出现了一根向上跳空的十字星线，它的后面再跟着一条向下跳空的黑色蜡烛线，并且在这根黑色蜡烛线的上影线与十字星线的下影线直接也形成了价格跳空，那么，这根十字星线就构成了一个主要顶部反转信号。这种形态称为弃婴顶部形态。非常罕见！</p>
<p>弃婴底部形态与顶部对应。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210qiying.png" alt=""></p>
<h4 id="d、流星形态">d、流星形态</h4><p>流星形态是一种二蜡烛线形态，它发出警告信号，表明市场顶部就再眼前。它的外观如其名称，象一颗流星，本形态的技术意义不如黄昏星形态强，通常不构成主要反转信号。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210liuxing.png" alt=""></p>
<p>在流星形态中，流星线具有较小的实体，而且实体处于其价格区间的下端，同时，流星线的上影线较长。</p>
<p>在理想的流星形态中，流星线的实体与前一根蜡烛线的实体之间存在价格跳空。不过价格跳空并不是非有不可。       </p>
<h4 id="e、倒锤子线">e、倒锤子线</h4><p>在下降趋势后，如果出现了与流星线外观一致的蜡烛线，则可能构成一个看涨信号。这样的蜡烛线称为<strong>倒锤子线</strong>。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210daochuizi.png" alt=""></p>
<p>倒锤子线看上去与流星线颇为相象，它也具有较长的上影线，较小的实体，并且实体居于整个价格范围的下端。但不同的是，流星线是一根顶部反转蜡烛线，而倒锤子线却是一根底部反转蜡烛线。如果倒锤子线出现在下降趋势之后，则构成一个看涨的蜡烛图形态。</p>
<p>在分析倒锤子线时，有一点非常重要：当倒锤子线出现后，必须等待下一个时间单位的看涨信号对它加以验证。</p>
<h5 id="倒锤子线的验证信号可能采取下面的形式：">倒锤子线的验证信号可能采取下面的形式：</h5><blockquote>
<ol>
<li><p>倒锤子线次日的开市价向上跳空，超过了倒锤子线的实体。向上跳空的距离越大，验证信号就越强烈。</p>
</li>
<li><p>倒锤子线次日是一根白色蜡烛线，并且它的价格均处在较高的水平。</p>
</li>
</ol>
</blockquote>
<h3 id="7，孕线形态">7，孕线形态</h3><p>后一根蜡烛线的实体较小，并且被前一根相对较长的实体包容进去。</p>
<p>孕线形态与吞没形态相比，两根蜡烛线的顺序恰好颠倒过来。在吞没形态中，后面是一根长长的实体，它将前一个小实体覆盖进去了。而在孕线形态中，前一个是非常长的实体，它将后一个小实体包容起来。</p>
<p>在吞没形态中，两根蜡烛线的实体的颜色应当互不相同，而在孕线形态中，这一点倒不是一项必要条件。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210yunxian.png" alt=""></p>
<h4 id="十字孕线形态">十字孕线形态</h4><p>指的是在孕线形态中，第二天是一根十字线，而不是一个小实体。因为十字孕线形态包含了一根强有力的十字蜡烛线，所以这类形态被视为主要反转信号。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210shizi.png" alt=""></p>
<p>十字孕线形态所蕴含的技术意义，比普通的孕线形态重要得多。一般的孕线形态并不属于主要反转形态，但是，十字孕线形态恰恰是一种主要反转形态。</p>
<h3 id="8，平头顶部形态和平头底部形态">8，平头顶部形态和平头底部形态</h3><p>平头形态是由具有几乎相同水平的最高点的两根蜡烛线组成，或者是由具有几乎相同的最低点的两根蜡烛线组成的。</p>
<p>图6.13，在上升趋势中，先是一根长长的白色蜡烛线，后是一根十字线。这个二蜡烛线形态既是一个十字孕线形态，又是一个平头形态，因为这两根蜡烛线具有同样的最高点。综合来看，这个形态可能构成了重要的反转信号。</p>
<p>图6.14，在这个平头形态中，先是一根长长的白色蜡烛线，后是一根上吊线。下一天，如果市场开市于上吊线的实体之下，那么，把这个形态判断为一个顶部反转信号，就有了很大的胜算。只要市场的收市价不高于这个平头形态的顶部，那么这种看跌的态度就不可动摇。</p>
<p>图6.15，在这个平头顶部形态中，第二根蜡烛线同时又是一根看跌的流星线，尽管它不是一根真正的流星线，但根据形成这根蜡烛线的价格变化过程，这根线本身是看跌的。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210pingtou.png" alt=""></p>
<h3 id="9，捉腰带线">9，捉腰带线</h3><p>捉腰带线形态是单独一根蜡烛线构成的，既可能具有看涨的意义，也可能具有看跌的意义。</p>
<ul>
<li><p>看涨捉腰带线形态是一根坚挺的白色蜡烛线，其开市价位于当日的最低点（或者，这根蜡烛线只有极短的下影线），然后市场一路上扬。如果市场处于低价区域，出现了一根长长的看涨捉腰带线，则预示着上冲行情的到来。</p>
</li>
<li><p>看跌捉腰带线形态是一根长长的黑色蜡烛线，它的开市价位于当日的最高点（或者这根蜡烛线只有极短的上影线），然后市场一路下跌。在市场处于高价区的条件下，看跌捉腰带形态的出现，构成了顶部反转信号。</p>
</li>
</ul>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210zhuoyao.png" alt=""></p>
<h3 id="10，向上跳空二只乌鸦">10，向上跳空二只乌鸦</h3><p>下图为向上跳空二只乌鸦形态。“向上跳空”指的是图示的小黑色实体与它们之前的实体（即第一个小黑色实体之前的实体，通常是一根长长的白色实体）之间的价格跳空。</p>
<p>在理想的向上跳空二只乌鸦形态中，第二个黑色实体的开市价高于第一个黑色实体的开市价，并且它的收市价低于第一个黑色实体的收市价</p>
<p>这个形态在技术上看跌的理论依据大致如下：市场本来处于上升趋势中，并且这一天的开市价同前一天的收市价相比，是向上跳空的，可是市场不能维持这个新高水平，结果当天反而形成了一根黑色蜡烛线。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210wuya.png" alt=""></p>
<h3 id="11，铺垫形态">11，铺垫形态</h3><p>其外形与向上跳空二只乌鸦形态相似，但不同的是，在上升行情中，这类形态是看涨的。在这个形态中，头三根蜡烛线与向上跳空二只乌鸦形态相似，但此后，又跟了一根黑色蜡烛线。如果接下来的一根蜡烛线是白色的，并向上跳空，向上超过了上述最后一根黑色蜡烛的上影线，或者这根白色蜡烛线的收市价高于最后一根黑色蜡烛的最高价，则形成了买入信号。</p>
<p>在铺垫形态中，可以有2根、3根乃至4根黑色蜡烛线。</p>
<p>相对而言，向上跳空二只乌鸦形态和铺垫形态都很少见。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210pudian.png" alt=""></p>
<blockquote>
<p><strong>建议：当向上跳空二只乌鸦形态出现后，应当在该形态的第二根黑色蜡烛线的最高点上方设置止损保护指令，以防备市场收市于该水平之下。</strong> P166</p>
</blockquote>
<h3 id="12，三只乌鸦">12，三只乌鸦</h3><p>类似于向上跳空两只乌鸦形态，连续出现了三根依次下降的黑色蜡烛线，则构成了所谓的三只乌鸦形态。如果三只乌鸦出现在高价格水平上，或者出现在经历了充分发展的上涨行情中，就预示着价格即将下跌。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210sanzhiwuya.png" alt=""></p>
<h3 id="13，反击线形态（约会线形态）">13，反击线形态（约会线形态）</h3><p>当两根颜色相反的蜡烛线具有相同的收市价时，就形成了一个反击线形态（也称为约会线形态）。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210fanjixian.png" alt=""></p>
<p>刺透形态与本图所示的看涨反击线形态一样，也是由两根蜡烛线组成的。它们之间主要的区别是，看涨反击线通常并不把收市价向上推进到前一天的白色实体的内部，而是仅仅回升到前一天的收市价的位置。而在透刺形态，第二根蜡烛线深深地向上穿入了前一个黑色实体之内。因此，透刺形态与看涨反击线形态相比较，透刺形态是一种更为重要的底部反转信号。</p>
<p>在看跌反击线形态中，第二天的开市价高于前一天的最高点，这一点与乌云盖顶形态是一致的。但是，与乌云盖顶形态不同的是，这一天的收市价并没有向下穿入前一天的白色蜡烛线之内。由此看来，乌云盖顶形态所发出的顶部反转信号，比看跌反击线形态更强。</p>
<p>在反击线形态中，一项重要的考虑因素是，第二天的开市价是否强劲地上升到较高的水平（在看跌反击线形态中），或者是否剧烈地下降到较低的水平（在看涨反击线形态中）。其核心思想是，在该形态第二天开市时，市场本来已经顺着既有趋势向前迈了一大步，但是后来，却发生了意想不到的变故！到当日收市时，市场竟然完全返回到了前一天收市价的水平！</p>
<h3 id="14，塔形顶部形态">14，塔形顶部形态</h3><ul>
<li><p><strong>塔形顶部形态</strong>属于顶部反转形态。市场本来处在上升趋势中，在某个时刻，出现了一根坚挺的白色蜡烛线（或者出现了一系列高高的白色蜡烛线）。后来，市场先是放缓了上涨的步调，然后，蜡烛线的高点开始下降。最后，市场上出现了一根或数根长长的黑色蜡烛线，于是，塔形顶部形态就完成了。在本形态中，两侧的长长的蜡烛线形似高塔，因此得名。</p>
</li>
<li><p><strong>塔形底部形态</strong>发生在低价格水平上，市场在形成了一根或数根长长的黑色蜡烛线之后，经历了一阵短暂的平静。然后，出现了一根或数根长长的白色蜡烛线。</p>
</li>
</ul>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210taxing.png" alt=""></p>
<h3 id="15，窗口">15，窗口</h3><p>所谓窗口，是指在前一根蜡烛线的端点与后一根蜡烛线的端点之间存在一个价格缺口。如图左是在上升趋势中形成的一个“打开的”窗口。图右是在下降趋势中的一个窗口。</p>
<p>同时，窗口还将演化为支撑区或阻挡区。因此，在上涨行情中，如果出现了一个窗口，则意味着价格将进一步上升。并且，今后当市场向下回撤时，这个窗口将形成其底部支撑水平。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210chuangkou.png" alt=""></p>
<p>如果连续出现了8个新高而没有发生任何有意义的调整，那么，日本分析师便将这种市场状况描述为“胃口已经填满了八成”。</p>
<p>传统的日本技术分析理论断言：在一个趋势中，如果已经出现了3个向上的或向下的窗口（即所谓三空形态），那么，市场即将形成顶部（如果这三个窗口发生在上升趋势中）或底部（如果这三个窗口发生在下降趋势中）的机会是极大的，特别是在第三个窗口之后，如果出现了某种转折性的蜡烛图形态或蜡烛线（比如说十字线，透刺形态，或者乌云盖顶形态等），那么市场见顶或见底的机会更大了。</p>
<p>日本分析师认为，如果一个窗口（在上升趋势过程中）没有在三天之内被市场关闭，那么市场将上涨。**</p>
<h3 id="16，向上跳空和向下跳空并列阴阳线形态">16，向上跳空和向下跳空并列阴阳线形态</h3><p>是一种持续形态，它的形成过程大体是这样的。市场本处于上升趋势中，这时，出现了一根向上跳空的白色蜡烛线。在这根白色蜡烛线后，紧跟着另一根黑色的蜡烛线。这根黑色蜡烛线的开市价位于前一个白色实体之内，收市价位于前一个白色实体之下，在这样的情况下，这根黑色蜡烛线的收市价，就构成了一个买入点。如果在市场回头填补了这里的跳空（即关闭了该窗口）后，抛售压力依然很明显的话，那么这个向上跳空并列黑白蜡烛线形态的看涨意义就不再成立了。</p>
<p>在向下跳空并列阴阳线形态中，基本概念与上述向上跳空并列阴阳线是相同的，只不过方向相反。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210tiaokong.png" alt=""></p>
<h3 id="17，高价位和低价位跳空突破形态">17，高价位和低价位跳空突破形态</h3><p>在上升趋势中，当市场经历了一两个急剧上涨的交易日后，在正常情况下都需要一个调整消化的过程。有时，这个整理过程是通过一系列小实体来完成的。如果在一根坚挺的蜡烛线之后，出现了一群小实体的蜡烛线则表明市场已经变得犹豫不决了。然而，一旦后来某一天的开市价从这群小实体处向上跳空（也就是说，形成了一个窗口），那么买进的时机就成熟了。</p>
<p>低价位跳空突破形态正是高价位跳空突破形态的反面角色。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210tupo.png" alt=""></p>
<h3 id="18，跳空并列白色蜡烛线形态">18，跳空并列白色蜡烛线形态</h3><p>在上升趋势中，先出现了一根向上跳空的白色蜡烛线，随后又是一根白色蜡烛线，并且后面这根线与前一根大小相当，两者的开市价也差不多处在同样的水平上，这样就形成了一种看涨的持续状态。这种二蜡烛线形态称为向上跳空并列白色蜡烛线形态（或者称为向上跳空并列阳线形态）。如果市场收市在并列白色蜡烛线的最高点之上，则意味着下一波上涨行情即将展开。</p>
<p>在下降趋势中，这类并列的白色蜡烛线也构成了一个持续状态。也就是说，当这类形态出现时，价格将继续走低。为什么这种形态不是看涨的，而是看跌的呢？这是因为在下降的市场中，这两根白色蜡烛线是由空头平仓过程造成的。一旦空头平仓的过程完成了，价格就要进一步下跌。</p>
<p>这两种形态非常少见。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210binglie.png" alt=""></p>
<h3 id="19，上升三法和下降三法形态">19，上升三法和下降三法形态</h3><h4 id="上升三法形态的判别标准，包括以下几个方面：">上升三法形态的判别标准，包括以下几个方面：</h4><blockquote>
<p>1，首先出现的是一根长长的白色蜡烛线</p>
<p>2，在这根白色蜡烛线之后，紧跟着一群依次下降的小实体蜡烛线。这群小实体蜡烛线的理想数目是3根。而且这群小实体蜡烛线基本上都局限在前面那根长长的白色蜡烛线的价格范围之内。小蜡烛线既可以是白色的，也可以是黑色的，不过，黑色蜡烛线最常见。</p>
<p>3，最后一天应当是一根具有坚挺的白色实体的蜡烛线，并且它的收市价高于第一天的收市价。同时，最后这根蜡烛线的开市价也应当高于前一天的收市价。</p>
</blockquote>
<p>下降三法形态与上升三法形态在图形上完全是对等的，只不过方向相反而已。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210sanfa.png" alt=""></p>
<h3 id="20，前进白色三兵形态">20，前进白色三兵形态</h3><ul>
<li>前进白色三兵形态</li>
</ul>
<p>本形态由接连出现的三根白色蜡烛线组成，它们的收市价依次上升。当市场在某个低价位稳定了一段时间后，如果出现了这样的形态，就标志着市场即将转强。</p>
<ul>
<li>前方受阻形态</li>
</ul>
<p>如果其中第二根和第三根蜡烛线，或者仅仅是第三根蜡烛线，表现出上涨势头减弱的迹象，就构成了一个前方受阻（白色三兵）形态。这就意味着这轮上涨行情碰到了麻烦，持有多头头寸者应当采取一些保护性措施。在前方受阻形态中，作为上涨势头减弱的具体表现，既可能是其中的白色实体一个比一个小，也可能是后两根蜡烛线具有相对较长的上影线。</p>
<ul>
<li>停顿状态</li>
</ul>
<p>如果在后两根蜡烛线中，前一根为长长的白色实体，并且向上刨出了新高，后一根只是一个小的白色蜡烛线，那么就构成了一个（白色三兵）停顿形态。当这一形态出现时，说明牛方的力量至少暂时已经消耗尽了。当停顿形态发生时，便构成了多头头寸平仓获利的紧要时机。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210sanbing.png" alt=""></p>
<p>虽然前方受阻形态与停顿形态在一般情况下都不属于顶部反转形态，但是有时候，它们也能引起不容忽视的下跌行情。我们应当利用前方受阻形态和停顿形态来平仓了结已有的多头头寸，或者为多头头寸采取保护措施，但是不可据之开立空头头寸。一般来说，如果这两类形态出现在较高的价格水平上，则更有预测意义。</p>
<h3 id="21，分手蜡烛线形态">21，分手蜡烛线形态</h3><p>反击线形态是一种二蜡烛线形态，前后两根蜡烛线颜色相反，并且后一根蜡烛线的收市价与前一根的收市价处于同一水平。这一形态属于反转信号。如下图的分手线形态也是由两根颜色相反的蜡烛线组成的，但是同反击线形态不同的是，分手线形态的两根蜡烛线具有相同的开市价。分手蜡烛线形态属于持续信号。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210fenshou.png" alt=""></p>
<h3 id="22，十字线">22，十字线</h3><p>十字线是一种不同凡响的趋势反转信号。如果十字线之后的蜡烛线发出了验证信号，证实了它的反转信号的话，就进一步加大了趋势反转的可能性。</p>
<p>需要指出的是，<strong>只有在一个市场不经常出现十字线的条件下，十字线才具有重要意义。如果在某张蜡烛图上有许多十字线，那么当这个市场形成了一根新的十字线的时候，我们就不应当将它视为一条有意义的技术线索。</strong></p>
<p>十字线之所以极具价值，是因为它在揭示市场顶部方面有过人之长。在上升趋势中，如果前面出现一根长长的白色蜡烛线，后面跟着一根十字线，这种情况尤其值得注意。为什么十字线出现在上升趋势中具有负面意义呢?这是因为十字线代表着市场处于犹豫不决心理状态。</p>
<p>但是根据我们的经验来看，在下降趋势中，十字线往往丧失了发挥反转作用的潜力。其中的原因可能是这样的：十字线反映了买方与卖方在力量对比上处于相对平衡状态。由于市场参与者抱着骑墙的态度，市场往往因为自身的重力而下坠。因此，当十字线出现时，在上升趋势中，市场可能向下反转，而在下降趋势中，市场则可能继续下跌。</p>
<ul>
<li>长腿十字线</li>
</ul>
<p>位于市场顶部的长腿十字线是一种特别重要的十字线。这类十字线具有长长的上影线和下影线，鲜明地表露出市场举棋不定的心理状态。</p>
<p>如果当日的开市价和收市价正好处在全日价格范围的中点，那么这种蜡烛线就称为<strong>黄包车夫（线）</strong>。</p>
<p>如果某根非十字线的蜡烛线具有很长的上影线，或者具有很长的下影线，并且其实体较小，这种蜡烛线就称为<strong>风高浪大线</strong>。如果出现了一群风高浪大线，也构成了一种反转形态。对日本分析师来说，非常长的上影线或非常长的下影线的形成——借用他们的话来描述——就表示市场“失去了方向感”。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210changtuishizi.png" alt=""></p>
<ul>
<li>墓碑十字线</li>
</ul>
<p>当开市价和收市价位于当日的最低点时，就形成了一根墓碑十字线。</p>
<p>这类形态最突出的长处在于昭示市场顶部。在上涨行情中，该形态的上影线越长，所处的价格水平愈高，那么，这根墓碑十字线的技术意义就愈疲弱。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210mubeishizi.png" alt=""></p>
<p>墓碑十字线与流星形态颇为相像。发生在市场顶部的墓碑十字线，实际上是流星形态的一种特殊情况。流星蜡烛线具有较小的实体，而墓碑十字线——作为一根十字线，甚至没有实体。墓碑十字线比流星形态更为疲软。</p>
<ul>
<li>三星形态</li>
</ul>
<p>三星形态非常罕见，但是是一种意义极其重大的反转形态。三星形态是由三根十字线组成的，中间的十字线是一根十字星蜡烛线。理想的三星形态如下图：</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210sanxing.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>日本蜡烛线形态</p>
<h3 id="1，纺锤线">1，纺锤线</h3><p>实体较短，说明熊方与牛方正处于胶着状态，一时难分高下。</p>
<p><img src="http://7xos68.com1.z0.glb.clouddn.com/20151210fangchuixian2.jpg" alt=""></p>
<h3 id="2，锤子线与上吊线">2，锤子线与上吊线</h3><p>下图中的蜡烛图线具有明显的特点：它们的下影线较长，而实体较小并且在其全天价格区间里，实体处在接近顶端的位置上。<br>]]>
    
    </summary>
    
      <category term="K线" scheme="http://www.kekefund.com/tags/K%E7%BA%BF/"/>
    
      <category term="期货" scheme="http://www.kekefund.com/tags/%E6%9C%9F%E8%B4%A7/"/>
    
      <category term="股票" scheme="http://www.kekefund.com/tags/%E8%82%A1%E7%A5%A8/"/>
    
      <category term="蜡烛图" scheme="http://www.kekefund.com/tags/%E8%9C%A1%E7%83%9B%E5%9B%BE/"/>
    
      <category term="Stock" scheme="http://www.kekefund.com/categories/Stock/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PyQt4 生成exe打包文件]]></title>
    <link href="http://www.kekefund.com/2015/11/26/pyqt4-build-exe/"/>
    <id>http://www.kekefund.com/2015/11/26/pyqt4-build-exe/</id>
    <published>2015-11-26T09:00:51.000Z</published>
    <updated>2016-01-21T01:17:01.000Z</updated>
    <content type="html"><![CDATA[<p><strong>PyQt4 生成exe打包文件</strong></p>
<p>pyqt是跨平台的GUI平台，本文的UI设计，代码编写在mac下进行，编译成exe，并打包在win7下做的。<br>python脚本语言，图形化平台不是其擅长的领域，一般都是直接运行脚本，这次因为客户需要一个“成型”的程序去外面给别人展示，故有了此文的背景。<br>QT作为一个跨平台的开发环境，编写出一个窗口程序，然后打包成python文件是比较迅速的。麻烦的是打包成windows的exe文件，试过py2exe,pyinstaller，都不是很好用，py2exe根本出不来图形界面，最后用到cxfreeze这个工具，才得以顺利打包。</p>
<h2 id="前言">前言</h2><p>环境搭建参考：<a href="http://www.cnblogs.com/zouzf/p/4308912.html" target="_blank" rel="external">http://www.cnblogs.com/zouzf/p/4308912.html</a></p>
<h2 id="一、Qt_Designer设计界面">一、Qt Designer设计界面</h2><p><em>安装Qt Designer，我的版本是5.2.1。</em><br>设计出的界面如下，保存为.ui文件。<br><img src="http://7xo67b.com1.z0.glb.clouddn.com/qt_main.png" alt="Qt_UI"></p>
<a id="more"></a>
<p>Qt的界面布局和MFC的比较类似，但它多了一层容器的概念。控件都放在容器Layout中，这点又和Android的手机布局比较相近。</p>
<blockquote>
<p><em>UI布局教程参考：<a href="http://www.linuxidc.com/Linux/2012-06/63652.htm" target="_blank" rel="external">PyQt4 精彩实例分析</a></em></p>
</blockquote>
<h2 id="二、Qt布局文件-ui转换成-py文件">二、Qt布局文件.ui转换成.py文件</h2><p>mac和win系统下先将pyuic4命令加入环境变量。mac中我是直接把/etc/paths拷贝到桌面，添加pyuic4路径后再拷贝覆盖回去。（ps: etc下不能直接修改）<br>在终端中执行：</p>
<pre><code><span class="tag">pyuic4</span> <span class="tag">-x</span> <span class="tag">aaaaaaa</span><span class="class">.ui</span> <span class="tag">-o</span> <span class="tag">bbbbbb</span><span class="class">.py</span>
</code></pre><p>即可将.ui文件转成py文件。</p>
<h2 id="三、添加按钮动作">三、添加按钮动作</h2><p>这里实现了三个功能：上传文件，运行py脚本，打开另一个Qt窗口</p>
<h3 id="1，上传文件">1，上传文件</h3><h4 id="a，post上传">a，post上传</h4><pre><code>dlg = QFileDialog()
<span class="keyword">filename</span> = dlg.getOpenFileName()
from os.path import isfile
<span class="keyword">if</span> isfile(<span class="keyword">filename</span>):
    <span class="keyword">filename</span> = str(<span class="keyword">filename</span>)
    print type(<span class="keyword">filename</span>)
<span class="comment">    #dir_f = os.path.dirname(str(filename))</span>

<span class="comment">    # ------ web post -----</span>
<span class="comment">    # 在 urllib2 上注册 http 流处理句柄</span>
    register_openers()

<span class="comment">    # headers 包含必须的 Content-Type 和 Content-Length</span>
<span class="comment">    # datagen 是一个生成器对象，返回编码过后的参数</span>
    datagen, headers = multipart_encode({<span class="string">"myfile"</span>: <span class="keyword">open</span>(str(<span class="keyword">filename</span>), <span class="string">"rb"</span>)})

<span class="comment">    # 创建请求对象</span>
    request = urllib2.Request(<span class="string">"http://yourwebsite:8080/upload"</span>, datagen, headers)
<span class="comment">    # 实际执行请求并取得返回</span>
    print urllib2.urlopen(request).<span class="keyword">read</span>()
</code></pre><h4 id="b，通过_ftp_上传">b，通过 ftp 上传</h4><pre><code>dlg = QFileDialog()
filename = dlg.getOpenFileName()
<span class="built_in">from</span> os.path import isfile
<span class="keyword">if</span> isfile(filename):
    filename = str(filename)

    <span class="comment"># ------- ftp --------</span>
    <span class="built_in">from</span> ftplib import FTP

    <span class="keyword">ftp</span>=FTP()
    <span class="keyword">ftp</span>.set_debuglevel(<span class="number">2</span>)<span class="comment">#打开调试级别2，显示详细信息;0为关闭调试信息</span>
    <span class="keyword">ftp</span>.connect(<span class="string">'127.0.0.1'</span>,<span class="string">'21'</span>)<span class="comment">#连接</span>
    <span class="keyword">ftp</span>.login(<span class="string">'Administrator'</span>,<span class="string">'password'</span>)<span class="comment">#登录，如果匿名登录则用空串代替即可</span>
    print <span class="keyword">ftp</span>.getwelcome()<span class="comment">#显示ftp服务器欢迎信息</span>
    <span class="comment">#ftp.cwd(dir_f) #选择操作目录</span>
    <span class="comment">#filename='keys.xlsx'</span>
    bufsize = <span class="number">1024</span><span class="comment">#设置缓冲块大小</span>
    file_handler = <span class="built_in">open</span>(filename,<span class="string">'rb'</span>)<span class="comment">#以读模式在本地打开文件</span>
    <span class="keyword">ftp</span>.storbinary(<span class="string">'STOR %s'</span> % os.path.basename(filename),file_handler,bufsize)<span class="comment">#上传文件</span>
    <span class="keyword">ftp</span>.set_debuglevel(<span class="number">0</span>)
    file_handler.<span class="built_in">close</span>()
    <span class="keyword">ftp</span>.quit()
    print <span class="string">"ftp up OK"</span>
</code></pre><h3 id="2，运行py脚本">2，运行py脚本</h3><p>在服务器上用web.py搭建web服务器，通过网页请求运行py文件。</p>
<pre><code><span class="comment">#运行</span>
<span class="function"><span class="keyword">def</span> <span class="title">on_run_clicked</span><span class="params">(self)</span>:</span>
    self.pushButton_run.setText(_translate(<span class="string">"Dialog"</span>, <span class="string">"运行中"</span>, <span class="keyword">None</span>))
    self.pushButton_run.setEnabled(<span class="keyword">False</span>)
    response = urllib2.urlopen(<span class="string">'http://%s:8080/run_video_search'</span> % self.ip, timeout=<span class="number">3</span>)
    <span class="keyword">print</span> response
</code></pre><p>这里采用的是同步的方式请求，服务器端的py脚本没执行完，则程序一直等待。不过设置了超时，过了3s返回超时错误，这种情况适合不需要得到服务器的反馈，只是执行远程py脚本而已。</p>
<h3 id="3，打开另一个Qt窗口">3，打开另一个Qt窗口</h3><p>pyqt 用起来的比较简单，直接run qt对应的py类</p>
<pre><code>#结果
def <span class="function"><span class="title">on_show_result</span><span class="params">(self)</span></span>:

    Dialog = QtGui.<span class="function"><span class="title">QDialog</span><span class="params">()</span></span>
    ui = <span class="function"><span class="title">Ui_Result_Dialog</span><span class="params">()</span></span>
    ui.<span class="function"><span class="title">setupUi</span><span class="params">(Dialog)</span></span>
    Dialog.<span class="function"><span class="title">show</span><span class="params">()</span></span>
    Dialog.<span class="function"><span class="title">exec_</span><span class="params">()</span></span>
</code></pre><p>跳转过来的窗口如下，是一个数据库的查询界面。<br><img src="http://7xo67b.com1.z0.glb.clouddn.com/qt_result.png" alt="result ui">                        </p>
<h2 id="四、打包">四、打包</h2><p>cx_Freeze 支持跨平台，可在windows、linux，mac下使用。下载地址为(<a href="http://sourceforge.net/projects/cx-freeze/files/),,也可以直接通过pip安装" target="_blank" rel="external">http://sourceforge.net/projects/cx-freeze/files/),,也可以直接通过pip安装</a></p>
<pre><code>pip <span class="keyword">install</span> cx_freeze
</code></pre><p>安装成功后，在C:\Python27\Lib\site-packages\cx_Freeze\samples\PyQt4中找到pyqt4的使用例子。<br>查看setup.py</p>
<pre><code><span class="keyword">import</span> sys
<span class="keyword">from</span> cx_Freeze <span class="keyword">import</span> setup, Executable

base = None
<span class="keyword">if</span> sys.platform == <span class="string">'win32'</span>:
    base = <span class="string">'Win32GUI'</span>

<span class="keyword">options</span> = {
    <span class="string">'build_exe'</span>: {
        <span class="string">'includes'</span>: <span class="string">'atexit'</span>
    }
}

executables = [
    Executable(<span class="string">'PyQt4app.py'</span>, base=base)
]

setup(name=<span class="string">'simple_PyQt4'</span>,
      version=<span class="string">'0.1'</span>,
      <span class="keyword">description</span>=<span class="string">'Sample cx_Freeze PyQt4 script'</span>,
      <span class="keyword">options</span>=<span class="keyword">options</span>,
      executables=executables
      )
</code></pre><p>把这个setup.py文件拷贝到你要打包py文件的目录，然后将setup.py中的“PyQt4app.py”改成你要打包的py文件。<br>在cmd命令行，cd到当前目录，运行:</p>
<pre><code>python setup<span class="class">.py</span> build
</code></pre><p>打包exe成功后，在当前目录下会生成build文件夹，在\build\exe.win32-2.7\中找到exe后缀的文件，执行。</p>
<h2 id="五、制作安装包">五、制作安装包</h2><p>采用的是Inno Setup 制作安装包，按照向导来生成.iss脚本，傻瓜化操作。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>PyQt4 生成exe打包文件</strong></p>
<p>pyqt是跨平台的GUI平台，本文的UI设计，代码编写在mac下进行，编译成exe，并打包在win7下做的。<br>python脚本语言，图形化平台不是其擅长的领域，一般都是直接运行脚本，这次因为客户需要一个“成型”的程序去外面给别人展示，故有了此文的背景。<br>QT作为一个跨平台的开发环境，编写出一个窗口程序，然后打包成python文件是比较迅速的。麻烦的是打包成windows的exe文件，试过py2exe,pyinstaller，都不是很好用，py2exe根本出不来图形界面，最后用到cxfreeze这个工具，才得以顺利打包。</p>
<h2 id="前言">前言</h2><p>环境搭建参考：<a href="http://www.cnblogs.com/zouzf/p/4308912.html">http://www.cnblogs.com/zouzf/p/4308912.html</a></p>
<h2 id="一、Qt_Designer设计界面">一、Qt Designer设计界面</h2><p><em>安装Qt Designer，我的版本是5.2.1。</em><br>设计出的界面如下，保存为.ui文件。<br><img src="http://7xo67b.com1.z0.glb.clouddn.com/qt_main.png" alt="Qt_UI"></p>]]>
    
    </summary>
    
      <category term="PyQt" scheme="http://www.kekefund.com/tags/PyQt/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/tags/Python/"/>
    
      <category term="exe" scheme="http://www.kekefund.com/tags/exe/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IP代理池的Python实现]]></title>
    <link href="http://www.kekefund.com/2015/11/17/pytho-ip-proxy/"/>
    <id>http://www.kekefund.com/2015/11/17/pytho-ip-proxy/</id>
    <published>2015-11-17T09:41:46.000Z</published>
    <updated>2015-11-19T04:53:31.000Z</updated>
    <content type="html"><![CDATA[<p>爬虫采集数据时，如果频繁的访问某个网站，会被封IP，有些是禁止访问3小时，有些是直接拉黑名单。为了避免被禁，一般采取的措施有三种：</p>
<blockquote>
<ol>
<li>放慢抓取的速度，设置一个时间间隔；</li>
<li>模拟浏览器行为，如采用Selenium + PhantomJS；</li>
<li>设置IP代理，定期更换代理IP，让网站不认为来自一个IP。</li>
</ol>
</blockquote>
<p>本文实现其中的第三种方法。<br>国内提供IP代理的网站有很多，我们以其中的一个为例：<a href="http://www.haodailiip.com" target="_blank" rel="external">http://www.haodailiip.com</a><br>分为三步来实现这个IP抓取类：</p>
<blockquote>
<ol>
<li>解析网页中的IP和端口</li>
<li>Ping所有IP地址的连接速度 </li>
<li>按速度从快到慢排序，保存到文件</li>
</ol>
</blockquote>
<a id="more"></a>
<h2 id="一、解析网页中的IP和端口">一、解析网页中的IP和端口</h2><p>抓取网页采用的是<font color="red"> urlib + BeautifulSoup</font>。<br>解析网站：<a href="http://www.haodailiip.com/guonei/page" target="_blank" rel="external">http://www.haodailiip.com/guonei/page</a>，page=1,2…,10</p>
<pre><code>def <span class="function"><span class="title">parse</span><span class="params">(url)</span></span>:
        try:
            page = urllib.<span class="function"><span class="title">urlopen</span><span class="params">(url)</span></span>
            data =  page.<span class="function"><span class="title">read</span><span class="params">()</span></span>
            soup = <span class="function"><span class="title">BeautifulSoup</span><span class="params">(data, <span class="string">"html5lib"</span>)</span></span>
            print soup.<span class="function"><span class="title">get_text</span><span class="params">()</span></span>
            body_data = soup.<span class="function"><span class="title">find</span><span class="params">(<span class="string">'table'</span>, attrs={<span class="string">'class'</span>:<span class="string">'content_table'</span>})</span></span>
            res_list = body_data.<span class="function"><span class="title">find_all</span><span class="params">(<span class="string">'tr'</span>)</span></span>
            <span class="keyword">for</span> res <span class="keyword">in</span> res_list:
                each_data = res.<span class="function"><span class="title">find_all</span><span class="params">(<span class="string">'td'</span>)</span></span>
                <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(each_data)</span></span> &gt; <span class="number">3</span> and not <span class="string">'IP'</span> <span class="keyword">in</span> each_data[<span class="number">0</span>].<span class="function"><span class="title">get_text</span><span class="params">()</span></span> and <span class="string">'.'</span> <span class="keyword">in</span> each_data[<span class="number">0</span>].<span class="function"><span class="title">get_text</span><span class="params">()</span></span>:
                    print each_data[<span class="number">0</span>].<span class="function"><span class="title">get_text</span><span class="params">()</span></span>.<span class="function"><span class="title">strip</span><span class="params">()</span></span>, each_data[<span class="number">1</span>].<span class="function"><span class="title">get_text</span><span class="params">()</span></span>.<span class="function"><span class="title">strip</span><span class="params">()</span></span>
                    item = <span class="function"><span class="title">IPItem</span><span class="params">()</span></span>
                    item<span class="class">.ip</span> = each_data[<span class="number">0</span>].<span class="function"><span class="title">get_text</span><span class="params">()</span></span>.<span class="function"><span class="title">strip</span><span class="params">()</span></span>
                    item<span class="class">.port</span> = each_data[<span class="number">1</span>].<span class="function"><span class="title">get_text</span><span class="params">()</span></span>.<span class="function"><span class="title">strip</span><span class="params">()</span></span>
                    item<span class="class">.addr</span> = each_data[<span class="number">2</span>].<span class="function"><span class="title">get_text</span><span class="params">()</span></span>.<span class="function"><span class="title">strip</span><span class="params">()</span></span>
                    item<span class="class">.tpye</span> = each_data[<span class="number">3</span>].<span class="function"><span class="title">get_text</span><span class="params">()</span></span>.<span class="function"><span class="title">strip</span><span class="params">()</span></span>
                    self<span class="class">.ip_items</span><span class="class">.append</span>(item)
        except Exception,e:
            print e
</code></pre><p>BeautifulSoup默认的解析器是lxml，但对于这个网址，发现网页内容解析的不完整，于是用了解析性最好的 html5lib，速度上会稍慢。<br>关于BeautifulSoup解析器的介绍见<a href="http://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/#id9" target="_blank" rel="external">http://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/#id9</a>。<br>BS解析的过程是：</p>
<ul>
<li>先找到table class=”content_table”的标签；</li>
<li>在从上面的内容中找所有tr</li>
<li>我们需要的信息在tr的td中</li>
<li>结果存入IPItem类。</li>
</ul>
<p><strong>IPItem的定义</strong></p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">IPItem</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>
        self.ip = <span class="string">''</span>    <span class="comment"># IP</span>
        self.port = <span class="string">''</span>  <span class="comment"># Port</span>
        self.addr = <span class="string">''</span>  <span class="comment"># 位置</span>
        self.tpye = <span class="string">''</span>  <span class="comment">#类型:http; https</span>
        self.speed = -<span class="number">1</span> <span class="comment">#速度</span>
</code></pre><h2 id="二、Ping所有IP地址的连接速度">二、Ping所有IP地址的连接速度</h2><pre><code>import pexpect
def <span class="function"><span class="title">test_ip_speed</span><span class="params">(ip_items)</span></span>:
    tmp_items = []
    <span class="keyword">for</span> item <span class="keyword">in</span> ip_items:

        (command_output, exitstatus) = pexpect.<span class="function"><span class="title">run</span><span class="params">(<span class="string">"ping -c1 %s"</span> % item.ip, timeout=<span class="number">5</span>, withexitstatus=<span class="number">1</span>)</span></span>
        <span class="keyword">if</span> exitstatus == <span class="number">0</span>:
            print command_output
            m = re.<span class="function"><span class="title">search</span><span class="params">(<span class="string">"time=([\d\.]+)"</span>, command_output)</span></span>
            <span class="keyword">if</span> m:
                print <span class="string">'time='</span>, m.<span class="function"><span class="title">group</span><span class="params">(<span class="number">1</span>)</span></span>
                item<span class="class">.speed</span> = <span class="function"><span class="title">float</span><span class="params">(m.group(<span class="number">1</span>)</span></span>)
                tmp_items.<span class="function"><span class="title">append</span><span class="params">(item)</span></span>

   ip_items = tmp_items
</code></pre><p>主要是利用pexpect模块调用系统的ping命令，上面代码在mac 10.11.1下测试通过。</p>
<h2 id="三、按速度从快到慢排序，保存至文件">三、按速度从快到慢排序，保存至文件</h2><p>保存至文件利用pandas模块，只需一句代码即可搞定。</p>
<ol>
<li>先把ip_items转换成pandas的DataFrame；</li>
<li>排序，df.sort_index()，按’Speed’列排序；</li>
<li>结果写入Excel文件，to_excel()</li>
</ol>
<pre><code><span class="function"><span class="keyword">def</span> <span class="title">save_data</span><span class="params">(self)</span>:</span>
        df = DataFrame({<span class="string">'IP'</span>:[item.ip <span class="keyword">for</span> item <span class="keyword">in</span> ip_items],
                        <span class="string">'Port'</span>:[item.port <span class="keyword">for</span> item <span class="keyword">in</span> self.ip_items],
                        <span class="string">'Addr'</span>:[item.addr <span class="keyword">for</span> item <span class="keyword">in</span> self.ip_items],
                        <span class="string">'Type'</span>:[item.tpye <span class="keyword">for</span> item <span class="keyword">in</span> self.ip_items],
                        <span class="string">'Speed'</span>:[item.speed <span class="keyword">for</span> item <span class="keyword">in</span> self.ip_items]
                        }, columns=[<span class="string">'IP'</span>, <span class="string">'Port'</span>, <span class="string">'Addr'</span>, <span class="string">'Type'</span>, <span class="string">'Speed'</span>])
        <span class="keyword">print</span> df[:<span class="number">10</span>]
        df[<span class="string">'Time'</span>] = GetNowTime()
        df = df.sort_index(by=<span class="string">'Speed'</span>)

        now_data = GetNowDate()


        file_name = self.dir_path +<span class="string">'ip_proxy_'</span> + now_data + <span class="string">'.xlsx'</span>

        df.to_excel(file_name)
</code></pre><p>生成的excel文件如下：<br><img src="http://7xo67b.com1.z0.glb.clouddn.com/ip_results.png" alt="results"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>爬虫采集数据时，如果频繁的访问某个网站，会被封IP，有些是禁止访问3小时，有些是直接拉黑名单。为了避免被禁，一般采取的措施有三种：</p>
<blockquote>
<ol>
<li>放慢抓取的速度，设置一个时间间隔；</li>
<li>模拟浏览器行为，如采用Selenium + PhantomJS；</li>
<li>设置IP代理，定期更换代理IP，让网站不认为来自一个IP。</li>
</ol>
</blockquote>
<p>本文实现其中的第三种方法。<br>国内提供IP代理的网站有很多，我们以其中的一个为例：<a href="http://www.haodailiip.com">http://www.haodailiip.com</a><br>分为三步来实现这个IP抓取类：</p>
<blockquote>
<ol>
<li>解析网页中的IP和端口</li>
<li>Ping所有IP地址的连接速度 </li>
<li>按速度从快到慢排序，保存到文件</li>
</ol>
</blockquote>]]>
    
    </summary>
    
      <category term="IP代理" scheme="http://www.kekefund.com/tags/IP%E4%BB%A3%E7%90%86/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/tags/Python/"/>
    
      <category term="爬虫" scheme="http://www.kekefund.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python正则表达式]]></title>
    <link href="http://www.kekefund.com/2015/11/10/python-regex/"/>
    <id>http://www.kekefund.com/2015/11/10/python-regex/</id>
    <published>2015-11-10T07:09:20.000Z</published>
    <updated>2016-01-21T01:17:26.000Z</updated>
    <content type="html"><![CDATA[<p>许多语言处理任务都涉及模式匹配。例如,可以使用endswith(‘ed’)找出以“ed”结尾的词。正则表达式提出了一个更加强大和灵活的方法描述感兴趣的字符模式。在Python中使用正则表达式，需要使用import re导入re函数库。</p>
<p><strong>下表为正则表达式基本元字符，其中包括通配符、范围和闭包</strong><br><a id="more"></a><br><img src="http://7xo67b.com1.z0.glb.clouddn.com/regex1.png" alt="正则模式"></p>
<h2 id="贪婪模式与非贪婪模式">贪婪模式与非贪婪模式</h2><p>Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。<br>例如：正则表达式 “ab<em>”，如果用于查找“abbbc”，将找到“abbb”。而如果使用非贪婪的数量词“ab\</em>?“，将找到”a“</p>
<ol>
<li><p>*? 是一个固定的搭配，.和*代表可以匹配任意无限多个字符，加上？表示使用非贪婪模式进行匹配，也就是我们会尽可能短地做匹配。</p>
</li>
<li><p>(.*?)代表一个分组，在这个正则表达式中我们匹配了五个分组，在后面的遍历item中，item[0]就代表第一个(.*?)所指代的内容，item[1]就代表第二个(.*?)所指代的内容，以此类推。</p>
</li>
<li><p>re.S 标志代表在匹配时为点任意匹配模式，点 . 也可以代表换行符。</p>
</li>
</ol>
<h2 id="re模块">re模块</h2><h3 id="一、re-search()">一、re.search()</h3><p>使用正则表达式&lt;<ed$>&gt;查找以ed结尾的词汇。使用函数re.search(p, s) 检查字符串s中是否有模式p。</ed$></p>
<pre><code><span class="keyword">import</span> re
<span class="keyword">import</span> nltk
In[<span class="number">12</span>]: wsj = sorted(set(nltk.corpus.treebank.word()))
In[<span class="number">13</span>]: ws = [w <span class="keyword">for</span> w <span class="keyword">in</span> wsj <span class="keyword">if</span> re.search(<span class="string">'ed$'</span>, w)]

In[<span class="number">15</span>]: ws[:<span class="number">10</span>]
Out[<span class="number">15</span>]: 
[<span class="string">u'62%-owned'</span>,<span class="string">u'Absorbed'</span>,<span class="string">u'Advanced'</span>,<span class="string">u'Alfred'</span>, <span class="string">u'Allied'</span>, <span class="string">u'Annualized'</span>, <span class="string">u'Arbitrage-related'</span>,
 <span class="string">u'Asked'</span>,<span class="string">u'Atlanta-based'</span>, <span class="string">u'Bermuda-based'</span>]
</code></pre><p>通配符“.”可以用来匹配任何单个字符。假设有一个8个字母组成的字谜，j是第三个字母，t是第六个字母。每个空白单元格用句点隔开。</p>
<pre><code>In[<span class="number">16</span>]: ws = [w <span class="keyword">for</span> w <span class="keyword">in</span> wsj <span class="keyword">if</span> re.search(<span class="string">'^..j..t..$'</span>, w)]
In[<span class="number">18</span>]: ws
Out[<span class="number">18</span>]: [<span class="string">u'adjusted'</span>, <span class="string">u'rejected'</span>]
</code></pre><p>匹配除元音字母之外的所有字母</p>
<pre><code><span class="collection">[<span class="comment">^aeiouAEIOU</span>]</span>
</code></pre><p><strong>?:</strong><br>如果要使用括号来指定连接的范围，又不想选择要输出字符串，必须添加“?:”。</p>
<pre><code>In[<span class="number">20</span>]: re.findall(<span class="string">r'^.*(?:ing|ly|ed|ies)$'</span>, <span class="string">'processing'</span>)
Out[<span class="number">20</span>]: [<span class="string">'processing'</span>]
</code></pre><p>演示如何使用符号：\，{}，() 和 |</p>
<pre><code>In[<span class="number">20</span>]: ws = [w <span class="keyword">for</span> w <span class="keyword">in</span> wsj <span class="keyword">if</span> re.search(<span class="string">'^[0-9]+\.[0-9]+$'</span>, w)]
In[<span class="number">21</span>]: ws[:<span class="number">5</span>]
Out[<span class="number">21</span>]: [<span class="string">u'0.0085'</span>, <span class="string">u'0.05'</span>, <span class="string">u'0.1'</span>, <span class="string">u'0.16'</span>, <span class="string">u'0.2'</span>]

In[<span class="number">22</span>]: ws = [w <span class="keyword">for</span> w <span class="keyword">in</span> wsj <span class="keyword">if</span> re.search(<span class="string">'^[A-Z]+\$$'</span>, w)]
In[<span class="number">23</span>]: ws
Out[<span class="number">23</span>]: [<span class="string">u'C$'</span>, <span class="string">u'US$'</span>]

In[<span class="number">24</span>]: ws = [w <span class="keyword">for</span> w <span class="keyword">in</span> wsj <span class="keyword">if</span> re.search(<span class="string">'^[0-9]{4}$'</span>, w)]
In[<span class="number">26</span>]: ws[:<span class="number">5</span>]
Out[<span class="number">26</span>]: [<span class="string">u'1614'</span>, <span class="string">u'1637'</span>, <span class="string">u'1787'</span>, <span class="string">u'1901'</span>, <span class="string">u'1903'</span>]

In[<span class="number">27</span>]: ws = [w <span class="keyword">for</span> w <span class="keyword">in</span> wsj <span class="keyword">if</span> re.search(<span class="string">'(ed|ing)$'</span>, w)]
In[<span class="number">28</span>]: ws[:<span class="number">5</span>]
Out[<span class="number">28</span>]: [<span class="string">u'62%-owned'</span>, <span class="string">u'Absorbed'</span>, <span class="string">u'According'</span>, <span class="string">u'Adopting'</span>, <span class="string">u'Advanced'</span>]
</code></pre><h3 id="二、re-split()">二、re.split()</h3><p>按照能够匹配的子串将string分割后返回列表。</p>
<h4 id="re-split(pattern,_string[,maxsplit])">re.split(pattern, string[,maxsplit])</h4><pre><code>In[<span class="number">13</span>]: raw = <span class="string">"""'When I'M a Duchess,' she said to herself, (not in a very hopeful tone
<span class="prompt">... </span>though), 'I won't have any pepper in my kitchen AT ALL. Soup does very
<span class="prompt">... </span>well without--Maybe it's always pepper that makes people
<span class="prompt">... </span>hot-tempered,'..."""</span>
In[<span class="number">16</span>]: re.split(<span class="string">r' '</span>, raw)
Out[<span class="number">16</span>]: 
[<span class="string">"'When"</span>,
 <span class="string">"I'M"</span>,
 <span class="string">'a'</span>,
 <span class="string">"Duchess,'"</span>,...]
In[<span class="number">17</span>]: re.split(<span class="string">'[ \t\n]'</span>, raw)
Out[<span class="number">17</span>]: 
[<span class="string">"'When"</span>,
 <span class="string">"I'M"</span>,
 <span class="string">'a'</span>,
 <span class="string">"Duchess,'"</span>,...]
</code></pre><h4 id="split(string[,_maxsplit])">split(string[, maxsplit])</h4><pre><code>In [<span class="number">1</span>]: <span class="keyword">import</span> re

In [<span class="number">2</span>]: p = re.compile(<span class="string">r'\d+'</span>)

In [<span class="number">3</span>]: p.split(<span class="string">'one1two2three3four4'</span>)
Out[<span class="number">3</span>]: [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>, <span class="string">''</span>]
</code></pre><h4 id="切分字符串">切分字符串</h4><p>Python自带的字符分割函数</p>
<pre><code><span class="string">'a b   c'</span>.<span class="function"><span class="title">split</span><span class="params">(<span class="string">' '</span>)</span></span>
[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">''</span>, <span class="string">'c'</span>]
</code></pre><p>嗯，无法识别连续的空格</p>
<pre><code><span class="keyword">import</span> re
<span class="prompt">&gt;&gt;&gt; </span>re.split(<span class="string">r'\s+'</span>, <span class="string">'a b    c'</span>)
[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]
</code></pre><p>使用re，无论多少个空格都可正常分割</p>
<h3 id="三、findall()">三、findall()</h3><p>findall函数返回的总是正则表达式在字符串中所有匹配结果的列表。</p>
<pre><code>In [<span class="number">2</span>]: <span class="tag">p</span> = re.<span class="function"><span class="title">compile</span><span class="params">(r<span class="string">'\d+'</span>)</span></span>

In [<span class="number">4</span>]: <span class="tag">p</span>.<span class="function"><span class="title">findall</span><span class="params">(<span class="string">'one1two2three3four4'</span>)</span></span>
Out[<span class="number">4</span>]: [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>]

In [<span class="number">5</span>]: ss = <span class="string">"adfad asdfasdf asdfas asdfawef asd adsfas "</span>

In [<span class="number">6</span>]: <span class="tag">p</span> = re.<span class="function"><span class="title">compile</span><span class="params">(<span class="string">'((\w+)\s+\w+)'</span>)</span></span>

In [<span class="number">7</span>]: <span class="tag">p</span>.<span class="function"><span class="title">findall</span><span class="params">(ss)</span></span>
Out[<span class="number">7</span>]:
[(<span class="string">'adfad asdfasdf'</span>, <span class="string">'adfad'</span>),
 (<span class="string">'asdfas asdfawef'</span>, <span class="string">'asdfas'</span>),
 (<span class="string">'asd adsfas'</span>, <span class="string">'asd'</span>)]

In [<span class="number">8</span>]: <span class="tag">p</span> = re.<span class="function"><span class="title">compile</span><span class="params">(<span class="string">'(\w+)\s+\w+'</span>)</span></span>

In [<span class="number">9</span>]: <span class="tag">p</span>.<span class="function"><span class="title">findall</span><span class="params">(ss)</span></span>
Out[<span class="number">9</span>]: [<span class="string">'adfad'</span>, <span class="string">'asdfas'</span>, <span class="string">'asd'</span>]
</code></pre><ol>
<li><p>当给出的正则表达式中不带括号时，列表的元素为字符串，此字符串为整个正则表达式匹配的内容。 </p>
</li>
<li><p>当正则表达式中带有多个括号时，列表的元素为多个字符串组成的tuple，tuple中字符串个数与括号对数相同，字符串内容与每个括号内的正则表达式相对应，并且排放顺序是按括号出现的顺序。</p>
</li>
<li><p>当给出的正则表达式中带有一个括号时，列表的元素为字符串，此字符串的内容与括号中的正则表达式相对应。</p>
</li>
</ol>
<h3 id="四、re-search()">四、re.search()</h3><p>re.search函数会在字符串内查找模式匹配，只要找到第一个匹配就返回，如果字符串没有匹配，则返回None。</p>
<pre><code>In [<span class="number">15</span>]: text = <span class="string">"JGood is a handsome boy, he is cool, clever, and so on..."</span>

In [<span class="number">16</span>]: m = re.search(<span class="string">r'(\w+)ome'</span>, text)

In [<span class="number">20</span>]: <span class="keyword">if</span> m:
   ....: <span class="keyword">print</span> m.group(<span class="number">0</span>), m.group(<span class="number">1</span>)
   ....: <span class="keyword">else</span>:
   ....: <span class="keyword">print</span> <span class="string">'not search'</span>
</code></pre><p>其中 group(0）或group()匹配的是整个字符串，group(1)匹配的是第一个括号中内容。   </p>
<h3 id="五、re-match()">五、re.match()</h3><p>re.match()和re.search()的区别：re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</p>
<pre><code><span class="keyword">In</span> [30]: s1 = <span class="string">"helloworld, i am 30!"</span>

<span class="keyword">In</span> [31]: w1 = 'world'

<span class="keyword">In</span> [32]: m1 = re.<span class="literal">match</span>(w1, s1)

<span class="keyword">In</span> [33]: <span class="keyword">if</span> m1:
   ....:     <span class="keyword">print</span> m1.<span class="literal">group</span>()
   ....: <span class="keyword">else</span>:
   ....:     <span class="keyword">print</span> <span class="string">"not find"</span>
   ....:
not find
</code></pre><h3 id="六、re-sub()">六、re.sub()</h3><p>re.sub用于替换字符串中的匹配项。<br>下面的例子将字符串中的空格’ ‘替换成’-‘</p>
<pre><code>In [<span class="number">2</span>]: text = <span class="string">"JGood is a handsome boy, he is cool, clever, and so on..."</span>

In [<span class="number">3</span>]: re.sub(<span class="string">r'\s+'</span>, <span class="string">'-'</span>, text)
Out[<span class="number">3</span>]: <span class="string">'JGood-is-a-handsome-boy,-he-is-cool,-clever,-and-so-on...'</span>
</code></pre><p><strong>re.sub的函数原型为：re.sub(pattern, repl, string, count)</strong></p>
<pre><code>其中第二个参数时替换后的字符串；
第四个参数为替换个数。默认为<span class="number">0</span>，表示每个匹配项都替换。
</code></pre><p>re.sub还允许使用函数对匹配项的替换进行复杂的处理。如：</p>
<pre><code>re.sub(<span class="string">r'\s'</span>, <span class="keyword">lambda</span> m : <span class="string">'['</span> + m.group(<span class="number">0</span>) + <span class="string">']'</span>, text, <span class="number">0</span>)
</code></pre><p>将字符串中的空格’‘替换为’[]’。</p>
<h3 id="七、re-compile()">七、re.compile()</h3><p>可以把正则表达式编译成一个正则表达式对象。对于经常要用的正则表达式，可以提高一定的效率。</p>
<pre><code>In [<span class="number">4</span>]: text = <span class="string">"JGood is a handsome boy, he is cool, clever, and so on..."</span>

In [<span class="number">6</span>]: regex = re.compile(<span class="string">r'\w*oo\w*'</span>)

In [<span class="number">7</span>]: regex.findall(text) <span class="comment">#查找所有包含’oo‘的单词</span>
Out[<span class="number">7</span>]: [<span class="string">'JGood'</span>, <span class="string">'cool'</span>]

In [<span class="number">8</span>]: regex.sub(<span class="keyword">lambda</span> m : <span class="string">'['</span> + m.group(<span class="number">0</span>) + <span class="string">']'</span>, text) <span class="comment"># 将字符串中含有’oo‘的单词用[]括起来</span>
Out[<span class="number">8</span>]: <span class="string">'[JGood] is a handsome boy, he is [cool], clever, and so on...'</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>许多语言处理任务都涉及模式匹配。例如,可以使用endswith(‘ed’)找出以“ed”结尾的词。正则表达式提出了一个更加强大和灵活的方法描述感兴趣的字符模式。在Python中使用正则表达式，需要使用import re导入re函数库。</p>
<p><strong>下表为正则表达式基本元字符，其中包括通配符、范围和闭包</strong><br>]]>
    
    </summary>
    
      <category term="Python" scheme="http://www.kekefund.com/tags/Python/"/>
    
      <category term="re" scheme="http://www.kekefund.com/tags/re/"/>
    
      <category term="模式匹配" scheme="http://www.kekefund.com/tags/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    
      <category term="正则表达式" scheme="http://www.kekefund.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="Python" scheme="http://www.kekefund.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[期货大作手风云录 读书笔记]]></title>
    <link href="http://www.kekefund.com/2015/11/06/fengyunlu-md/"/>
    <id>http://www.kekefund.com/2015/11/06/fengyunlu-md/</id>
    <published>2015-11-06T07:09:20.000Z</published>
    <updated>2015-11-19T04:52:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="期货大作手风云录">期货大作手风云录</h1><h3 id="读书笔记">读书笔记</h3><h2 id="一、趋势">一、趋势</h2><ol>
<li><strong>投机法则之一：放鱼头，弃鱼尾，吃鱼肚。一个品种的趋势行情分为鱼头、鱼肚和鱼尾行情。鱼头行情往往是趋势行情初始起步阶段，你很难分期是反转还是反弹，所以很难吃到。鱼尾行情往往是一波趋势行情的末端，最大的特点是连续的逼空或者逼多，一方认输出局，所谓多头不死空头不止，这种鱼尾行情随时有可能反转或者巨幅震荡，不吃也罢。而在我看来，我们期货作手真正需要去大吃、狠吃的阶段是鱼肚行情，此时趋势已成，行情进三退一，这是才是我们需要重仓且不断浮盈加仓大口吃肉的好时机。</strong><a id="more"></a></li>
<li><strong>判断大势的方法有很多，有通过技术面判断的，也有通过基本面判断的，但今天要强调只有两点：第一，政治大于经济。当你做多或者做空某商品时，首先考虑的不应该是供需关系，而是该商品的政治因素。简单点说，现在的世界超级大国仍然是美国，如果你发现近期由于政治原因需要石油价格上涨时，即使供需和技术面都支持你做空，你也应该果断放弃。特别是石油、铜、黄金这类关系到美国切身利益的期货品种，尤其不能和美国政府对着干。</strong></li>
<li><strong>关于如何判断大势的第二点，我要强调的是：整体趋势大于个体趋势。具体来说，当大多数商品都处于上涨周期时，不要轻易去做空任何一个商品，特别是对于股票市场来说，如果现在大势处于熊市，即使基本面和技术面再好的股票，也不要去做多。切记这一点。</strong></li>
<li><strong>如果市场处于牛市中，而某个商品或者股票没有上涨，这反而是去做多它的好时机呢？ 错。做多只做龙头，做空只做熊头。记住，股价永远不会因为太高二停止上涨，同样的，股价也永远不会因为太低而停止下跌。重势不重价。只有龙头和熊头才会带给你超额的利润，其他的品种根本没必要去关注他们。</strong></li>
<li><strong>期货市场的行情分为趋势行情和震荡行情。市场的80%的时间都处于震荡行情之中，只有20%的趋势行情才能让我们赚大钱。但遗憾的是，绝大多数投机者总想抓住市场的每一个机会，总想像上班一样每天都能赚到钱，结果是在80%的震荡行情中赔掉了大部分的钱。周而复始，恶性循环。</strong></li>
</ol>
<h2 id="二、法则">二、法则</h2><ol>
<li><strong>“止语”的修行方法来自佛法的戒定慧：先戒，戒能生定，而定后能生慧。此乃佛法的博大精深也！</strong></li>
<li><p><strong>行情在绝望中产生，行情在犹豫中发展，行情在热闹中高潮，行情在兴奋中灭亡。</strong></p>
</li>
<li><p><strong>有人的地方就有江湖，有资金的地方就有大行情。这句话在期货里一点不假。</strong></p>
</li>
<li><strong>草原生物链中最厉害的角色是鳄鱼。因为鳄鱼有足够的耐心、信心和狠心。所谓耐心，就是指鳄鱼从来不随便游来游去去寻找猎物，这样多半是白白耗费体力。鳄鱼总是耐心的潜伏在水塘里，趴在猎物必须要喝水的地方，静静地耐心等待猎物自己找上门来；所谓信心，就是指鳄鱼不管几天没有遇到猎物，即使他已经饥肠辘辘，但他还会继续有信心的待在原地等待猎物，直到猎物出现；所谓狠心，就是指一旦猎物出现在鳄鱼的射程之内，它会毫不犹豫的发起攻击，一击致命，绝不嘴软，直到把猎物彻底咬死。鳄鱼的这三个特点，决定了他能在物竞天择的生物链里顽强的活到现在。而这三个特点，也是我们期货作手最需要具备的。</strong></li>
<li><strong>简单的事实是，行情总是先发生变化，然后才有经济新闻，市场不会对经济新闻作出反应。市场是活的，它反映的是将来。因此，企图genuine当前的经济新闻和当前的事件预测股市的走势是非常愚蠢的。贪婪和恐惧一样，都会扭曲理性。股市只讲事实，只讲现实，只讲理性，股市永远不会错，错的是交易者。</strong></li>
<li><strong>投资法则：只相信自己的眼睛，不要相信自己的耳朵！只相信自己的大脑，不要相信别人的建议！</strong></li>
<li><strong>期货最怕的就是快！很多时候，快就是慢！快的同义词就是风险。当你的账户盈利曲线越陡峭，你越应该引起高度的警惕，因为快速的都是短暂的，只有缓慢的才是稳定的。切记，做期货比的不是谁赢得多，而是看谁活得长。切记！</strong></li>
<li><strong>人如果犯错误，那用不了一个月就能拥有整个世界。但是反过来，如果一个人不能从自己的错误中汲取经验教训，他迟早一文不名。</strong></li>
<li><strong>投机于赌博的最大区别在于是否拥有大局观。</strong></li>
</ol>
<h2 id="三、操作">三、操作</h2><ol>
<li><p><strong>期货的魅力在于浮盈加仓，只有不断的浮盈加仓，我们才能赚取超额的巨大利润。但浮盈加仓的勇气来源于哪里？只有不断的盈利才是我们加仓的勇气！这就像你去带一支军队打仗，什么才是你们官兵不断勇敢冲锋的动力？唯有胜利！只有你的账户不断盈利了，你才有勇气去加仓，去继续以小搏大。</strong></p>
</li>
<li><p><strong>期货行业内有一句话，叫做：赚或赔靠本事，赚多赚少靠运气。也就是说，如果你赔了，那是你分析不到位，说明你没本事，如果你赚了，那么赚多赚少就要靠运气和天意了。</strong></p>
</li>
<li><p><strong>从某种意义上来说，投资并不是一个天道酬勤的行业。这个行业的秘诀在于节奏。会买的是徒弟，会卖的是师父，会空仓休息的是大事。对于期货作手来说，等待和寂寞也许是陪伴他一生的修炼法门。</strong></p>
</li>
<li><p><strong>既然是重仓，为什么利弗莫尔还要逐步建仓？为什么不能一次性重仓呢？那是因为谁也不敢保证自己一定是对的。只有账单上的盈利数字会告诉你对还是错，盈利了就加仓，亏损了就止损，让盈利奔跑，让亏损尽快了结。这是投机的不二法则。</strong></p>
</li>
<li><p><strong>一旦我们试仓之后市场朝着有利于我们的方向行进，我们有了浮盈，那么就开始倒金字塔加仓，就像利弗莫尔那样，1，2，4，8似的加仓，这样你的仓位自然就上来了，记住，股票永远不会因为价格太高而不可买进，或者因为价格太低而不可卖出。在你第一笔交易之后，除非第一笔交易有利润，否则就不可做第二笔。切记！</strong></p>
</li>
<li><p><strong>股市不是法庭，他不会跟你讲道理。股市更像是战场，他只会用实力去说话。打仗靠枪，炒股靠钱。所以，钱就是股票上涨的最终动力。当你发现一只股票价格开始不断上涨时，我们不用去刻意分析股票上涨的背后原因是什么，不要去打探他的消息，也不用去分析他的基本面有何变化，你只需去判断一个问题，是不是有大资金入场买股票了？只要有钱进来，什么技术面，什么基本面，什么重组消息，都会陆陆续续浮出水面的。原因很简单，大资金绝不会随随便便买入一只股票，他一定会把后面的故事给你讲得圆圆满满的！</strong></p>
</li>
<li><p><strong>原来人面来到投机市场的目的是不同的：有人是来过瘾的，因为频繁交易本身会带来快感；有的是来逛街的，只看不买，娱乐而已；还有极少数人是来赚钱的，他们需要时刻克制自己交易的冲动。。。</strong></p>
</li>
<li><p><strong>有句话说得好：在市场里，多头可以赚钱，空头也可以赚钱，但滑头早晚会死掉。</strong></p>
</li>
<li><p><strong>市场趋势显示下跌，但政府希望绿豆止跌，当市场和政府观点相反时，我选择空仓观望。期货比的不是谁赚的最多，而是比谁活得最长。方向不明时，空仓就是最好的策略。</strong></p>
</li>
<li><p><strong>期货往往就是这样，一开始就出现浮亏的持仓往往最终都很难赚钱。好的开始是成功的一半，这话在期货市场一点不假。</strong></p>
</li>
<li><p><strong>期货是个概率游戏。我们这些期货作手终生追求的目标只有一个：大赚小赔。也就是说，100次交易中，你失败90次也没关系，关键是如何在你作对的10次交易中，把盈利放大到远远超过你做错的90次亏损。</strong></p>
</li>
<li><p><strong>绝不能让自己盈利的单子变为亏损！这是期货投机的重要原则。以做多为例，随着你的分步建仓，你的持仓成本是在不断提高的，由于你是浮盈加仓，所以你应该是一直处于盈利中的，而盈利中的单子需要设立止盈点，这个止盈点就应该设立在你的持仓成本之上。一旦市场发生反向波动，如果触及到你的止盈点，你就应该毫不犹豫的平仓止盈。绝对不能让你原来盈利的单子面临亏损的可能，这是原则问题。止盈点因人而异，我的个人习惯是把止盈点设在最近的一次加仓点上。我的逻辑很简单：如果市场价格跌破了我的最近一次加仓点，那至少说明我这最后一次加仓的时机是错误的。既然错误了，我就要付出代价，所谓的代价就是全部平仓出局观望。我绝对不允许自己的盈利单变成亏损单。</strong></p>
</li>
<li><p><strong>在我看来，股票基本面分析的精髓不在于分析公司未来的盈利能力，而在于分析公司股票的供求关系。简单来说，就是在股市里，到底是买股票的人多？还是卖股票的人多？如果在一段时间内，主动卖股票的人大大多于卖股票的人，那就是供不应求，股价就会持续上涨，反之，如果主动卖股票的人多于买股票的人，那就是供大于求，股价就会持续下跌。供求决定价格，这才是我理解的基本面分析。</strong></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="期货大作手风云录">期货大作手风云录</h1><h3 id="读书笔记">读书笔记</h3><h2 id="一、趋势">一、趋势</h2><ol>
<li><strong>投机法则之一：放鱼头，弃鱼尾，吃鱼肚。一个品种的趋势行情分为鱼头、鱼肚和鱼尾行情。鱼头行情往往是趋势行情初始起步阶段，你很难分期是反转还是反弹，所以很难吃到。鱼尾行情往往是一波趋势行情的末端，最大的特点是连续的逼空或者逼多，一方认输出局，所谓多头不死空头不止，这种鱼尾行情随时有可能反转或者巨幅震荡，不吃也罢。而在我看来，我们期货作手真正需要去大吃、狠吃的阶段是鱼肚行情，此时趋势已成，行情进三退一，这是才是我们需要重仓且不断浮盈加仓大口吃肉的好时机。</strong>]]>
    
    </summary>
    
      <category term="期货" scheme="http://www.kekefund.com/tags/%E6%9C%9F%E8%B4%A7/"/>
    
      <category term="股票" scheme="http://www.kekefund.com/tags/%E8%82%A1%E7%A5%A8/"/>
    
      <category term="Stock" scheme="http://www.kekefund.com/categories/Stock/"/>
    
  </entry>
  
</feed>
